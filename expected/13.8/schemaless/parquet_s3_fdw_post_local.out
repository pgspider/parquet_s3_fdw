\set ECHO none
show server_version \gset
\ir sql/:server_version/schemaless/parquet_s3_fdw_post.sql
-- ===================================================================
-- create FDW objects
-- ===================================================================
--Testcase 1:
CREATE EXTENSION parquet_s3_fdw;
--Testcase 2:
CREATE SERVER parquet_s3_srv FOREIGN DATA WRAPPER parquet_s3_fdw
      :USE_MINIO;
--Testcase 3:
CREATE SERVER parquet_s3_srv_2 FOREIGN DATA WRAPPER parquet_s3_fdw
      :USE_MINIO;
--Testcase 4:
CREATE SERVER parquet_s3_srv_3 FOREIGN DATA WRAPPER parquet_s3_fdw
      :USE_MINIO;
--Testcase 5:
CREATE USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv :USER_PASSWORD;
--Testcase 6:
CREATE USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv_2 :USER_PASSWORD;
--Testcase 7:
CREATE USER MAPPING FOR public SERVER parquet_s3_srv_3 :USER_PASSWORD;
-- ===================================================================
-- create objects used through FDW loopback server
-- ===================================================================
--Testcase 8:
CREATE TYPE user_enum AS ENUM ('foo', 'bar', 'buz');
--Testcase 9:
CREATE SCHEMA "S 1";
\set var '\"':PATH_FILENAME'\/ported_postgres\"'
IMPORT FOREIGN SCHEMA :var FROM SERVER parquet_s3_srv INTO "S 1" OPTIONS (sorted 'c1', schemaless 'true');
-- -- Disable autovacuum for these tables to avoid unexpected effects of that
-- ALTER TABLE "S 1"."T1" SET (autovacuum_enabled = 'false');
-- ALTER TABLE "S 1"."T2" SET (autovacuum_enabled = 'false');
-- ALTER TABLE "S 1"."T3" SET (autovacuum_enabled = 'false');
-- ALTER TABLE "S 1"."T4" SET (autovacuum_enabled = 'false');
-- ANALYZE "S 1"."T1";
-- ANALYZE "S 1"."T2";
-- ANALYZE "S 1"."T3";
-- ANALYZE "S 1"."T4";
-- ===================================================================
-- create foreign tables
-- ===================================================================
\set var :PATH_FILENAME'/ported_postgres/ft1.parquet'
--Testcase 10:
CREATE FOREIGN TABLE ft1 (
	c0 int,
  v jsonb
) SERVER parquet_s3_srv
OPTIONS (filename :'var', key_columns 'c1', sorted 'c1', schemaless 'true');
--Testcase 446:
ALTER FOREIGN TABLE ft1 DROP COLUMN c0;
\set var :PATH_FILENAME'/ported_postgres/ft1.parquet'
--Testcase 11:
CREATE FOREIGN TABLE ft2 (
  v jsonb,
	cx int
) SERVER parquet_s3_srv
OPTIONS (filename :'var', key_columns 'c1', sorted 'c1', schemaless 'true');
--Testcase 447:
ALTER FOREIGN TABLE ft2 DROP COLUMN cx;
\set var :PATH_FILENAME'/ported_postgres/T3.parquet'
--Testcase 12:
CREATE FOREIGN TABLE ft4 (
  v jsonb
) SERVER parquet_s3_srv
OPTIONS (filename :'var', key_columns 'c1', sorted 'c1', schemaless 'true');
\set var :PATH_FILENAME'/ported_postgres/T4.parquet'
--Testcase 13:
CREATE FOREIGN TABLE ft5 (
	v jsonb
) SERVER parquet_s3_srv
OPTIONS (filename :'var', key_columns 'c1', sorted 'c1', schemaless 'true');
\set var :PATH_FILENAME'/ported_postgres/T4.parquet'
--Testcase 14:
CREATE FOREIGN TABLE ft6 (
	v jsonb
) SERVER parquet_s3_srv_2
OPTIONS (filename :'var', key_columns 'c1', sorted 'c1', schemaless 'true');
\set var :PATH_FILENAME'/ported_postgres/T4.parquet'
--Testcase 15:
CREATE FOREIGN TABLE ft7 (
	v jsonb
) SERVER parquet_s3_srv_3
OPTIONS (filename :'var', key_columns 'c1', sorted 'c1', schemaless 'true');
-- -- ===================================================================
-- -- tests for validator
-- -- ===================================================================
-- -- requiressl and some other parameters are omitted because
-- -- valid values for them depend on configure options
-- ALTER SERVER testserver1 OPTIONS (
-- 	use_remote_estimate 'false',
-- 	updatable 'true',
-- 	fdw_startup_cost '123.456',
-- 	fdw_tuple_cost '0.123',
-- 	service 'value',
-- 	connect_timeout 'value',
-- 	dbname 'value',
-- 	host 'value',
-- 	hostaddr 'value',
-- 	port 'value',
-- 	--client_encoding 'value',
-- 	application_name 'value',
-- 	--fallback_application_name 'value',
-- 	keepalives 'value',
-- 	keepalives_idle 'value',
-- 	keepalives_interval 'value',
-- 	tcp_user_timeout 'value',
-- 	-- requiressl 'value',
-- 	sslcompression 'value',
-- 	sslmode 'value',
-- 	sslcert 'value',
-- 	sslkey 'value',
-- 	sslrootcert 'value',
-- 	sslcrl 'value',
-- 	--requirepeer 'value',
-- 	krbsrvname 'value',
-- 	gsslib 'value'
-- 	--replication 'value'
-- );
-- -- Error, invalid list syntax
-- ALTER SERVER testserver1 OPTIONS (ADD extensions 'foo; bar');
-- -- OK but gets a warning
-- ALTER SERVER testserver1 OPTIONS (ADD extensions 'foo, bar');
-- ALTER SERVER testserver1 OPTIONS (DROP extensions);
-- ALTER USER MAPPING FOR public SERVER testserver1
-- 	OPTIONS (DROP user, DROP password);
-- -- Attempt to add a valid option that's not allowed in a user mapping
-- ALTER USER MAPPING FOR public SERVER testserver1
-- 	OPTIONS (ADD sslmode 'require');
-- -- But we can add valid ones fine
-- ALTER USER MAPPING FOR public SERVER testserver1
-- 	OPTIONS (ADD sslpassword 'dummy');
-- -- Ensure valid options we haven't used in a user mapping yet are
-- -- permitted to check validation.
-- ALTER USER MAPPING FOR public SERVER testserver1
-- 	OPTIONS (ADD sslkey 'value', ADD sslcert 'value');
-- ALTER FOREIGN TABLE ft1 OPTIONS (schema_name 'S 1', table_name 'T 1');
-- ALTER FOREIGN TABLE ft2 OPTIONS (schema_name 'S 1', table_name 'T 1');
-- ALTER FOREIGN TABLE ft1 ALTER COLUMN v->>'c1' OPTIONS (column_name 'C 1');
-- ALTER FOREIGN TABLE ft2 ALTER COLUMN v->>'c1' OPTIONS (column_name 'C 1');
-- \det+
-- Test that alteration of server options causes reconnection
-- Remote's errors might be non-English, so hide them to ensure stable results
\set VERBOSITY terse
--Testcase 16:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should work
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

--Testcase 448:
ALTER SERVER parquet_s3_srv OPTIONS (SET use_minio 'false');
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:169: ERROR:  option "use_minio" not found
--Testcase 17:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should fail if only when we use minio/s3. With local file, option use_minio is useless.
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

DO $d$
    BEGIN
        EXECUTE $$ALTER SERVER parquet_s3_srv
            OPTIONS (SET use_minio 'true')$$;
    END;
$d$;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:177: ERROR:  option "use_minio" not found
--Testcase 18:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should work again
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

-- Test that alteration of user mapping options causes reconnection
--Testcase 449:
ALTER USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv
  OPTIONS (SET user 'no such user');
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:184: ERROR:  option "user" not found
--Testcase 19:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should fail if only when we use minio/s3. With local file, option user is useless.
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

--Testcase 450:
ALTER USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv
  OPTIONS (SET user 'minioadmin');
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:189: ERROR:  option "user" not found
--Testcase 20:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should work again
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

\set VERBOSITY default
-- Now we should be able to run ANALYZE.
-- To exercise multiple code paths, we use local stats on ft1
-- and remote-estimate mode on ft2.
-- ANALYZE ft1;
-- ALTER FOREIGN TABLE ft2 OPTIONS (use_remote_estimate 'true');
-- ===================================================================
-- simple queries
-- ===================================================================
-- single table without alias
--Testcase 21:
EXPLAIN (COSTS OFF) SELECT * FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 OFFSET 100 LIMIT 10;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   ->  Sort
         Sort Key: ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on ft1
               Reader: Single File
               Row groups: 1
(6 rows)

--Testcase 22:
SELECT * FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 101, "c2": 1, "c3": "00101", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 102, "c2": 2, "c3": "00102", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 103, "c2": 3, "c3": "00103", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 104, "c2": 4, "c3": "00104", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
 {"c1": 105, "c2": 5, "c3": "00105", "c5": "Tue Jan 06 00:00:00 1970", "c6": "5", "c7": "5", "c8": "foo"}
 {"c1": 106, "c2": 6, "c3": "00106", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 107, "c2": 7, "c3": "00107", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 108, "c2": 8, "c3": "00108", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 109, "c2": 9, "c3": "00109", "c5": "Sat Jan 10 00:00:00 1970", "c6": "9", "c7": "9", "c8": "foo"}
 {"c1": 110, "c2": 0, "c3": "00110", "c5": "Sun Jan 11 00:00:00 1970", "c6": "0", "c7": "0", "c8": "foo"}
(10 rows)

-- single table with alias - also test that tableoid sort is not pushed to remote side
--Testcase 23:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8, t1.tableoid OFFSET 100 LIMIT 10;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit
   Output: v, ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint), tableoid
   ->  Sort
         Output: v, ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint), tableoid
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint), t1.tableoid
         ->  Foreign Scan on public.ft1 t1
               Output: v, (v ->> 'c3'::text), ((v ->> 'c1'::text))::bigint, tableoid
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 24:
SELECT * FROM ft1 t1 ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8, t1.tableoid OFFSET 100 LIMIT 10;
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 101, "c2": 1, "c3": "00101", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 102, "c2": 2, "c3": "00102", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 103, "c2": 3, "c3": "00103", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 104, "c2": 4, "c3": "00104", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
 {"c1": 105, "c2": 5, "c3": "00105", "c5": "Tue Jan 06 00:00:00 1970", "c6": "5", "c7": "5", "c8": "foo"}
 {"c1": 106, "c2": 6, "c3": "00106", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 107, "c2": 7, "c3": "00107", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 108, "c2": 8, "c3": "00108", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 109, "c2": 9, "c3": "00109", "c5": "Sat Jan 10 00:00:00 1970", "c6": "9", "c7": "9", "c8": "foo"}
 {"c1": 110, "c2": 0, "c3": "00110", "c5": "Sun Jan 11 00:00:00 1970", "c6": "0", "c7": "0", "c8": "foo"}
(10 rows)

-- whole-row reference
--Testcase 25:
EXPLAIN (VERBOSE, COSTS OFF) SELECT t1 FROM ft1 t1 ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t1.*, ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: t1.*, ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint)
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.*, (v ->> 'c3'::text), ((v ->> 'c1'::text))::bigint
               Reader: Single File
               Row groups: 1
(9 rows)

-- parquet_s3_fdw only fill slot attributes if column was referred in targetlist or clauses. In other cases mark attribute as NULL.
--Testcase 26:
SELECT t1 FROM ft1 t1 ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                                  t1                                                                  
--------------------------------------------------------------------------------------------------------------------------------------
 ("{""c1"": 101, ""c2"": 1, ""c3"": ""00101"", ""c5"": ""Fri Jan 02 00:00:00 1970"", ""c6"": ""1"", ""c7"": ""1"", ""c8"": ""foo""}")
 ("{""c1"": 102, ""c2"": 2, ""c3"": ""00102"", ""c5"": ""Sat Jan 03 00:00:00 1970"", ""c6"": ""2"", ""c7"": ""2"", ""c8"": ""foo""}")
 ("{""c1"": 103, ""c2"": 3, ""c3"": ""00103"", ""c5"": ""Sun Jan 04 00:00:00 1970"", ""c6"": ""3"", ""c7"": ""3"", ""c8"": ""foo""}")
 ("{""c1"": 104, ""c2"": 4, ""c3"": ""00104"", ""c5"": ""Mon Jan 05 00:00:00 1970"", ""c6"": ""4"", ""c7"": ""4"", ""c8"": ""foo""}")
 ("{""c1"": 105, ""c2"": 5, ""c3"": ""00105"", ""c5"": ""Tue Jan 06 00:00:00 1970"", ""c6"": ""5"", ""c7"": ""5"", ""c8"": ""foo""}")
 ("{""c1"": 106, ""c2"": 6, ""c3"": ""00106"", ""c5"": ""Wed Jan 07 00:00:00 1970"", ""c6"": ""6"", ""c7"": ""6"", ""c8"": ""foo""}")
 ("{""c1"": 107, ""c2"": 7, ""c3"": ""00107"", ""c5"": ""Thu Jan 08 00:00:00 1970"", ""c6"": ""7"", ""c7"": ""7"", ""c8"": ""foo""}")
 ("{""c1"": 108, ""c2"": 8, ""c3"": ""00108"", ""c5"": ""Fri Jan 09 00:00:00 1970"", ""c6"": ""8"", ""c7"": ""8"", ""c8"": ""foo""}")
 ("{""c1"": 109, ""c2"": 9, ""c3"": ""00109"", ""c5"": ""Sat Jan 10 00:00:00 1970"", ""c6"": ""9"", ""c7"": ""9"", ""c8"": ""foo""}")
 ("{""c1"": 110, ""c2"": 0, ""c3"": ""00110"", ""c5"": ""Sun Jan 11 00:00:00 1970"", ""c6"": ""0"", ""c7"": ""0"", ""c8"": ""foo""}")
(10 rows)

-- empty result
--Testcase 27:
SELECT * FROM ft1 WHERE false;
 v 
---
(0 rows)

-- with WHERE clause
--Testcase 28:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = 101 AND (t1.v->>'c6')::int = '1' AND (t1.v->>'c7')::int >= '1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((((t1.v ->> 'c7'::text))::integer >= 1) AND (((t1.v ->> 'c1'::text))::bigint = 101) AND (((t1.v ->> 'c6'::text))::integer = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 29:
SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = 101 AND (t1.v->>'c6')::int = '1' AND (t1.v->>'c7')::int >= '1';
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 101, "c2": 1, "c3": "00101", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- with FOR UPDATE/SHARE
--Testcase 30:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = 101 FOR UPDATE;
                       QUERY PLAN                        
---------------------------------------------------------
 LockRows
   Output: v, t1.*
   ->  Foreign Scan on public.ft1 t1
         Output: v, t1.*
         Filter: (((t1.v ->> 'c1'::text))::bigint = 101)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 31:
SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = 101 FOR UPDATE;
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 101, "c2": 1, "c3": "00101", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

--Testcase 32:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = 102 FOR SHARE;
                       QUERY PLAN                        
---------------------------------------------------------
 LockRows
   Output: v, t1.*
   ->  Foreign Scan on public.ft1 t1
         Output: v, t1.*
         Filter: (((t1.v ->> 'c1'::text))::bigint = 102)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 33:
SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = 102 FOR SHARE;
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 102, "c2": 2, "c3": "00102", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
(1 row)

-- aggregate
--Testcase 34:
SELECT COUNT(*) FROM ft1 t1;
 count 
-------
  1000
(1 row)

-- subquery
--Testcase 35:
SELECT * FROM ft1 t1 WHERE t1.v->>'c3' IN (SELECT v->>'c3' FROM ft2 t2 WHERE (v->>'c1')::int8 <= 10) ORDER BY (v->>'c1')::int8;
                                                    v                                                    
---------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 2, "c2": 2, "c3": "00002", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 3, "c2": 3, "c3": "00003", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 4, "c2": 4, "c3": "00004", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
 {"c1": 5, "c2": 5, "c3": "00005", "c5": "Tue Jan 06 00:00:00 1970", "c6": "5", "c7": "5", "c8": "foo"}
 {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 7, "c2": 7, "c3": "00007", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 8, "c2": 8, "c3": "00008", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 9, "c2": 9, "c3": "00009", "c5": "Sat Jan 10 00:00:00 1970", "c6": "9", "c7": "9", "c8": "foo"}
 {"c1": 10, "c2": 0, "c3": "00010", "c5": "Sun Jan 11 00:00:00 1970", "c6": "0", "c7": "0", "c8": "foo"}
(10 rows)

-- subquery+MAX
--Testcase 36:
SELECT * FROM ft1 t1 WHERE t1.v->>'c3' = (SELECT MAX(v->>'c3') FROM ft2 t2) ORDER BY (v->>'c1')::int8;
                                                     v                                                     
-----------------------------------------------------------------------------------------------------------
 {"c1": 1000, "c2": 0, "c3": "01000", "c5": "Thu Jan 01 00:00:00 1970", "c6": "0", "c7": "0", "c8": "foo"}
(1 row)

-- used in CTE
--Testcase 37:
WITH t1 AS (SELECT * FROM ft1 WHERE (v->>'c1')::int8 <= 10) SELECT (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, t2.v->>'c3' as c3, t2.v->>'c5' as c5 FROM t1, ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 ORDER BY (t1.v->>'c1')::int8;
 c1 | c2 |  c3   |            c5            
----+----+-------+--------------------------
  1 |  1 | 00001 | Fri Jan 02 00:00:00 1970
  2 |  2 | 00002 | Sat Jan 03 00:00:00 1970
  3 |  3 | 00003 | Sun Jan 04 00:00:00 1970
  4 |  4 | 00004 | Mon Jan 05 00:00:00 1970
  5 |  5 | 00005 | Tue Jan 06 00:00:00 1970
  6 |  6 | 00006 | Wed Jan 07 00:00:00 1970
  7 |  7 | 00007 | Thu Jan 08 00:00:00 1970
  8 |  8 | 00008 | Fri Jan 09 00:00:00 1970
  9 |  9 | 00009 | Sat Jan 10 00:00:00 1970
 10 |  0 | 00010 | Sun Jan 11 00:00:00 1970
(10 rows)

-- fixed values
--Testcase 38:
SELECT 'fixed', NULL FROM ft1 t1 WHERE (v->>'c1')::int8 = 1;
 ?column? | ?column? 
----------+----------
 fixed    | 
(1 row)

-- Test forcing the remote server to produce sorted data for a merge join.
--Testcase 451:
SET enable_hashjoin TO false;
--Testcase 452:
SET enable_nestloop TO false;
-- inner join; expressions in the clauses appear in the equivalence class list
--Testcase 39:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft2 t1 JOIN "S 1"."T1" t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Merge Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft2 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on "S 1"."T1" t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(15 rows)

--Testcase 40:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft2 t1 JOIN "S 1"."T1" t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- outer join; expressions in the clauses do not appear in equivalence class
-- list but no output change as compared to the previous query
--Testcase 41:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft2 t1 LEFT JOIN "S 1"."T1" t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft2 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on "S 1"."T1" t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(15 rows)

--Testcase 42:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft2 t1 LEFT JOIN "S 1"."T1" t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- A join between local table and foreign join. ORDER BY clause is added to the
-- foreign join so that the local table can be joined using merge join strategy.
--Testcase 43:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 left join ft1 t2 join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint)
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t3.v
               ->  Merge Join
                     Output: t3.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t3.v
                           ->  Foreign Scan on public.ft2 t3
                                 Output: t3.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 44:
SELECT (t1.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 left join ft1 t2 join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  
-----
 101
 102
 103
 104
 105
 106
 107
 108
 109
 110
(10 rows)

-- Test similar to above, except that the full join prevents any equivalence
-- classes from being merged. This produces single relation equivalence classes
-- included in join restrictions.
--Testcase 45:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 left join ft1 t2 full join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t3.v, t2.v
               ->  Merge Left Join
                     Output: t3.v, t2.v
                     Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t3
                           Output: t3.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v
                           ->  Foreign Scan on public.ft1 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 46:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 left join ft1 t2 full join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  | c1  | c1  
-----+-----+-----
 101 | 101 | 101
 102 | 102 | 102
 103 | 103 | 103
 104 | 104 | 104
 105 | 105 | 105
 106 | 106 | 106
 107 | 107 | 107
 108 | 108 | 108
 109 | 109 | 109
 110 | 110 | 110
(10 rows)

-- Test similar to above with all full outer joins
--Testcase 47:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 full join ft1 t2 full join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   ->  Merge Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = (((t3.v ->> 'c1'::text))::bigint))
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Sort
               Output: t2.v, t3.v, (((t3.v ->> 'c1'::text))::bigint)
               Sort Key: (((t3.v ->> 'c1'::text))::bigint)
               ->  Merge Full Join
                     Output: t2.v, t3.v, ((t3.v ->> 'c1'::text))::bigint
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t3.v
                           ->  Foreign Scan on public.ft2 t3
                                 Output: t3.v
                                 Reader: Single File
                                 Row groups: 1
(25 rows)

--Testcase 48:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 full join ft1 t2 full join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  | c1  | c1  
-----+-----+-----
 101 | 101 | 101
 102 | 102 | 102
 103 | 103 | 103
 104 | 104 | 104
 105 | 105 | 105
 106 | 106 | 106
 107 | 107 | 107
 108 | 108 | 108
 109 | 109 | 109
 110 | 110 | 110
(10 rows)

--Testcase 453:
RESET enable_hashjoin;
--Testcase 454:
RESET enable_nestloop;
-- Test executing assertion in estimate_path_cost_size() that makes sure that
-- retrieved_rows for foreign rel re-used to cost pre-sorted foreign paths is
-- a sensible value even when the rel has tuples=0
\set var :PATH_FILENAME'/ported_postgres/loct_empty.parquet'
--Testcase 49:
CREATE FOREIGN TABLE ft_empty (v jsonb)
  SERVER parquet_s3_srv OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
-- ANALYZE ft_empty;
--Testcase 50:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft_empty ORDER BY (v->>'c1')::int8;
                QUERY PLAN                 
-------------------------------------------
 Foreign Scan on public.ft_empty
   Output: v, ((v ->> 'c1'::text))::bigint
   Reader: Single File
   Row groups: 1
(4 rows)

-- ===================================================================
-- WHERE with remotely-executable conditions
-- ===================================================================
--Testcase 51:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = 1;         -- Var, OpExpr(b), Const
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 52:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = 100 AND (t1.v->>'c2')::int = 0; -- BoolExpr
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((((t1.v ->> 'c1'::text))::bigint = 100) AND (((t1.v ->> 'c2'::text))::integer = 0))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 53:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 IS NULL;        -- NullTest
                     QUERY PLAN                      
-----------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint IS NULL)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 54:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 IS NOT NULL;    -- NullTest
                       QUERY PLAN                        
---------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint IS NOT NULL)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 55:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE round(abs((v->>'c1')::int8), 0) = 1; -- FuncExpr
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (round((abs(((t1.v ->> 'c1'::text))::bigint))::numeric, 0) = '1'::numeric)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 56:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = -(v->>'c1')::int8;          -- OpExpr(l)
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = (- ((t1.v ->> 'c1'::text))::bigint))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 57:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE ((v->>'c1')::int8 IS NOT NULL) IS DISTINCT FROM ((v->>'c1')::int8 IS NOT NULL); -- DistinctExpr
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((((t1.v ->> 'c1'::text))::bigint IS NOT NULL) IS DISTINCT FROM (((t1.v ->> 'c1'::text))::bigint IS NOT NULL))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 58:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = ANY(ARRAY[(v->>'c2')::int, 1, (v->>'c1')::int8 + 0]); -- ScalarArrayOpExpr
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = ANY (ARRAY[(((t1.v ->> 'c2'::text))::integer)::bigint, '1'::bigint, (((t1.v ->> 'c1'::text))::bigint + 0)]))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 59:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = (ARRAY[(v->>'c1')::int8,(v->>'c2')::int,3])[1]; -- SubscriptingRef
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = (ARRAY[((t1.v ->> 'c1'::text))::bigint, (((t1.v ->> 'c2'::text))::integer)::bigint, '3'::bigint])[1])
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 60:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE v->>'c6' = E'foo''s\\bar';  -- check special chars
                       QUERY PLAN                       
--------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((t1.v ->> 'c6'::text) = 'foo''s\bar'::text)
   Reader: Trivial
(4 rows)

--Testcase 61:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE v->>'c8' = 'foo';  -- can't be sent to remote
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((t1.v ->> 'c8'::text) = 'foo'::text)
   Reader: Single File
   Row groups: 1
(5 rows)

-- parameterized remote path for foreign table
--Testcase 62:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT * FROM "S 1"."T1" a, ft2 b WHERE (a.v->>'c1')::int8 = 47 AND (b.v->>'c1')::int8 = (a.v->>'c2')::int8;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Hash Join
   Output: a.v, b.v
   Hash Cond: (((b.v ->> 'c1'::text))::bigint = ((a.v ->> 'c2'::text))::bigint)
   ->  Foreign Scan on public.ft2 b
         Output: b.v
         Reader: Single File
         Row groups: 1
   ->  Hash
         Output: a.v
         ->  Foreign Scan on "S 1"."T1" a
               Output: a.v
               Filter: (((a.v ->> 'c1'::text))::bigint = 47)
               Reader: Single File
               Row groups: 1
(14 rows)

--Testcase 63:
SELECT * FROM ft2 a, ft2 b WHERE (a.v->>'c1')::int8 = 47 AND (b.v->>'c1')::int8 = (a.v->>'c2')::int8;
                                                    v                                                    |                                                   v                                                    
---------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------
 {"c1": 47, "c2": 7, "c3": "00047", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"} | {"c1": 7, "c2": 7, "c3": "00007", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
(1 row)

-- check both safe and unsafe join conditions
--Testcase 64:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT * FROM ft2 a, ft2 b
  WHERE (a.v->>'c2')::int = 6 AND (b.v->>'c1')::int8 = (a.v->>'c1')::int8 AND a.v->>'c8' = 'foo' AND b.v->>'c7' = upper(a.v->>'c7');
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: a.v, b.v
   Join Filter: ((upper((a.v ->> 'c7'::text)) = (b.v ->> 'c7'::text)) AND (((a.v ->> 'c1'::text))::bigint = ((b.v ->> 'c1'::text))::bigint))
   ->  Foreign Scan on public.ft2 a
         Output: a.v
         Filter: (((a.v ->> 'c8'::text) = 'foo'::text) AND (((a.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
   ->  Foreign Scan on public.ft2 b
         Output: b.v
         Reader: Single File
         Row groups: 1
(12 rows)

--Testcase 65:s
SELECT * FROM ft2 a, ft2 b
WHERE (a.v->>'c2')::int = 6 AND (b.v->>'c1')::int8 = (a.v->>'c1')::int8 AND a.v->>'c8' = 'foo' AND b.v->>'c7' = upper(a.v->>'c7');
                                                    v                                                     |                                                    v                                                     
----------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------
 {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}   | {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 26, "c2": 6, "c3": "00026", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 26, "c2": 6, "c3": "00026", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 56, "c2": 6, "c3": "00056", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 56, "c2": 6, "c3": "00056", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 66, "c2": 6, "c3": "00066", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 66, "c2": 6, "c3": "00066", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 76, "c2": 6, "c3": "00076", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 76, "c2": 6, "c3": "00076", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 86, "c2": 6, "c3": "00086", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 86, "c2": 6, "c3": "00086", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 96, "c2": 6, "c3": "00096", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 96, "c2": 6, "c3": "00096", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 106, "c2": 6, "c3": "00106", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 106, "c2": 6, "c3": "00106", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 116, "c2": 6, "c3": "00116", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 116, "c2": 6, "c3": "00116", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 126, "c2": 6, "c3": "00126", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 126, "c2": 6, "c3": "00126", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 136, "c2": 6, "c3": "00136", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 136, "c2": 6, "c3": "00136", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 146, "c2": 6, "c3": "00146", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 146, "c2": 6, "c3": "00146", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 156, "c2": 6, "c3": "00156", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 156, "c2": 6, "c3": "00156", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 166, "c2": 6, "c3": "00166", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 166, "c2": 6, "c3": "00166", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 176, "c2": 6, "c3": "00176", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 176, "c2": 6, "c3": "00176", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 186, "c2": 6, "c3": "00186", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 186, "c2": 6, "c3": "00186", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 196, "c2": 6, "c3": "00196", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 196, "c2": 6, "c3": "00196", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 206, "c2": 6, "c3": "00206", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 206, "c2": 6, "c3": "00206", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 216, "c2": 6, "c3": "00216", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 216, "c2": 6, "c3": "00216", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 226, "c2": 6, "c3": "00226", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 226, "c2": 6, "c3": "00226", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 236, "c2": 6, "c3": "00236", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 236, "c2": 6, "c3": "00236", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 246, "c2": 6, "c3": "00246", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 246, "c2": 6, "c3": "00246", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 256, "c2": 6, "c3": "00256", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 256, "c2": 6, "c3": "00256", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 266, "c2": 6, "c3": "00266", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 266, "c2": 6, "c3": "00266", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 276, "c2": 6, "c3": "00276", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 276, "c2": 6, "c3": "00276", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 286, "c2": 6, "c3": "00286", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 286, "c2": 6, "c3": "00286", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 296, "c2": 6, "c3": "00296", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 296, "c2": 6, "c3": "00296", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 306, "c2": 6, "c3": "00306", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 306, "c2": 6, "c3": "00306", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 316, "c2": 6, "c3": "00316", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 316, "c2": 6, "c3": "00316", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 326, "c2": 6, "c3": "00326", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 326, "c2": 6, "c3": "00326", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 336, "c2": 6, "c3": "00336", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 336, "c2": 6, "c3": "00336", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 346, "c2": 6, "c3": "00346", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 346, "c2": 6, "c3": "00346", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 356, "c2": 6, "c3": "00356", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 356, "c2": 6, "c3": "00356", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 366, "c2": 6, "c3": "00366", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 366, "c2": 6, "c3": "00366", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 376, "c2": 6, "c3": "00376", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 376, "c2": 6, "c3": "00376", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 386, "c2": 6, "c3": "00386", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 386, "c2": 6, "c3": "00386", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 396, "c2": 6, "c3": "00396", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 396, "c2": 6, "c3": "00396", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 406, "c2": 6, "c3": "00406", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 406, "c2": 6, "c3": "00406", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 416, "c2": 6, "c3": "00416", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 416, "c2": 6, "c3": "00416", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 426, "c2": 6, "c3": "00426", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 426, "c2": 6, "c3": "00426", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 436, "c2": 6, "c3": "00436", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 436, "c2": 6, "c3": "00436", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 446, "c2": 6, "c3": "00446", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 446, "c2": 6, "c3": "00446", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 456, "c2": 6, "c3": "00456", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 456, "c2": 6, "c3": "00456", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 466, "c2": 6, "c3": "00466", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 466, "c2": 6, "c3": "00466", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 476, "c2": 6, "c3": "00476", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 476, "c2": 6, "c3": "00476", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 486, "c2": 6, "c3": "00486", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 486, "c2": 6, "c3": "00486", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 496, "c2": 6, "c3": "00496", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 496, "c2": 6, "c3": "00496", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 506, "c2": 6, "c3": "00506", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 506, "c2": 6, "c3": "00506", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 516, "c2": 6, "c3": "00516", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 516, "c2": 6, "c3": "00516", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 526, "c2": 6, "c3": "00526", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 526, "c2": 6, "c3": "00526", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 536, "c2": 6, "c3": "00536", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 536, "c2": 6, "c3": "00536", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 546, "c2": 6, "c3": "00546", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 546, "c2": 6, "c3": "00546", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 556, "c2": 6, "c3": "00556", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 556, "c2": 6, "c3": "00556", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 566, "c2": 6, "c3": "00566", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 566, "c2": 6, "c3": "00566", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 576, "c2": 6, "c3": "00576", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 576, "c2": 6, "c3": "00576", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 586, "c2": 6, "c3": "00586", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 586, "c2": 6, "c3": "00586", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 596, "c2": 6, "c3": "00596", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 596, "c2": 6, "c3": "00596", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 606, "c2": 6, "c3": "00606", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 606, "c2": 6, "c3": "00606", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 616, "c2": 6, "c3": "00616", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 616, "c2": 6, "c3": "00616", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 626, "c2": 6, "c3": "00626", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 626, "c2": 6, "c3": "00626", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 636, "c2": 6, "c3": "00636", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 636, "c2": 6, "c3": "00636", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 646, "c2": 6, "c3": "00646", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 646, "c2": 6, "c3": "00646", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 656, "c2": 6, "c3": "00656", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 656, "c2": 6, "c3": "00656", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 666, "c2": 6, "c3": "00666", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 666, "c2": 6, "c3": "00666", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 676, "c2": 6, "c3": "00676", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 676, "c2": 6, "c3": "00676", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 686, "c2": 6, "c3": "00686", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 686, "c2": 6, "c3": "00686", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 696, "c2": 6, "c3": "00696", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 696, "c2": 6, "c3": "00696", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 706, "c2": 6, "c3": "00706", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 706, "c2": 6, "c3": "00706", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 716, "c2": 6, "c3": "00716", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 716, "c2": 6, "c3": "00716", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 726, "c2": 6, "c3": "00726", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 726, "c2": 6, "c3": "00726", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 736, "c2": 6, "c3": "00736", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 736, "c2": 6, "c3": "00736", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 746, "c2": 6, "c3": "00746", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 746, "c2": 6, "c3": "00746", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 756, "c2": 6, "c3": "00756", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 756, "c2": 6, "c3": "00756", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 766, "c2": 6, "c3": "00766", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 766, "c2": 6, "c3": "00766", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 776, "c2": 6, "c3": "00776", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 776, "c2": 6, "c3": "00776", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 786, "c2": 6, "c3": "00786", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 786, "c2": 6, "c3": "00786", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 796, "c2": 6, "c3": "00796", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 796, "c2": 6, "c3": "00796", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 806, "c2": 6, "c3": "00806", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 806, "c2": 6, "c3": "00806", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 816, "c2": 6, "c3": "00816", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 816, "c2": 6, "c3": "00816", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 826, "c2": 6, "c3": "00826", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 826, "c2": 6, "c3": "00826", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 836, "c2": 6, "c3": "00836", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 836, "c2": 6, "c3": "00836", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 846, "c2": 6, "c3": "00846", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 846, "c2": 6, "c3": "00846", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 856, "c2": 6, "c3": "00856", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 856, "c2": 6, "c3": "00856", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 866, "c2": 6, "c3": "00866", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 866, "c2": 6, "c3": "00866", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 876, "c2": 6, "c3": "00876", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 876, "c2": 6, "c3": "00876", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 886, "c2": 6, "c3": "00886", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 886, "c2": 6, "c3": "00886", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 896, "c2": 6, "c3": "00896", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 896, "c2": 6, "c3": "00896", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 906, "c2": 6, "c3": "00906", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 906, "c2": 6, "c3": "00906", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 916, "c2": 6, "c3": "00916", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 916, "c2": 6, "c3": "00916", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 926, "c2": 6, "c3": "00926", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 926, "c2": 6, "c3": "00926", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 936, "c2": 6, "c3": "00936", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 936, "c2": 6, "c3": "00936", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 946, "c2": 6, "c3": "00946", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 946, "c2": 6, "c3": "00946", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 956, "c2": 6, "c3": "00956", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 956, "c2": 6, "c3": "00956", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 966, "c2": 6, "c3": "00966", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 966, "c2": 6, "c3": "00966", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 976, "c2": 6, "c3": "00976", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 976, "c2": 6, "c3": "00976", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 986, "c2": 6, "c3": "00986", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 986, "c2": 6, "c3": "00986", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 996, "c2": 6, "c3": "00996", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 996, "c2": 6, "c3": "00996", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
(100 rows)

-- bug before 9.3.5 due to sloppy handling of remote-estimate parameters
--Testcase 66:
SELECT * FROM ft1 WHERE (v->>'c1')::int8 = ANY (ARRAY(SELECT (v->>'c1')::int8 FROM ft2 WHERE (v->>'c1')::int8 < 5));
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 2, "c2": 2, "c3": "00002", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 3, "c2": 3, "c3": "00003", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 4, "c2": 4, "c3": "00004", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
(4 rows)

--Testcase 67:
SELECT * FROM ft2 WHERE (v->>'c1')::int8 = ANY (ARRAY(SELECT (v->>'c1')::int8 FROM ft1 WHERE (v->>'c1')::int8 < 5));
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 2, "c2": 2, "c3": "00002", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 3, "c2": 3, "c3": "00003", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 4, "c2": 4, "c3": "00004", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
(4 rows)

-- we should not push order by clause with volatile expressions or unsafe
-- collations
--Testcase 68:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT * FROM ft2 ORDER BY (ft2.v->>'c1')::int8, random();
                         QUERY PLAN                         
------------------------------------------------------------
 Incremental Sort
   Output: v, (((v ->> 'c1'::text))::bigint), (random())
   Sort Key: (((ft2.v ->> 'c1'::text))::bigint), (random())
   Presorted Key: (((ft2.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft2
         Output: v, ((v ->> 'c1'::text))::bigint, random()
         Reader: Single File
         Row groups: 1
(8 rows)

--Testcase 69:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT * FROM ft2 ORDER BY (ft2.v->>'c1')::int8, ft2.v->>'c3' collate "C";
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Incremental Sort
   Output: v, (((v ->> 'c1'::text))::bigint), ((v ->> 'c3'::text COLLATE "C"))
   Sort Key: (((ft2.v ->> 'c1'::text))::bigint), ((ft2.v ->> 'c3'::text COLLATE "C")) COLLATE "C"
   Presorted Key: (((ft2.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft2
         Output: v, ((v ->> 'c1'::text))::bigint, (v ->> 'c3'::text COLLATE "C")
         Reader: Single File
         Row groups: 1
(8 rows)

-- user-defined operator/function
--Testcase 70:
CREATE FUNCTION parquet_s3_fdw_abs(int) RETURNS int AS $$
BEGIN
RETURN abs($1);
END
$$ LANGUAGE plpgsql IMMUTABLE;
--Testcase 71:
CREATE OPERATOR === (
    LEFTARG = int,
    RIGHTARG = int,
    PROCEDURE = int4eq,
    COMMUTATOR = ===
);
-- built-in operators and functions can be shipped for remote execution
--Testcase 72:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = abs((t1.v->>'c2')::int);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::bigint = abs(((t1.v ->> 'c2'::text))::integer))
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 73:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = abs((t1.v->>'c2')::int);
 count 
-------
     9
(1 row)

--Testcase 74:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = (t1.v->>'c2')::int;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 75:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = (t1.v->>'c2')::int;
 count 
-------
     9
(1 row)

-- by default, user-defined ones cannot
--Testcase 76:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = parquet_s3_fdw_abs((t1.v->>'c2')::int);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::bigint = parquet_s3_fdw_abs(((t1.v ->> 'c2'::text))::integer))
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 77:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = parquet_s3_fdw_abs((t1.v->>'c2')::int);
 count 
-------
     9
(1 row)

--Testcase 78:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 79:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
 count 
-------
     9
(1 row)

-- ORDER BY can be shipped, though
--Testcase 80:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int order by (t1.v->>'c2')::int limit 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: v, (((v ->> 'c2'::text))::integer)
   ->  Sort
         Output: v, (((v ->> 'c2'::text))::integer)
         Sort Key: (((t1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1 t1
               Output: v, ((v ->> 'c2'::text))::integer
               Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 81:
SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int order by (t1.v->>'c2')::int limit 1;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- but let's put them in an extension ...
--Testcase 455:
ALTER EXTENSION parquet_s3_fdw ADD FUNCTION parquet_s3_fdw_abs(int);
--Testcase 456:
ALTER EXTENSION parquet_s3_fdw ADD OPERATOR === (int, int);
--Testcase 457:
ALTER SERVER parquet_s3_srv OPTIONS (ADD extensions 'parquet_s3_fdw');
-- ... now they can be shipped
--Testcase 82:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = parquet_s3_fdw_abs((t1.v->>'c2')::int);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::bigint = parquet_s3_fdw_abs(((t1.v ->> 'c2'::text))::integer))
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 83:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = parquet_s3_fdw_abs((t1.v->>'c2')::int);
 count 
-------
     9
(1 row)

--Testcase 84:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 85:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
 count 
-------
     9
(1 row)

-- and both ORDER BY and LIMIT can be shipped
--Testcase 86:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int order by (t1.v->>'c2')::int limit 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: v, (((v ->> 'c2'::text))::integer)
   ->  Sort
         Output: v, (((v ->> 'c2'::text))::integer)
         Sort Key: (((t1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1 t1
               Output: v, ((v ->> 'c2'::text))::integer
               Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 87:
SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int order by (t1.v->>'c2')::int limit 1;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- ===================================================================
-- JOIN queries
-- ===================================================================
-- Analyze ft4 and ft5 so that we have better statistics. These tables do not
-- have use_remote_estimate set.
-- ANALYZE ft4;
-- ANALYZE ft5;
-- join two tables
--Testcase 88:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text)
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft1 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(18 rows)

--Testcase 89:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- join three tables
--Testcase 90:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) JOIN ft4 t3 ON ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10; 
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text)), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text)), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text), (t1.v ->> 'c3'::text)
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: t1.v, t3.v
                     Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft4 t3
                           Output: t3.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t1.v
                           ->  Foreign Scan on public.ft1 t1
                                 Output: t1.v
                                 Reader: Single File
                                 Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(27 rows)

--Testcase 91:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) JOIN ft4 t3 ON ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 22 |  2 | AAA022
 24 |  4 | AAA024
 26 |  6 | AAA026
 28 |  8 | AAA028
 30 |  0 | AAA030
 32 |  2 | AAA032
 34 |  4 | AAA034
 36 |  6 | AAA036
 38 |  8 | AAA038
 40 |  0 | AAA040
(10 rows)

-- left outer join
--Testcase 92:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Presorted Key: (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 93:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c1 
----+----
 22 |   
 24 | 24
 26 |   
 28 |   
 30 | 30
 32 |   
 34 |   
 36 | 36
 38 |   
 40 |   
(10 rows)

-- left outer join three tables
--Testcase 94:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft2 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v, t3.v
               ->  Merge Left Join
                     Output: t2.v, t3.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t3.v
                           ->  Foreign Scan on public.ft4 t3
                                 Output: t3.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 95:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

-- left outer join + placement of clauses.
-- clauses within the nullable side are not pulled up, but top level clause on
-- non-nullable side is pushed into non-nullable side
--Testcase 96:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t1.v->>'c2')::int8 as c2, (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM ft4 t1 LEFT JOIN (SELECT * FROM ft5 WHERE (v->>'c1')::int8 < 10) t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE (t1.v->>'c1')::int8 < 10;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Output: ((t1.v ->> 'c1'::text))::bigint, ((t1.v ->> 'c2'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c2'::text))::bigint
   Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft4 t1
         Output: t1.v
         Filter: (((t1.v ->> 'c1'::text))::bigint < 10)
         Reader: Single File
         Row groups: 1
   ->  Hash
         Output: ft5.v
         ->  Foreign Scan on public.ft5
               Output: ft5.v
               Filter: (((ft5.v ->> 'c1'::text))::bigint < 10)
               Reader: Single File
               Row groups: 1
(15 rows)

--Testcase 97:
SELECT (t1.v->>'c1')::int8 as c1, (t1.v->>'c2')::int8 as c2, (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM ft4 t1 LEFT JOIN (SELECT * FROM ft5 WHERE (v->>'c1')::int8 < 10) t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE (t1.v->>'c1')::int8 < 10;
 c1 | c2 | c1 | c2 
----+----+----+----
  2 |  3 |    |   
  4 |  5 |    |   
  6 |  7 |  6 |  7
  8 |  9 |    |   
(4 rows)

-- clauses within the nullable side are not pulled up, but the top level clause
-- on nullable side is not pushed down into nullable side
--Testcase 98:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t1.v->>'c2')::int8 as c2, (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM ft4 t1 LEFT JOIN (SELECT * FROM ft5 WHERE (v->>'c1')::int8 < 10) t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)
			WHERE ((t2.v->>'c1')::int8 < 10 OR (t2.v->>'c1')::int8 IS NULL) AND (t1.v->>'c1')::int8 < 10;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Output: ((t1.v ->> 'c1'::text))::bigint, ((t1.v ->> 'c2'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c2'::text))::bigint
   Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
   Filter: ((((ft5.v ->> 'c1'::text))::bigint < 10) OR (((ft5.v ->> 'c1'::text))::bigint IS NULL))
   ->  Foreign Scan on public.ft4 t1
         Output: t1.v
         Filter: (((t1.v ->> 'c1'::text))::bigint < 10)
         Reader: Single File
         Row groups: 1
   ->  Hash
         Output: ft5.v
         ->  Foreign Scan on public.ft5
               Output: ft5.v
               Filter: (((ft5.v ->> 'c1'::text))::bigint < 10)
               Reader: Single File
               Row groups: 1
(16 rows)

--Testcase 99:
SELECT (t1.v->>'c1')::int8 as c1, (t1.v->>'c2')::int8 as c2, (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM ft4 t1 LEFT JOIN (SELECT * FROM ft5 WHERE (v->>'c1')::int8 < 10) t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)
			WHERE ((t2.v->>'c1')::int8 < 10 OR (t2.v->>'c1')::int8 IS NULL) AND (t1.v->>'c1')::int8 < 10;
 c1 | c2 | c1 | c2 
----+----+----+----
  2 |  3 |    |   
  4 |  5 |    |   
  6 |  7 |  6 |  7
  8 |  9 |    |   
(4 rows)

-- right outer join
--Testcase 100:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft5 t1 RIGHT JOIN ft4 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t2.v->>'c1')::int8, (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t2.v ->> 'c1'::text))::bigint), (((t1.v ->> 'c1'::text))::bigint)
         Presorted Key: (((t2.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t1.v
                     ->  Foreign Scan on public.ft5 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 101:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft5 t1 RIGHT JOIN ft4 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t2.v->>'c1')::int8, (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c1 
----+----
    | 22
 24 | 24
    | 26
    | 28
 30 | 30
    | 32
    | 34
 36 | 36
    | 38
    | 40
(10 rows)

-- right outer join three tables
--Testcase 102:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4 t3
               Output: t3.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v, t1.v
               ->  Merge Left Join
                     Output: t2.v, t1.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t1.v
                           ->  Foreign Scan on public.ft2 t1
                                 Output: t1.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 103:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 22 |  2 | AAA022
 24 |  4 | AAA024
 26 |  6 | AAA026
 28 |  8 | AAA028
 30 |  0 | AAA030
 32 |  2 | AAA032
 34 |  4 | AAA034
 36 |  6 | AAA036
 38 |  8 | AAA038
 40 |  0 | AAA040
(10 rows)

-- full outer join
--Testcase 104:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 FULL JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 45 LIMIT 10;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         ->  Hash Full Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(18 rows)

--Testcase 105:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 FULL JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 45 LIMIT 10;
 c1  | c1 
-----+----
  92 |   
  94 |   
  96 | 96
  98 |   
 100 |   
     |  3
     |  9
     | 15
     | 21
     | 27
(10 rows)

-- full outer join with restrictions on the joining relations
-- a. the joining relations are both base relations
--Testcase 106:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.c1, t2.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t2 ON (t1.c1 = t2.c1) ORDER BY t1.c1, t2.c1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   ->  Hash Full Join
         Output: ((ft4.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint
         Hash Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4
               Output: ft4.v
               Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: ft5.v
               ->  Foreign Scan on public.ft5
                     Output: ft5.v
                     Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(18 rows)

--Testcase 107:
SELECT t1.c1, t2.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t2 ON (t1.c1 = t2.c1) ORDER BY t1.c1, t2.c1;
 c1 | c1 
----+----
 50 |   
 52 |   
 54 | 54
 56 |   
 58 |   
 60 | 60
    | 51
    | 57
(8 rows)

--Testcase 108:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT 1 FROM (SELECT (v->>'c1')::int8 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (v->>'c1')::int8 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t2 ON (TRUE) OFFSET 10 LIMIT 10;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Limit
   Output: 1
   ->  Merge Full Join
         Output: 1
         ->  Foreign Scan on public.ft5
               Output: ft5.v
               Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: ft4.v
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(16 rows)

--Testcase 109:
SELECT 1 FROM (SELECT (v->>'c1')::int8 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (v->>'c1')::int8 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t2 ON (TRUE) OFFSET 10 LIMIT 10;
 ?column? 
----------
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
(10 rows)

-- b. one of the joining relations is a base relation and the other is a join
-- relation
--Testcase 110:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft4 t2 LEFT JOIN ft5 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) WHERE ((t2.v->>'c1')::int8 between 50 and 60)) ss(a, b) ON (t1.c1 = ss.a) ORDER BY t1.c1, ss.a, ss.b;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   ->  Hash Full Join
         Output: ((ft4.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
         Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((ft4.v ->> 'c1'::text))::bigint)
         ->  Nested Loop Left Join
               Output: t2.v, t3.v
               Join Filter: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t2
                     Output: t2.v
                     Filter: ((((t2.v ->> 'c1'::text))::bigint >= 50) AND (((t2.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
               ->  Foreign Scan on public.ft5 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
         ->  Hash
               Output: ft4.v
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(25 rows)

--Testcase 111:
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft4 t2 LEFT JOIN ft5 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) WHERE ((t2.v->>'c1')::int8 between 50 and 60)) ss(a, b) ON (t1.c1 = ss.a) ORDER BY t1.c1, ss.a, ss.b;
 c1 | a  | b  
----+----+----
 50 | 50 |   
 52 | 52 |   
 54 | 54 | 54
 56 | 56 |   
 58 | 58 |   
 60 | 60 | 60
(6 rows)

-- c. test deparsing the remote query as nested subqueries
--Testcase 112:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT t2.c1, t3.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t2 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t3 ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (t1.c1 = ss.a) ORDER BY t1.c1, ss.a, ss.b;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft4_1.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft4_1.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   ->  Hash Full Join
         Output: ((ft4.v ->> 'c1'::text))::bigint, ((ft4_1.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint
         Hash Cond: (((ft4_1.v ->> 'c1'::text))::bigint = ((ft4.v ->> 'c1'::text))::bigint)
         ->  Hash Full Join
               Output: ft4_1.v, ft5.v
               Hash Cond: (((ft4_1.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
               Filter: ((((ft4_1.v ->> 'c1'::text))::bigint IS NULL) OR (((ft4_1.v ->> 'c1'::text))::bigint IS NOT NULL))
               ->  Foreign Scan on public.ft4 ft4_1
                     Output: ft4_1.v
                     Filter: ((((ft4_1.v ->> 'c1'::text))::bigint >= 50) AND (((ft4_1.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: ft5.v
                     ->  Foreign Scan on public.ft5
                           Output: ft5.v
                           Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: ft4.v
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(29 rows)

--Testcase 113:
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT t2.c1, t3.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t2 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t3 ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (t1.c1 = ss.a) ORDER BY t1.c1, ss.a, ss.b;
 c1 | a  | b  
----+----+----
 50 | 50 |   
 52 | 52 |   
 54 | 54 | 54
 56 | 56 |   
 58 | 58 |   
 60 | 60 | 60
    |    | 51
    |    | 57
(8 rows)

-- d. test deparsing rowmarked relations as subqueries
--Testcase 114:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM "S 1"."T3" WHERE (v->>'c1')::int8 = 50) t1 INNER JOIN (SELECT t2.c1, t3.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t2 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t3 ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (TRUE) ORDER BY t1.c1, ss.a, ss.b FOR UPDATE OF t1;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 LockRows
   Output: ((("T3".v ->> 'c1'::text))::bigint), (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint), "T3".*, ft4.*, ft5.*
   ->  Sort
         Output: ((("T3".v ->> 'c1'::text))::bigint), (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint), "T3".*, ft4.*, ft5.*
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         ->  Nested Loop
               Output: (("T3".v ->> 'c1'::text))::bigint, ((ft4.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint, "T3".*, ft4.*, ft5.*
               ->  Foreign Scan on "S 1"."T3"
                     Output: "T3".v, "T3".*
                     Filter: ((("T3".v ->> 'c1'::text))::bigint = 50)
                     Reader: Single File
                     Row groups: 1
               ->  Hash Full Join
                     Output: ft4.v, ft4.*, ft5.v, ft5.*
                     Hash Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
                     Filter: ((((ft4.v ->> 'c1'::text))::bigint IS NULL) OR (((ft4.v ->> 'c1'::text))::bigint IS NOT NULL))
                     ->  Foreign Scan on public.ft4
                           Output: ft4.v, ft4.*
                           Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: ft5.v, ft5.*
                           ->  Foreign Scan on public.ft5
                                 Output: ft5.v, ft5.*
                                 Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
                                 Reader: Single File
                                 Row groups: 1
(28 rows)

--Testcase 115:
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM "S 1"."T3" WHERE (v->>'c1')::int8 = 50) t1 INNER JOIN (SELECT t2.c1, t3.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t2 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t3 ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (TRUE) ORDER BY t1.c1, ss.a, ss.b FOR UPDATE OF t1;
 c1 | a  | b  
----+----+----
 50 | 50 |   
 50 | 52 |   
 50 | 54 | 54
 50 | 56 |   
 50 | 58 |   
 50 | 60 | 60
 50 |    | 51
 50 |    | 57
(8 rows)

-- full outer join + inner join
--Testcase 116:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft4 t1 INNER JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 + 1 and (t1.v->>'c1')::int8 between 50 and 60) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8, (t3.v->>'c1')::int8 LIMIT 10;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
         ->  Hash Full Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
               Hash Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t1.v, t2.v
                     ->  Nested Loop
                           Output: t1.v, t2.v
                           Join Filter: (((t1.v ->> 'c1'::text))::bigint = (((t2.v ->> 'c1'::text))::bigint + 1))
                           ->  Foreign Scan on public.ft4 t1
                                 Output: t1.v
                                 Filter: ((((t1.v ->> 'c1'::text))::bigint >= 50) AND (((t1.v ->> 'c1'::text))::bigint <= 60))
                                 Reader: Single File
                                 Row groups: 1
                           ->  Foreign Scan on public.ft5 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(26 rows)

--Testcase 117:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft4 t1 INNER JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 + 1 and (t1.v->>'c1')::int8 between 50 and 60) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8, (t3.v->>'c1')::int8 LIMIT 10;
 c1 | c1 | c1 
----+----+----
 52 | 51 |   
 58 | 57 |   
    |    |  2
    |    |  4
    |    |  6
    |    |  8
    |    | 10
    |    | 12
    |    | 14
    |    | 16
(10 rows)

-- full outer join three tables
--Testcase 118:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Hash Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Merge Full Join
               Output: t1.v, t2.v
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: t3.v
               ->  Foreign Scan on public.ft4 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 119:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

-- full outer join + right outer join
--Testcase 120:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4 t3
               Output: t3.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v, t1.v
               ->  Merge Left Join
                     Output: t2.v, t1.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t1.v
                           ->  Foreign Scan on public.ft2 t1
                                 Output: t1.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 121:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 22 |  2 | AAA022
 24 |  4 | AAA024
 26 |  6 | AAA026
 28 |  8 | AAA028
 30 |  0 | AAA030
 32 |  2 | AAA032
 34 |  4 | AAA034
 36 |  6 | AAA036
 38 |  8 | AAA038
 40 |  0 | AAA040
(10 rows)

-- right outer join + full outer join
--Testcase 122:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4 t3
               Output: t3.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v, t1.v
               ->  Merge Left Join
                     Output: t2.v, t1.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t1.v
                           ->  Foreign Scan on public.ft2 t1
                                 Output: t1.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 123:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

-- full outer join + left outer join
--Testcase 124:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Hash Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Merge Full Join
               Output: t1.v, t2.v
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: t3.v
               ->  Foreign Scan on public.ft4 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 125:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

-- left outer join + full outer join
--Testcase 126:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Hash Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: t1.v, t2.v
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: t3.v
               ->  Foreign Scan on public.ft4 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 127:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

--Testcase 458:
SET enable_memoize TO off;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:567: ERROR:  unrecognized configuration parameter "enable_memoize"
-- right outer join + left outer join
--Testcase 128:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: t2.v, t3.v
               Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t3.v
                     ->  Foreign Scan on public.ft4 t3
                           Output: t3.v
                           Reader: Single File
                           Row groups: 1
         ->  Materialize
               Output: t1.v
               ->  Foreign Scan on public.ft2 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 129:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

--Testcase 459:
RESET enable_memoize;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:575: ERROR:  unrecognized configuration parameter "enable_memoize"
-- left outer join + right outer join
--Testcase 130:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4 t3
               Output: t3.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t1.v, t2.v
               ->  Merge Join
                     Output: t1.v, t2.v
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 131:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 22 |  2 | AAA022
 24 |  4 | AAA024
 26 |  6 | AAA026
 28 |  8 | AAA028
 30 |  0 | AAA030
 32 |  2 | AAA032
 34 |  4 | AAA034
 36 |  6 | AAA036
 38 |  8 | AAA038
 40 |  0 | AAA040
(10 rows)

-- full outer join + WHERE clause, only matched rows
--Testcase 132:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 FULL JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 OR (t1.v->>'c1')::int8 IS NULL) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         ->  Hash Full Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               Filter: ((((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint) OR (((t1.v ->> 'c1'::text))::bigint IS NULL))
               ->  Foreign Scan on public.ft4 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 133:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 FULL JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 OR (t1.v->>'c1')::int8 IS NULL) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c1 
----+----
 66 | 66
 72 | 72
 78 | 78
 84 | 84
 90 | 90
 96 | 96
    |  3
    |  9
    | 15
    | 21
(10 rows)

-- full outer join + WHERE clause with shippable extensions set
--Testcase 134:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8, t2.v->>'c2', t1.v->>'c3' FROM ft1 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE parquet_s3_fdw_abs((t1.v->>'c1')::int) > 0 OFFSET 10 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), ((t2.v ->> 'c2'::text)), ((t1.v ->> 'c3'::text))
   ->  Merge Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, (t2.v ->> 'c2'::text), (t1.v ->> 'c3'::text)
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         Filter: (parquet_s3_fdw_abs(((t1.v ->> 'c1'::text))::integer) > 0)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(16 rows)

--Testcase 460:
ALTER SERVER parquet_s3_srv OPTIONS (DROP extensions);
-- full outer join + WHERE clause with shippable extensions not set
--Testcase 135:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8, t2.v->>'c2', t1.v->>'c3' FROM ft1 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE parquet_s3_fdw_abs((t1.v->>'c1')::int) > 0 OFFSET 10 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), ((t2.v ->> 'c2'::text)), ((t1.v ->> 'c3'::text))
   ->  Merge Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, (t2.v ->> 'c2'::text), (t1.v ->> 'c3'::text)
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         Filter: (parquet_s3_fdw_abs(((t1.v ->> 'c1'::text))::integer) > 0)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(16 rows)

--Testcase 461:
ALTER SERVER parquet_s3_srv OPTIONS (ADD extensions 'parquet_s3_fdw');
-- join two tables with FOR UPDATE clause
-- tests whole-row reference for row marks
--Testcase 136:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR UPDATE OF t1;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
   ->  LockRows
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
         ->  Sort
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
               Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), t1.*, t2.*
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, t1.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v, t2.*
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v, t2.*
                                 Reader: Single File
                                 Row groups: 1
(20 rows)

--Testcase 137:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR UPDATE OF t1;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

--Testcase 138:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR UPDATE;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
   ->  LockRows
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
         ->  Sort
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
               Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), t1.*, t2.*
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, t1.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v, t2.*
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v, t2.*
                                 Reader: Single File
                                 Row groups: 1
(20 rows)

--Testcase 139:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR UPDATE;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- join two tables with FOR SHARE clause
--Testcase 140:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR SHARE OF t1;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
   ->  LockRows
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
         ->  Sort
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
               Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), t1.*, t2.*
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, t1.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v, t2.*
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v, t2.*
                                 Reader: Single File
                                 Row groups: 1
(20 rows)

--Testcase 141:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR SHARE OF t1;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

--Testcase 142:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR SHARE;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
   ->  LockRows
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
         ->  Sort
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
               Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), t1.*, t2.*
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, t1.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v, t2.*
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v, t2.*
                                 Reader: Single File
                                 Row groups: 1
(20 rows)

--Testcase 143:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR SHARE;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- join in CTE
--Testcase 144:
EXPLAIN (VERBOSE, COSTS OFF)
WITH t (c1_1, c1_3, c2_1) AS MATERIALIZED (SELECT (t1.v->>'c1')::int8, t1.v->>'c3', (t2.v->>'c1')::int8 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)) SELECT c1_1, c2_1 FROM t ORDER BY c1_3, c1_1 OFFSET 100 LIMIT 10;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t.c1_1, t.c2_1, t.c1_3
   CTE t
     ->  Merge Join
           Output: ((t1.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), ((t2.v ->> 'c1'::text))::bigint
           Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
           ->  Foreign Scan on public.ft1 t1
                 Output: t1.v
                 Reader: Single File
                 Row groups: 1
           ->  Materialize
                 Output: t2.v
                 ->  Foreign Scan on public.ft2 t2
                       Output: t2.v
                       Reader: Single File
                       Row groups: 1
   ->  Sort
         Output: t.c1_1, t.c2_1, t.c1_3
         Sort Key: t.c1_3, t.c1_1
         ->  CTE Scan on t
               Output: t.c1_1, t.c2_1, t.c1_3
(21 rows)

--Testcase 145:
WITH t (c1_1, c1_3, c2_1) AS MATERIALIZED (SELECT (t1.v->>'c1')::int8, t1.v->>'c3', (t2.v->>'c1')::int8 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)) SELECT c1_1, c2_1 FROM t ORDER BY c1_3, c1_1 OFFSET 100 LIMIT 10;
 c1_1 | c2_1 
------+------
  101 |  101
  102 |  102
  103 |  103
  104 |  104
  105 |  105
  106 |  106
  107 |  107
  108 |  108
  109 |  109
  110 |  110
(10 rows)

-- ctid with whole-row reference
--Testcase 146:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.ctid, t1, t2, (t1.v->>'c1')::int8 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Limit
   Output: t1.ctid, t1.*, t2.*, (((t1.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: t1.ctid, t1.*, t2.*, (((t1.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Join
               Output: t1.ctid, t1.*, t2.*, ((t1.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text)
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft1 t1
                     Output: t1.ctid, t1.*, t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.*, t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.*, t2.v
                           Reader: Single File
                           Row groups: 1
(18 rows)

-- SEMI JOIN, not pushed down
--Testcase 147:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 AS c1 FROM ft1 t1 WHERE EXISTS (SELECT 1 FROM ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint)
   ->  Merge Semi Join
         Output: ((t1.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Foreign Scan on public.ft2 t2
               Output: t2.v
               Reader: Single File
               Row groups: 1
(13 rows)

--Testcase 148:
SELECT (t1.v->>'c1')::int8 AS c1 FROM ft1 t1 WHERE EXISTS (SELECT 1 FROM ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  
-----
 101
 102
 103
 104
 105
 106
 107
 108
 109
 110
(10 rows)

-- ANTI JOIN, not pushed down
--Testcase 149:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 AS c1 FROM ft1 t1 WHERE NOT EXISTS (SELECT 1 FROM ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c2')::int8) ORDER BY (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint)
   ->  Merge Anti Join
         Output: ((t1.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = (((t2.v ->> 'c2'::text))::bigint))
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Sort
               Output: t2.v, (((t2.v ->> 'c2'::text))::bigint)
               Sort Key: (((t2.v ->> 'c2'::text))::bigint)
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v, ((t2.v ->> 'c2'::text))::bigint
                     Reader: Single File
                     Row groups: 1
(16 rows)

--Testcase 150:
SELECT (t1.v->>'c1')::int8 AS c1 FROM ft1 t1 WHERE NOT EXISTS (SELECT 1 FROM ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c2')::int8) ORDER BY (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  
-----
 110
 111
 112
 113
 114
 115
 116
 117
 118
 119
(10 rows)

-- CROSS JOIN can be pushed down
--Testcase 151:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 CROSS JOIN ft2 t2 ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Presorted Key: (((t1.v ->> 'c1'::text))::bigint)
         ->  Nested Loop
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               ->  Foreign Scan on public.ft1 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(18 rows)

--Testcase 152:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 CROSS JOIN ft2 t2 ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1 | c1  
----+-----
  1 | 101
  1 | 102
  1 | 103
  1 | 104
  1 | 105
  1 | 106
  1 | 107
  1 | 108
  1 | 109
  1 | 110
(10 rows)

-- different server, not pushed down. No result expected.
--Testcase 153:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft5 t1 JOIN ft6 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Merge Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft5 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft6 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(15 rows)

--Testcase 154:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft5 t1 JOIN ft6 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1 | c1 
----+----
(0 rows)

-- unsafe join conditions (c8 has a UDT), not pushed down. Practically a CROSS
-- JOIN since c8 in both tables has same value.
--Testcase 155:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON (t1.v->>'c8' = t2.v->>'c8') ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((t1.v ->> 'c8'::text)) = ((t2.v ->> 'c8'::text)))
               ->  Sort
                     Output: t1.v, ((t1.v ->> 'c8'::text))
                     Sort Key: ((t1.v ->> 'c8'::text))
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, (t1.v ->> 'c8'::text)
                           Reader: Single File
                           Row groups: 1
               ->  Sort
                     Output: t2.v, ((t2.v ->> 'c8'::text))
                     Sort Key: ((t2.v ->> 'c8'::text))
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v, (t2.v ->> 'c8'::text)
                           Reader: Single File
                           Row groups: 1
(22 rows)

--Testcase 156:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON (t1.v->>'c8' = t2.v->>'c8') ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1 | c1  
----+-----
  1 | 101
  1 | 102
  1 | 103
  1 | 104
  1 | 105
  1 | 106
  1 | 107
  1 | 108
  1 | 109
  1 | 110
(10 rows)

-- unsafe conditions on one side (c8 has a UDT), not pushed down.
--Testcase 157:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE t1.v->>'c8' = 'foo' ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Hash Right Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text)
               Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t1.v
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v
                           Filter: ((t1.v ->> 'c8'::text) = 'foo'::text)
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 158:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE t1.v->>'c8' = 'foo' ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- join where unsafe to pushdown condition in WHERE clause has a column not
-- in the SELECT clause. In this test unsafe clause needs to have column
-- references from both joining sides so that the clause is not pushed down
-- into one of the joining sides.
--Testcase 159:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE t1.v->>'c8' = t2.v->>'c8' ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Join
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (t1.v ->> 'c3'::text)
               Merge Cond: (((((t1.v ->> 'c1'::text))::bigint) = (((t2.v ->> 'c1'::text))::bigint)) AND (((t1.v ->> 'c8'::text)) = ((t2.v ->> 'c8'::text))))
               ->  Sort
                     Output: t1.v, (((t1.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c8'::text))
                     Sort Key: (((t1.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c8'::text))
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, ((t1.v ->> 'c1'::text))::bigint, (t1.v ->> 'c8'::text)
                           Reader: Single File
                           Row groups: 1
               ->  Sort
                     Output: t2.v, (((t2.v ->> 'c1'::text))::bigint), ((t2.v ->> 'c8'::text))
                     Sort Key: (((t2.v ->> 'c1'::text))::bigint), ((t2.v ->> 'c8'::text))
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v, ((t2.v ->> 'c1'::text))::bigint, (t2.v ->> 'c8'::text)
                           Reader: Single File
                           Row groups: 1
(22 rows)

--Testcase 160:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE t1.v->>'c8' = t2.v->>'c8' ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- Aggregate after UNION, for testing setrefs
--Testcase 161:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1c1, avg(t1c1 + t2c1) FROM (SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) UNION SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)) AS t (t1c1, t2c1) GROUP BY t1c1 ORDER BY t1c1 OFFSET 100 LIMIT 10;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (avg(((((t1.v ->> 'c1'::text))::bigint) + (((t2.v ->> 'c1'::text))::bigint))))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (avg(((((t1.v ->> 'c1'::text))::bigint) + (((t2.v ->> 'c1'::text))::bigint))))
         Sort Key: (((t1.v ->> 'c1'::text))::bigint)
         ->  HashAggregate
               Output: (((t1.v ->> 'c1'::text))::bigint), avg(((((t1.v ->> 'c1'::text))::bigint) + (((t2.v ->> 'c1'::text))::bigint)))
               Group Key: (((t1.v ->> 'c1'::text))::bigint)
               ->  HashAggregate
                     Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
                     Group Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
                     ->  Append
                           ->  Merge Join
                                 Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
                                 Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                                 ->  Foreign Scan on public.ft1 t1
                                       Output: t1.v
                                       Reader: Single File
                                       Row groups: 1
                                 ->  Materialize
                                       Output: t2.v
                                       ->  Foreign Scan on public.ft2 t2
                                             Output: t2.v
                                             Reader: Single File
                                             Row groups: 1
                           ->  Merge Join
                                 Output: ((t1_1.v ->> 'c1'::text))::bigint, ((t2_1.v ->> 'c1'::text))::bigint
                                 Merge Cond: (((t1_1.v ->> 'c1'::text))::bigint = ((t2_1.v ->> 'c1'::text))::bigint)
                                 ->  Foreign Scan on public.ft1 t1_1
                                       Output: t1_1.v
                                       Reader: Single File
                                       Row groups: 1
                                 ->  Materialize
                                       Output: t2_1.v
                                       ->  Foreign Scan on public.ft2 t2_1
                                             Output: t2_1.v
                                             Reader: Single File
                                             Row groups: 1
(38 rows)

--Testcase 162:
SELECT t1c1, avg(t1c1 + t2c1) FROM (SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) UNION SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)) AS t (t1c1, t2c1) GROUP BY t1c1 ORDER BY t1c1 OFFSET 100 LIMIT 10;
 t1c1 |         avg          
------+----------------------
  101 | 202.0000000000000000
  102 | 204.0000000000000000
  103 | 206.0000000000000000
  104 | 208.0000000000000000
  105 | 210.0000000000000000
  106 | 212.0000000000000000
  107 | 214.0000000000000000
  108 | 216.0000000000000000
  109 | 218.0000000000000000
  110 | 220.0000000000000000
(10 rows)

-- join with lateral reference
--Testcase 163:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1, LATERAL (SELECT DISTINCT (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft1 t2, ft2 t3 WHERE (t2.v->>'c1')::int8 = (t3.v->>'c1')::int8 AND (t2.v->>'c2')::int = (t1.v->>'c2')::int) q ORDER BY (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint)
   ->  Nested Loop
         Output: ((t1.v ->> 'c1'::text))::bigint
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  HashAggregate
               Output: (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
               Group Key: ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
               ->  Hash Join
                     Output: ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
                     Hash Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t3
                           Output: t3.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: t2.v
                           ->  Foreign Scan on public.ft1 t2
                                 Output: t2.v
                                 Filter: (((t2.v ->> 'c2'::text))::integer = ((t1.v ->> 'c2'::text))::integer)
                                 Reader: Single File
                                 Row groups: 1
(25 rows)

--Testcase 164:
SELECT (t1.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1, LATERAL (SELECT DISTINCT (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft1 t2, ft2 t3 WHERE (t2.v->>'c1')::int8 = (t3.v->>'c1')::int8 AND (t2.v->>'c2')::int = (t1.v->>'c2')::int) q ORDER BY (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 
----
  1
  1
  1
  1
  1
  1
  1
  1
  1
  1
(10 rows)

-- non-Var items in targetlist of the nullable rel of a join preventing
-- push-down in some cases
-- unable to push {ft1, ft2}
--Testcase 165:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT q.a, (ft2.v->>'c1')::int8 as c1 FROM (SELECT 13 FROM ft1 WHERE (v->>'c1')::int8 = 13) q(a) RIGHT JOIN ft2 ON (q.a = (ft2.v->>'c1')::int8) WHERE (ft2.v->>'c1')::int8 BETWEEN 10 AND 15;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: (13), ((ft2.v ->> 'c1'::text))::bigint
   Join Filter: (13 = ((ft2.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft2
         Output: ft2.v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint >= 10) AND (((ft2.v ->> 'c1'::text))::bigint <= 15))
         Reader: Single File
         Row groups: 1
   ->  Materialize
         Output: (13)
         ->  Foreign Scan on public.ft1
               Output: 13
               Filter: (((ft1.v ->> 'c1'::text))::bigint = 13)
               Reader: Single File
               Row groups: 1
(15 rows)

--Testcase 166:
SELECT q.a, (ft2.v->>'c1')::int8 as c1 FROM (SELECT 13 FROM ft1 WHERE (v->>'c1')::int8 = 13) q(a) RIGHT JOIN ft2 ON (q.a = (ft2.v->>'c1')::int8) WHERE (ft2.v->>'c1')::int8 BETWEEN 10 AND 15;
 a  | c1 
----+----
    | 10
    | 11
    | 12
 13 | 13
    | 14
    | 15
(6 rows)

-- ok to push {ft1, ft2} but not {ft1, ft2, ft4}
--Testcase 167:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (ft4.v->>'c1')::int8 as c1, q.* FROM ft4 LEFT JOIN (SELECT 13, (ft1.v->>'c1')::int8, (ft2.v->>'c1')::int8 FROM ft1 RIGHT JOIN ft2 ON ((ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8) WHERE (ft1.v->>'c1')::int8 = 12) q(a, b, c) ON ((ft4.v->>'c1')::int8 = q.b) WHERE (ft4.v->>'c1')::int8 BETWEEN 10 AND 15;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: ((ft4.v ->> 'c1'::text))::bigint, (13), ((ft1.v ->> 'c1'::text))::bigint, ((ft2.v ->> 'c1'::text))::bigint
   Join Filter: (((ft4.v ->> 'c1'::text))::bigint = ((ft1.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft4
         Output: ft4.v
         Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 10) AND (((ft4.v ->> 'c1'::text))::bigint <= 15))
         Reader: Single File
         Row groups: 1
   ->  Nested Loop
         Output: ft1.v, ft2.v, 13
         ->  Foreign Scan on public.ft1
               Output: ft1.v
               Filter: (((ft1.v ->> 'c1'::text))::bigint = 12)
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: ft2.v
               ->  Foreign Scan on public.ft2
                     Output: ft2.v
                     Filter: (((ft2.v ->> 'c1'::text))::bigint = 12)
                     Reader: Single File
                     Row groups: 1
(22 rows)

--Testcase 168:
SELECT (ft4.v->>'c1')::int8 as c1, q.* FROM ft4 LEFT JOIN (SELECT 13, (ft1.v->>'c1')::int8, (ft2.v->>'c1')::int8 FROM ft1 RIGHT JOIN ft2 ON ((ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8) WHERE (ft1.v->>'c1')::int8 = 12) q(a, b, c) ON ((ft4.v->>'c1')::int8 = q.b) WHERE (ft4.v->>'c1')::int8 BETWEEN 10 AND 15;
 c1 | a  | b  | c  
----+----+----+----
 10 |    |    |   
 12 | 13 | 12 | 12
 14 |    |    |   
(3 rows)

-- join with nullable side with some columns with null values
--Testcase 462:
UPDATE ft5 SET v = json_build_object('c3', null) where (v->>'c1')::int % 9 = 0;
--Testcase 463:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT ft5, ft5.v->>'c1', ft5.v->>'c2', ft5.v->>'c3', ft4.v->>'c1', ft4.v->>'c2' FROM ft5 left join ft4 on (ft5.v->>'c1')::int = (ft4.v->>'c1')::int WHERE (ft4.v->>'c1')::int BETWEEN 10 and 30 ORDER BY (ft5.v->>'c1')::int, (ft4.v->>'c1')::int;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: ft5.*, ((ft5.v ->> 'c1'::text)), ((ft5.v ->> 'c2'::text)), ((ft5.v ->> 'c3'::text)), ((ft4.v ->> 'c1'::text)), ((ft4.v ->> 'c2'::text)), (((ft5.v ->> 'c1'::text))::integer), (((ft4.v ->> 'c1'::text))::integer)
   Sort Key: (((ft5.v ->> 'c1'::text))::integer)
   ->  Nested Loop
         Output: ft5.*, (ft5.v ->> 'c1'::text), (ft5.v ->> 'c2'::text), (ft5.v ->> 'c3'::text), (ft4.v ->> 'c1'::text), (ft4.v ->> 'c2'::text), ((ft5.v ->> 'c1'::text))::integer, ((ft4.v ->> 'c1'::text))::integer
         Join Filter: (((ft5.v ->> 'c1'::text))::integer = ((ft4.v ->> 'c1'::text))::integer)
         ->  Foreign Scan on public.ft4
               Output: ft4.v
               Filter: ((((ft4.v ->> 'c1'::text))::integer >= 10) AND (((ft4.v ->> 'c1'::text))::integer <= 30))
               Reader: Single File
               Row groups: 1
         ->  Foreign Scan on public.ft5
               Output: ft5.*, ft5.v
               Reader: Single File
               Row groups: 1
(15 rows)

--Testcase 464:
SELECT ft5, ft5.v->>'c1', ft5.v->>'c2', ft5.v->>'c3', ft4.v->>'c1', ft4.v->>'c2' FROM ft5 left join ft4 on (ft5.v->>'c1')::int = (ft4.v->>'c1')::int WHERE (ft4.v->>'c1')::int BETWEEN 10 and 30 ORDER BY (ft5.v->>'c1')::int, (ft4.v->>'c1')::int;
                       ft5                        | ?column? | ?column? | ?column? | ?column? | ?column? 
--------------------------------------------------+----------+----------+----------+----------+----------
 ("{""c1"": 12, ""c2"": 13, ""c3"": ""AAA012""}") | 12       | 13       | AAA012   | 12       | 13
 ("{""c1"": 18, ""c2"": 19, ""c3"": null}")       | 18       | 19       |          | 18       | 19
 ("{""c1"": 24, ""c2"": 25, ""c3"": ""AAA024""}") | 24       | 25       | AAA024   | 24       | 25
 ("{""c1"": 30, ""c2"": 31, ""c3"": ""AAA030""}") | 30       | 31       | AAA030   | 30       | 31
(4 rows)

-- multi-way join involving multiple merge joins
-- (this case used to have EPQ-related planning problems)
\set var :PATH_FILENAME'/ported_postgres/local_tbl.parquet'
--Testcase 169:
CREATE FOREIGN TABLE local_tbl (v jsonb)
SERVER parquet_s3_srv
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
-- ANALYZE local_tbl;
--Testcase 465:
SET enable_nestloop TO false;
--Testcase 466:
SET enable_hashjoin TO false;
--Testcase 170:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM ft1, ft2, ft4, ft5, local_tbl WHERE (ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8 AND (ft1.v->>'c2')::int = (ft4.v->>'c1')::int8
    AND (ft1.v->>'c2')::int = (ft5.v->>'c1')::int8 AND (ft1.v->>'c2')::int = (local_tbl.v->>'c1')::int8 AND (ft1.v->>'c1')::int8 < 100 AND (ft2.v->>'c1')::int8 < 100 ORDER BY (ft1.v->>'c1')::int8 FOR UPDATE;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 LockRows
   Output: ft1.v, ft2.v, ft4.v, ft5.v, local_tbl.v, (((ft1.v ->> 'c1'::text))::bigint), ft1.*, ft2.*, ft4.*, ft5.*, local_tbl.*
   ->  Merge Join
         Output: ft1.v, ft2.v, ft4.v, ft5.v, local_tbl.v, (((ft1.v ->> 'c1'::text))::bigint), ft1.*, ft2.*, ft4.*, ft5.*, local_tbl.*
         Merge Cond: ((((ft1.v ->> 'c1'::text))::bigint) = ((ft2.v ->> 'c1'::text))::bigint)
         ->  Sort
               Output: ft1.v, ft1.*, ft4.v, ft4.*, ft5.v, ft5.*, local_tbl.v, local_tbl.*, (((ft1.v ->> 'c1'::text))::bigint)
               Sort Key: (((ft1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ft1.v, ft1.*, ft4.v, ft4.*, ft5.v, ft5.*, local_tbl.v, local_tbl.*, ((ft1.v ->> 'c1'::text))::bigint
                     Merge Cond: (((local_tbl.v ->> 'c1'::text))::bigint = ((ft1.v ->> 'c2'::text))::integer)
                     ->  Foreign Scan on public.local_tbl
                           Output: local_tbl.v, local_tbl.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: ft1.v, ft1.*, ft4.v, ft4.*, ft5.v, ft5.*
                           ->  Merge Join
                                 Output: ft1.v, ft1.*, ft4.v, ft4.*, ft5.v, ft5.*
                                 Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = (((ft1.v ->> 'c2'::text))::integer))
                                 ->  Merge Join
                                       Output: ft4.v, ft4.*, ft5.v, ft5.*
                                       Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
                                       ->  Foreign Scan on public.ft4
                                             Output: ft4.v, ft4.*
                                             Reader: Single File
                                             Row groups: 1
                                       ->  Materialize
                                             Output: ft5.v, ft5.*
                                             ->  Foreign Scan on public.ft5
                                                   Output: ft5.v, ft5.*
                                                   Reader: Single File
                                                   Row groups: 1
                                 ->  Sort
                                       Output: ft1.v, ft1.*, (((ft1.v ->> 'c2'::text))::integer)
                                       Sort Key: (((ft1.v ->> 'c2'::text))::integer)
                                       ->  Foreign Scan on public.ft1
                                             Output: ft1.v, ft1.*, ((ft1.v ->> 'c2'::text))::integer
                                             Filter: (((ft1.v ->> 'c1'::text))::bigint < 100)
                                             Reader: Single File
                                             Row groups: 1
         ->  Materialize
               Output: ft2.v, ft2.*
               ->  Foreign Scan on public.ft2
                     Output: ft2.v, ft2.*
                     Filter: (((ft2.v ->> 'c1'::text))::bigint < 100)
                     Reader: Single File
                     Row groups: 1
(48 rows)

--Testcase 171:
SELECT * FROM ft1, ft2, ft4, ft5, local_tbl WHERE (ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8 AND (ft1.v->>'c2')::int = (ft4.v->>'c1')::int8
    AND (ft1.v->>'c2')::int = (ft5.v->>'c1')::int8 AND (ft1.v->>'c2')::int = (local_tbl.v->>'c1')::int8 AND (ft1.v->>'c1')::int8 < 100 AND (ft2.v->>'c1')::int8 < 100 ORDER BY (ft1.v->>'c1')::int8 FOR UPDATE;
                                                    v                                                    |                                                    v                                                    |                 v                  |                 v                  |                v                 
---------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------+------------------------------------+------------------------------------+----------------------------------
 {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 26, "c2": 6, "c3": "00026", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 26, "c2": 6, "c3": "00026", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 56, "c2": 6, "c3": "00056", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 56, "c2": 6, "c3": "00056", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 66, "c2": 6, "c3": "00066", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 66, "c2": 6, "c3": "00066", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 76, "c2": 6, "c3": "00076", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 76, "c2": 6, "c3": "00076", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 86, "c2": 6, "c3": "00086", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 86, "c2": 6, "c3": "00086", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 96, "c2": 6, "c3": "00096", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 96, "c2": 6, "c3": "00096", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
(10 rows)

--Testcase 467:
RESET enable_nestloop;
--Testcase 468:
RESET enable_hashjoin;
--Testcase 172:
DROP FOREIGN TABLE local_tbl;
-- check join pushdown in situations where multiple userids are involved
--Testcase 173:
CREATE ROLE regress_view_owner SUPERUSER;
--Testcase 174:
CREATE USER MAPPING FOR regress_view_owner SERVER parquet_s3_srv;
GRANT SELECT ON ft4 TO regress_view_owner;
GRANT SELECT ON ft5 TO regress_view_owner;
--Testcase 175:
CREATE VIEW v4 AS SELECT * FROM ft4;
--Testcase 176:
CREATE VIEW v5 AS SELECT * FROM ft5;
--Testcase 469:
ALTER VIEW v5 OWNER TO regress_view_owner;
--Testcase 177:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN v5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can't be pushed down, different view owners
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c2'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c2'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         Presorted Key: (((ft4.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((ft4.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c2'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint
               Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: ft5.v
                     ->  Foreign Scan on public.ft5
                           Output: ft5.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 178:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN v5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can't be pushed down, different view owners
 c1 | c2 
----+----
 22 |   
 24 | 25
 26 |   
 28 |   
 30 | 31
 32 |   
 34 |   
 36 | 37
 38 |   
 40 |   
(10 rows)

--Testcase 470:
ALTER VIEW v4 OWNER TO regress_view_owner;
--Testcase 179:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN v5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can be pushed down
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c2'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c2'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         Presorted Key: (((ft4.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((ft4.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c2'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint
               Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: ft5.v
                     ->  Foreign Scan on public.ft5
                           Output: ft5.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 180:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN v5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can be pushed down
 c1 | c2 
----+----
 22 |   
 24 | 25
 26 |   
 28 |   
 30 | 31
 32 |   
 34 |   
 36 | 37
 38 |   
 40 |   
(10 rows)

--Testcase 181:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can't be pushed down, view owner not current user
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Presorted Key: (((ft4.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((ft4.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 182:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c2 
----+----
 22 |   
 24 | 25
 26 |   
 28 |   
 30 | 31
 32 |   
 34 |   
 36 | 37
 38 |   
 40 |   
(10 rows)

--Testcase 471:
ALTER VIEW v4 OWNER TO CURRENT_USER;
--Testcase 183:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can be pushed down
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Presorted Key: (((ft4.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((ft4.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 184:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can be pushed down
 c1 | c2 
----+----
 22 |   
 24 | 25
 26 |   
 28 |   
 30 | 31
 32 |   
 34 |   
 36 | 37
 38 |   
 40 |   
(10 rows)

--Testcase 472:
ALTER VIEW v4 OWNER TO regress_view_owner;
-- cleanup
--Testcase 185:
DROP OWNED BY regress_view_owner;
--Testcase 186:
DROP ROLE regress_view_owner;
-- ===================================================================
-- Aggregate and grouping queries
-- ===================================================================
-- Simple aggregates
--Testcase 187:
explain (verbose, costs off)
select count(v->>'c6'), sum((v->>'c1')::int8), avg((v->>'c1')::int8), min((v->>'c2')::int), max((v->>'c1')::int8), stddev((v->>'c2')::int), sum((v->>'c1')::int8) * (random() <= 1)::int as sum2 from ft1 where (v->>'c2')::int < 5 group by (v->>'c2')::int order by 1, 2;
                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), ((sum(((v ->> 'c1'::text))::bigint)) * (((random() <= '1'::double precision))::integer)::numeric), (((v ->> 'c2'::text))::integer)
   ->  Sort
         Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), (((v ->> 'c2'::text))::integer)
         Sort Key: (count((ft1.v ->> 'c6'::text))), (sum(((ft1.v ->> 'c1'::text))::bigint))
         ->  HashAggregate
               Output: count((v ->> 'c6'::text)), sum(((v ->> 'c1'::text))::bigint), avg(((v ->> 'c1'::text))::bigint), min((((v ->> 'c2'::text))::integer)), max(((v ->> 'c1'::text))::bigint), stddev((((v ->> 'c2'::text))::integer)), (((v ->> 'c2'::text))::integer)
               Group Key: ((ft1.v ->> 'c2'::text))::integer
               ->  Foreign Scan on public.ft1
                     Output: ((v ->> 'c2'::text))::integer, v
                     Filter: (((ft1.v ->> 'c2'::text))::integer < 5)
                     Reader: Single File
                     Row groups: 1
(13 rows)

--Testcase 188:
select count(v->>'c6'), sum((v->>'c1')::int8), avg((v->>'c1')::int8), min((v->>'c2')::int), max((v->>'c1')::int8), stddev((v->>'c2')::int), sum((v->>'c1')::int8) * (random() <= 1)::int as sum2 from ft1 where (v->>'c2')::int < 5 group by (v->>'c2')::int order by 1, 2;
 count |  sum  |         avg          | min | max  | stddev | sum2  
-------+-------+----------------------+-----+------+--------+-------
   100 | 49600 | 496.0000000000000000 |   1 |  991 |      0 | 49600
   100 | 49700 | 497.0000000000000000 |   2 |  992 |      0 | 49700
   100 | 49800 | 498.0000000000000000 |   3 |  993 |      0 | 49800
   100 | 49900 | 499.0000000000000000 |   4 |  994 |      0 | 49900
   100 | 50500 | 505.0000000000000000 |   0 | 1000 |      0 | 50500
(5 rows)

--Testcase 189:
explain (verbose, costs off)
select count(v->>'c6'), sum((v->>'c1')::int8), avg((v->>'c1')::int8), min((v->>'c2')::int), max((v->>'c1')::int8), stddev((v->>'c2')::int), sum((v->>'c1')::int8) * (random() <= 1)::int as sum2 from ft1 where (v->>'c2')::int < 5 group by (v->>'c2')::int order by 1, 2 limit 1;
                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), (((sum(((v ->> 'c1'::text))::bigint)) * (((random() <= '1'::double precision))::integer)::numeric)), (((v ->> 'c2'::text))::integer)
   ->  Result
         Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), ((sum(((v ->> 'c1'::text))::bigint)) * (((random() <= '1'::double precision))::integer)::numeric), (((v ->> 'c2'::text))::integer)
         ->  Sort
               Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), (((v ->> 'c2'::text))::integer)
               Sort Key: (count((ft1.v ->> 'c6'::text))), (sum(((ft1.v ->> 'c1'::text))::bigint))
               ->  HashAggregate
                     Output: count((v ->> 'c6'::text)), sum(((v ->> 'c1'::text))::bigint), avg(((v ->> 'c1'::text))::bigint), min((((v ->> 'c2'::text))::integer)), max(((v ->> 'c1'::text))::bigint), stddev((((v ->> 'c2'::text))::integer)), (((v ->> 'c2'::text))::integer)
                     Group Key: ((ft1.v ->> 'c2'::text))::integer
                     ->  Foreign Scan on public.ft1
                           Output: ((v ->> 'c2'::text))::integer, v
                           Filter: (((ft1.v ->> 'c2'::text))::integer < 5)
                           Reader: Single File
                           Row groups: 1
(15 rows)

--Testcase 190:
select count(v->>'c6'), sum((v->>'c1')::int8), avg((v->>'c1')::int8), min((v->>'c2')::int), max((v->>'c1')::int8), stddev((v->>'c2')::int), sum((v->>'c1')::int8) * (random() <= 1)::int as sum2 from ft1 where (v->>'c2')::int < 5 group by (v->>'c2')::int order by 1, 2 limit 1;
 count |  sum  |         avg          | min | max | stddev | sum2  
-------+-------+----------------------+-----+-----+--------+-------
   100 | 49600 | 496.0000000000000000 |   1 | 991 |      0 | 49600
(1 row)

-- Aggregate is not pushed down as aggregation contains random()
--Testcase 191:
explain (verbose, costs off)
select sum((v->>'c1')::int8 * (random() <= 1)::int) as sum, avg((v->>'c1')::int8) from ft1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum((((v ->> 'c1'::text))::bigint * ((random() <= '1'::double precision))::integer)), avg(((v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft1
         Output: v
         Reader: Single File
         Row groups: 1
(6 rows)

-- Aggregate over join query
--Testcase 192:
explain (verbose, costs off)
select count(*), sum((t1.v->>'c1')::int8), avg((t2.v->>'c1')::int8) from ft1 t1 inner join ft1 t2 on ((t1.v->>'c2')::int = (t2.v->>'c2')::int) where (t1.v->>'c2')::int = 6;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(*), sum(((t1.v ->> 'c1'::text))::bigint), avg(((t2.v ->> 'c1'::text))::bigint)
   ->  Nested Loop
         Output: t1.v, t2.v
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Filter: (((t1.v ->> 'c2'::text))::integer = 6)
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft1 t2
                     Output: t2.v
                     Filter: (((t2.v ->> 'c2'::text))::integer = 6)
                     Reader: Single File
                     Row groups: 1
(16 rows)

--Testcase 193:
select count(*), sum((t1.v->>'c1')::int8), avg((t2.v->>'c1')::int8) from ft1 t1 inner join ft1 t2 on ((t1.v->>'c2')::int = (t2.v->>'c2')::int) where (t1.v->>'c2')::int = 6;
 count |   sum   |         avg          
-------+---------+----------------------
 10000 | 5010000 | 501.0000000000000000
(1 row)

-- Not pushed down due to local conditions present in underneath input rel
--Testcase 194:
explain (verbose, costs off)
select sum((t1.v->>'c1')::int8), count((t2.v->>'c1')::int8) from ft1 t1 inner join ft2 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (((t1.v->>'c1')::int8 * (t2.v->>'c1')::int8)/((t1.v->>'c1')::int8 * (t2.v->>'c1')::int8)) * random() <= 1;
                                                                                                          QUERY PLAN                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum(((t1.v ->> 'c1'::text))::bigint), count(((t2.v ->> 'c1'::text))::bigint)
   ->  Merge Join
         Output: t1.v, t2.v
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         Join Filter: (((((((t1.v ->> 'c1'::text))::bigint * ((t2.v ->> 'c1'::text))::bigint) / (((t1.v ->> 'c1'::text))::bigint * ((t2.v ->> 'c1'::text))::bigint)))::double precision * random()) <= '1'::double precision)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(16 rows)

-- GROUP BY clause having expressions
--Testcase 195:
explain (verbose, costs off)
select (v->>'c2')::int/2, sum((v->>'c2')::int) * ((v->>'c2')::int/2) from ft1 group by (v->>'c2')::int/2 order by (v->>'c2')::int/2;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: ((((v ->> 'c2'::text))::integer / 2)), ((sum(((v ->> 'c2'::text))::integer) * ((((v ->> 'c2'::text))::integer / 2))))
   Sort Key: ((((ft1.v ->> 'c2'::text))::integer / 2))
   ->  HashAggregate
         Output: ((((v ->> 'c2'::text))::integer / 2)), (sum(((v ->> 'c2'::text))::integer) * ((((v ->> 'c2'::text))::integer / 2)))
         Group Key: (((ft1.v ->> 'c2'::text))::integer / 2)
         ->  Foreign Scan on public.ft1
               Output: (((v ->> 'c2'::text))::integer / 2), v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 196:
select (v->>'c2')::int/2, sum((v->>'c2')::int) * ((v->>'c2')::int/2) from ft1 group by (v->>'c2')::int/2 order by (v->>'c2')::int/2;
 ?column? | ?column? 
----------+----------
        0 |        0
        1 |      500
        2 |     1800
        3 |     3900
        4 |     6800
(5 rows)

-- Aggregates in subquery are pushed down.
--Testcase 197:
explain (verbose, costs off)
select count(x.a), sum(x.a) from (select (v->>'c2')::int a, sum((v->>'c1')::int8) b from ft1 group by (v->>'c2')::int, sqrt((v->>'c1')::int8) order by 1, 2) x;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count((((ft1.v ->> 'c2'::text))::integer)), sum((((ft1.v ->> 'c2'::text))::integer))
   ->  Sort
         Output: (((ft1.v ->> 'c2'::text))::integer), (sum(((ft1.v ->> 'c1'::text))::bigint)), (sqrt((((ft1.v ->> 'c1'::text))::bigint)::double precision))
         Sort Key: (((ft1.v ->> 'c2'::text))::integer), (sum(((ft1.v ->> 'c1'::text))::bigint))
         ->  HashAggregate
               Output: (((ft1.v ->> 'c2'::text))::integer), sum(((ft1.v ->> 'c1'::text))::bigint), (sqrt((((ft1.v ->> 'c1'::text))::bigint)::double precision))
               Group Key: ((ft1.v ->> 'c2'::text))::integer, sqrt((((ft1.v ->> 'c1'::text))::bigint)::double precision)
               ->  Foreign Scan on public.ft1
                     Output: ((ft1.v ->> 'c2'::text))::integer, sqrt((((ft1.v ->> 'c1'::text))::bigint)::double precision), ft1.v
                     Reader: Single File
                     Row groups: 1
(12 rows)

--Testcase 198:
select count(x.a), sum(x.a) from (select (v->>'c2')::int a, sum((v->>'c1')::int8) b from ft1 group by (v->>'c2')::int, sqrt((v->>'c1')::int8) order by 1, 2) x;
 count | sum  
-------+------
  1000 | 4500
(1 row)

-- Aggregate is still pushed down by taking unshippable expression out
--Testcase 199:
explain (verbose, costs off)
select (v->>'c2')::int * (random() <= 1)::int as sum1, sum((v->>'c1')::int8) * (v->>'c2')::int as sum2 from ft1 group by (v->>'c2')::int order by 1, 2;
                                                                                                      QUERY PLAN                                                                                                       
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((((v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer)), ((sum(((v ->> 'c1'::text))::bigint) * ((((v ->> 'c2'::text))::integer))::numeric)), (((v ->> 'c2'::text))::integer)
   Sort Key: (((((ft1.v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer)), ((sum(((ft1.v ->> 'c1'::text))::bigint) * ((((ft1.v ->> 'c2'::text))::integer))::numeric))
   ->  HashAggregate
         Output: ((((v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer), (sum(((v ->> 'c1'::text))::bigint) * ((((v ->> 'c2'::text))::integer))::numeric), (((v ->> 'c2'::text))::integer)
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 200:
select (v->>'c2')::int * (random() <= 1)::int as sum1, sum((v->>'c1')::int8) * (v->>'c2')::int as sum2 from ft1 group by (v->>'c2')::int order by 1, 2;
 sum1 |  sum2  
------+--------
    0 |      0
    1 |  49600
    2 |  99400
    3 | 149400
    4 | 199600
    5 | 250000
    6 | 300600
    7 | 351400
    8 | 402400
    9 | 453600
(10 rows)

-- Aggregate with unshippable GROUP BY clause are not pushed
--Testcase 201:
explain (verbose, costs off)
select (v->>'c2')::int * (random() <= 1)::int as c2 from ft2 group by (v->>'c2')::int * (random() <= 1)::int order by 1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort
   Output: ((((v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer))
   Sort Key: ((((ft2.v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer))
   ->  HashAggregate
         Output: ((((v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer))
         Group Key: (((ft2.v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer)
         ->  Foreign Scan on public.ft2
               Output: (((v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer)
               Reader: Single File
               Row groups: 1
(10 rows)

-- GROUP BY clause in various forms, cardinal, alias and constant expression
--Testcase 202:
explain (verbose, costs off)
select count((v->>'c2')::int) w, (v->>'c2')::int x, 5 y, 7.0 z from ft1 group by 2, y, 9.0::int order by 2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort
   Output: (count((((v ->> 'c2'::text))::integer))), (((v ->> 'c2'::text))::integer), 5, 7.0, 9
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  HashAggregate
         Output: count((((v ->> 'c2'::text))::integer)), (((v ->> 'c2'::text))::integer), (5), 7.0, (9)
         Group Key: ((ft1.v ->> 'c2'::text))::integer, 5, 9
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, 5, 9, v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 203:
select count((v->>'c2')::int) w, (v->>'c2')::int x, 5 y, 7.0 z from ft1 group by 2, y, 9.0::int order by 2;
  w  | x | y |  z  
-----+---+---+-----
 100 | 0 | 5 | 7.0
 100 | 1 | 5 | 7.0
 100 | 2 | 5 | 7.0
 100 | 3 | 5 | 7.0
 100 | 4 | 5 | 7.0
 100 | 5 | 5 | 7.0
 100 | 6 | 5 | 7.0
 100 | 7 | 5 | 7.0
 100 | 8 | 5 | 7.0
 100 | 9 | 5 | 7.0
(10 rows)

-- GROUP BY clause referring to same column multiple times
-- Also, ORDER BY contains an aggregate function
--Testcase 204:
explain (verbose, costs off)
select (v->>'c2')::int as c2, (v->>'c2')::int as c2 from ft1 where (v->>'c2')::int > 6 group by 1, 2 order by sum((v->>'c1')::int8);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (sum(((ft1.v ->> 'c1'::text))::bigint))
   ->  HashAggregate
         Output: (((v ->> 'c2'::text))::integer), (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint)
         Group Key: ((ft1.v ->> 'c2'::text))::integer, ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer > 6)
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 205:
select (v->>'c2')::int as c2, (v->>'c2')::int as c2 from ft1 where (v->>'c2')::int > 6 group by 1, 2 order by sum((v->>'c1')::int8);
 c2 | c2 
----+----
  7 |  7
  8 |  8
  9 |  9
(3 rows)

-- Testing HAVING clause shippability
--Testcase 206:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft2 group by (v->>'c2')::int having avg((v->>'c1')::int8) < 500 and sum((v->>'c1')::int8) < 49800 order by (v->>'c2')::int;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (((ft2.v ->> 'c2'::text))::integer)
   ->  HashAggregate
         Output: (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint)
         Group Key: ((ft2.v ->> 'c2'::text))::integer
         Filter: ((avg(((ft2.v ->> 'c1'::text))::bigint) < '500'::numeric) AND (sum(((ft2.v ->> 'c1'::text))::bigint) < '49800'::numeric))
         ->  Foreign Scan on public.ft2
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 207:
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft2 group by (v->>'c2')::int having avg((v->>'c1')::int8) < 500 and sum((v->>'c1')::int8) < 49800 order by (v->>'c2')::int;
 c2 |  sum  
----+-------
  1 | 49600
  2 | 49700
(2 rows)

-- Unshippable HAVING clause will be evaluated locally, and other qual in HAVING clause is pushed down
--Testcase 208:
explain (verbose, costs off)
select count(*) from (select  v->>'c5', count((v->>'c1')::int8) from ft1 group by  v->>'c5', sqrt((v->>'c2')::int) having (avg((v->>'c1')::int8) / avg((v->>'c1')::int8)) * random() <= 1 and avg((v->>'c1')::int8) < 500) x;
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  HashAggregate
         Output: ((ft1.v ->> 'c5'::text)), NULL::bigint, (sqrt((((ft1.v ->> 'c2'::text))::integer)::double precision))
         Group Key: (ft1.v ->> 'c5'::text), sqrt((((ft1.v ->> 'c2'::text))::integer)::double precision)
         Filter: ((avg(((ft1.v ->> 'c1'::text))::bigint) < '500'::numeric) AND ((((avg(((ft1.v ->> 'c1'::text))::bigint) / avg(((ft1.v ->> 'c1'::text))::bigint)))::double precision * random()) <= '1'::double precision))
         ->  Foreign Scan on public.ft1
               Output: (ft1.v ->> 'c5'::text), sqrt((((ft1.v ->> 'c2'::text))::integer)::double precision), ft1.v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 209:
select count(*) from (select  v->>'c5', count((v->>'c1')::int8) from ft1 group by  v->>'c5', sqrt((v->>'c2')::int) having (avg((v->>'c1')::int8) / avg((v->>'c1')::int8)) * random() <= 1 and avg((v->>'c1')::int8) < 500) x;
 count 
-------
    49
(1 row)

-- Aggregate in HAVING clause is not pushable, and thus aggregation is not pushed down
--Testcase 210:
explain (verbose, costs off)
select sum((v->>'c1')::int8) from ft1 group by (v->>'c2')::int having avg((v->>'c1')::int8 * (random() <= 1)::int) > 100 order by 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (sum(((v ->> 'c1'::text))::bigint)), (((v ->> 'c2'::text))::integer)
   Sort Key: (sum(((ft1.v ->> 'c1'::text))::bigint))
   ->  HashAggregate
         Output: sum(((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer)
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         Filter: (avg((((ft1.v ->> 'c1'::text))::bigint * ((random() <= '1'::double precision))::integer)) > '100'::numeric)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(11 rows)

-- Remote aggregate in combination with a local Param (for the output
-- of an initplan) can be trouble, per bug #15781
--Testcase 211:
explain (verbose, costs off)
select exists(select 1 from pg_enum), sum((v->>'c1')::int8) from ft1;
                     QUERY PLAN                      
-----------------------------------------------------
 Aggregate
   Output: $0, sum(((ft1.v ->> 'c1'::text))::bigint)
   InitPlan 1 (returns $0)
     ->  Seq Scan on pg_catalog.pg_enum
   ->  Foreign Scan on public.ft1
         Output: ft1.v
         Reader: Single File
         Row groups: 1
(8 rows)

--Testcase 212:
select exists(select 1 from pg_enum), sum((v->>'c1')::int8) from ft1;
 exists |  sum   
--------+--------
 t      | 500500
(1 row)

--Testcase 213:
explain (verbose, costs off)
select exists(select 1 from pg_enum), sum((v->>'c1')::int8) from ft1 group by 1;
                      QUERY PLAN                       
-------------------------------------------------------
 GroupAggregate
   Output: ($0), sum(((ft1.v ->> 'c1'::text))::bigint)
   Group Key: $0
   InitPlan 1 (returns $0)
     ->  Seq Scan on pg_catalog.pg_enum
   ->  Foreign Scan on public.ft1
         Output: $0, ft1.v
         Reader: Single File
         Row groups: 1
(9 rows)

--Testcase 214:
select exists(select 1 from pg_enum), sum((v->>'c1')::int8) from ft1 group by 1;
 exists |  sum   
--------+--------
 t      | 500500
(1 row)

-- Testing ORDER BY, DISTINCT, FILTER, Ordered-sets and VARIADIC within aggregates
-- ORDER BY within aggregate, same column used to order
--Testcase 215:
explain (verbose, costs off)
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int8) from ft1 where (v->>'c1')::int8 < 100 group by (v->>'c2')::int order by 1;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::bigint)), (((v ->> 'c2'::text))::integer)
   Sort Key: (array_agg(((ft1.v ->> 'c1'::text))::bigint ORDER BY ((ft1.v ->> 'c1'::text))::bigint))
   ->  GroupAggregate
         Output: array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer)
         Group Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Sort
               Output: (((v ->> 'c2'::text))::integer), v
               Sort Key: (((ft1.v ->> 'c2'::text))::integer)
               ->  Foreign Scan on public.ft1
                     Output: ((v ->> 'c2'::text))::integer, v
                     Filter: (((ft1.v ->> 'c1'::text))::bigint < 100)
                     Reader: Single File
                     Row groups: 1
(14 rows)

--Testcase 216:
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int8) from ft1 where (v->>'c1')::int8 < 100 group by (v->>'c2')::int order by 1;
           array_agg            
--------------------------------
 {1,11,21,31,41,51,61,71,81,91}
 {2,12,22,32,42,52,62,72,82,92}
 {3,13,23,33,43,53,63,73,83,93}
 {4,14,24,34,44,54,64,74,84,94}
 {5,15,25,35,45,55,65,75,85,95}
 {6,16,26,36,46,56,66,76,86,96}
 {7,17,27,37,47,57,67,77,87,97}
 {8,18,28,38,48,58,68,78,88,98}
 {9,19,29,39,49,59,69,79,89,99}
 {10,20,30,40,50,60,70,80,90}
(10 rows)

-- ORDER BY within aggregate, different column used to order also using DESC
--Testcase 217:
explain (verbose, costs off)
select array_agg((v->>'c5')::timestamp order by (v->>'c1')::int8 desc) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 50;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: array_agg(((v ->> 'c5'::text))::timestamp without time zone ORDER BY ((v ->> 'c1'::text))::bigint DESC)
   ->  Foreign Scan on public.ft2
         Output: v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint < 50) AND (((ft2.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 218:
select array_agg((v->>'c5')::timestamp order by (v->>'c1')::int8 desc) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 50;
                                                                array_agg                                                                 
------------------------------------------------------------------------------------------------------------------------------------------
 {"Mon Feb 16 00:00:00 1970","Fri Feb 06 00:00:00 1970","Tue Jan 27 00:00:00 1970","Sat Jan 17 00:00:00 1970","Wed Jan 07 00:00:00 1970"}
(1 row)

-- DISTINCT within aggregate
--Testcase 219:
explain (verbose, costs off)
select array_agg(distinct ((t1.v->>'c1')::int8)%5) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint))), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
   Sort Key: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint)))
   ->  GroupAggregate
         Output: array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint)), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         Group Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         ->  Sort
               Output: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint)), t1.v
               Sort Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
               ->  Hash Full Join
                     Output: (((t2.v ->> 'c1'::text))::bigint % '3'::bigint), t1.v
                     Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     Filter: ((((t1.v ->> 'c1'::text))::bigint < 20) OR ((((t1.v ->> 'c1'::text))::bigint IS NULL) AND (((t2.v ->> 'c1'::text))::bigint < 5)))
                     ->  Foreign Scan on public.ft4 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: t2.v
                           ->  Foreign Scan on public.ft5 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(23 rows)

--Testcase 220:
select array_agg(distinct ((t1.v->>'c1')::int8)%5) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
  array_agg   
--------------
 {0,1,2,3,4}
 {1,2,3,NULL}
(2 rows)

-- DISTINCT combined with ORDER BY within aggregate
--Testcase 221:
explain (verbose, costs off)
select array_agg(distinct ((t1.v->>'c1')::int8)%5 order by ((t1.v->>'c1')::int8)%5) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint))), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
   Sort Key: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint)))
   ->  GroupAggregate
         Output: array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint)), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         Group Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         ->  Sort
               Output: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint)), t1.v
               Sort Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
               ->  Hash Full Join
                     Output: (((t2.v ->> 'c1'::text))::bigint % '3'::bigint), t1.v
                     Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     Filter: ((((t1.v ->> 'c1'::text))::bigint < 20) OR ((((t1.v ->> 'c1'::text))::bigint IS NULL) AND (((t2.v ->> 'c1'::text))::bigint < 5)))
                     ->  Foreign Scan on public.ft4 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: t2.v
                           ->  Foreign Scan on public.ft5 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(23 rows)

--Testcase 222:
select array_agg(distinct ((t1.v->>'c1')::int8)%5 order by ((t1.v->>'c1')::int8)%5) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
  array_agg   
--------------
 {0,1,2,3,4}
 {1,2,3,NULL}
(2 rows)

--Testcase 223:
explain (verbose, costs off)
select array_agg(distinct ((t1.v->>'c1')::int8)%5 order by ((t1.v->>'c1')::int8)%5 desc nulls last) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) DESC NULLS LAST)), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
   Sort Key: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) DESC NULLS LAST))
   ->  GroupAggregate
         Output: array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) DESC NULLS LAST), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         Group Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         ->  Sort
               Output: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint)), t1.v
               Sort Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
               ->  Hash Full Join
                     Output: (((t2.v ->> 'c1'::text))::bigint % '3'::bigint), t1.v
                     Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     Filter: ((((t1.v ->> 'c1'::text))::bigint < 20) OR ((((t1.v ->> 'c1'::text))::bigint IS NULL) AND (((t2.v ->> 'c1'::text))::bigint < 5)))
                     ->  Foreign Scan on public.ft4 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: t2.v
                           ->  Foreign Scan on public.ft5 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(23 rows)

--Testcase 224:
select array_agg(distinct ((t1.v->>'c1')::int8)%5 order by ((t1.v->>'c1')::int8)%5 desc nulls last) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
  array_agg   
--------------
 {3,2,1,NULL}
 {4,3,2,1,0}
(2 rows)

-- FILTER within aggregate
--Testcase 225:
explain (verbose, costs off)
select sum((v->>'c1')::int8) filter (where (v->>'c1')::int8 < 100 and (v->>'c2')::int > 5) from ft1 group by (v->>'c2')::int order by 1 nulls last;
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (sum(((v ->> 'c1'::text))::bigint) FILTER (WHERE ((((v ->> 'c1'::text))::bigint < 100) AND ((((v ->> 'c2'::text))::integer) > 5)))), (((v ->> 'c2'::text))::integer)
   Sort Key: (sum(((ft1.v ->> 'c1'::text))::bigint) FILTER (WHERE ((((ft1.v ->> 'c1'::text))::bigint < 100) AND ((((ft1.v ->> 'c2'::text))::integer) > 5))))
   ->  HashAggregate
         Output: sum(((v ->> 'c1'::text))::bigint) FILTER (WHERE ((((v ->> 'c1'::text))::bigint < 100) AND ((((v ->> 'c2'::text))::integer) > 5))), (((v ->> 'c2'::text))::integer)
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 226:
select sum((v->>'c1')::int8) filter (where (v->>'c1')::int8 < 100 and (v->>'c2')::int > 5) from ft1 group by (v->>'c2')::int order by 1 nulls last;
 sum 
-----
 510
 520
 530
 540
    
    
    
    
    
    
(10 rows)

-- DISTINCT, ORDER BY and FILTER within aggregate
--Testcase 227:
explain (verbose, costs off)
select sum((v->>'c1')::int8 % 3), sum(distinct (v->>'c1')::int8 %3 order by (v->>'c1')::int8 % 3) filter (where (v->>'c1')::int8 % 3 < 2), (v->>'c2')::int as c2 from ft1 where (v->>'c2')::int = 6 group by (v->>'c2')::int;
                                                                                                                                    QUERY PLAN                                                                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: sum((((v ->> 'c1'::text))::bigint % '3'::bigint)), sum(DISTINCT (((v ->> 'c1'::text))::bigint % '3'::bigint) ORDER BY (((v ->> 'c1'::text))::bigint % '3'::bigint)) FILTER (WHERE ((((v ->> 'c1'::text))::bigint % '3'::bigint) < 2)), (((v ->> 'c2'::text))::integer)
   Group Key: ((ft1.v ->> 'c2'::text))::integer
   ->  Foreign Scan on public.ft1
         Output: ((v ->> 'c2'::text))::integer, v
         Filter: (((ft1.v ->> 'c2'::text))::integer = 6)
         Reader: Single File
         Row groups: 1
(8 rows)

--Testcase 228:
select sum((v->>'c1')::int8 % 3), sum(distinct (v->>'c1')::int8 %3 order by (v->>'c1')::int8 % 3) filter (where (v->>'c1')::int8 % 3 < 2), (v->>'c2')::int as c2 from ft1 where (v->>'c2')::int = 6 group by (v->>'c2')::int;
 sum | sum | c2 
-----+-----+----
  99 |   1 |  6
(1 row)

-- Outer query is aggregation query
--Testcase 229:
explain (verbose, costs off)
select distinct (select count(*) filter (where (t2.v->>'c2')::int = 6 and (t2.v->>'c1')::int8 < 10) from ft1 t1 where (t1.v->>'c1')::int8 = 6) from ft2 t2 where (t2.v->>'c2')::int % 6 = 0 order by 1;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Unique
   Output: ((SubPlan 1))
   ->  Sort
         Output: ((SubPlan 1))
         Sort Key: ((SubPlan 1))
         ->  Aggregate
               Output: (SubPlan 1)
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Filter: ((((t2.v ->> 'c2'::text))::integer % 6) = 0)
                     Reader: Single File
                     Row groups: 1
               SubPlan 1
                 ->  Foreign Scan on public.ft1 t1
                       Output: count(*) FILTER (WHERE ((((t2.v ->> 'c2'::text))::integer = 6) AND (((t2.v ->> 'c1'::text))::bigint < 10)))
                       Filter: (((t1.v ->> 'c1'::text))::bigint = 6)
                       Reader: Single File
                       Row groups: 1
(18 rows)

--Testcase 230:
select distinct (select count(*) filter (where (t2.v->>'c2')::int = 6 and (t2.v->>'c1')::int8 < 10) from ft1 t1 where (t1.v->>'c1')::int8 = 6) from ft2 t2 where (t2.v->>'c2')::int % 6 = 0 order by 1;
 count 
-------
     1
(1 row)

-- Inner query is aggregation query
--Testcase 231:
explain (verbose, costs off)
select distinct (select count((t1.v->>'c1')::int8) filter (where (t2.v->>'c2')::int = 6 and (t2.v->>'c1')::int8 < 10) from ft1 t1 where (t1.v->>'c1')::int8 = 6) from ft2 t2 where (t2.v->>'c2')::int % 6 = 0 order by 1;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Unique
   Output: ((SubPlan 1))
   ->  Sort
         Output: ((SubPlan 1))
         Sort Key: ((SubPlan 1))
         ->  Foreign Scan on public.ft2 t2
               Output: (SubPlan 1)
               Filter: ((((t2.v ->> 'c2'::text))::integer % 6) = 0)
               Reader: Single File
               Row groups: 1
               SubPlan 1
                 ->  Aggregate
                       Output: count(((t1.v ->> 'c1'::text))::bigint) FILTER (WHERE ((((t2.v ->> 'c2'::text))::integer = 6) AND (((t2.v ->> 'c1'::text))::bigint < 10)))
                       ->  Foreign Scan on public.ft1 t1
                             Output: t1.v
                             Filter: (((t1.v ->> 'c1'::text))::bigint = 6)
                             Reader: Single File
                             Row groups: 1
(18 rows)

--Testcase 232:
select distinct (select count((t1.v->>'c1')::int8) filter (where (t2.v->>'c2')::int = 6 and (t2.v->>'c1')::int8 < 10) from ft1 t1 where (t1.v->>'c1')::int8 = 6) from ft2 t2 where (t2.v->>'c2')::int % 6 = 0 order by 1;
 count 
-------
     0
     1
(2 rows)

-- Aggregate not pushed down as FILTER condition is not pushable
--Testcase 233:
explain (verbose, costs off)
select sum((v->>'c1')::int8) filter (where ((v->>'c1')::int8 / (v->>'c1')::int8) * random() <= 1) from ft1 group by (v->>'c2')::int order by 1;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (sum(((v ->> 'c1'::text))::bigint) FILTER (WHERE ((((((v ->> 'c1'::text))::bigint / ((v ->> 'c1'::text))::bigint))::double precision * random()) <= '1'::double precision))), (((v ->> 'c2'::text))::integer)
   Sort Key: (sum(((ft1.v ->> 'c1'::text))::bigint) FILTER (WHERE ((((((ft1.v ->> 'c1'::text))::bigint / ((ft1.v ->> 'c1'::text))::bigint))::double precision * random()) <= '1'::double precision)))
   ->  HashAggregate
         Output: sum(((v ->> 'c1'::text))::bigint) FILTER (WHERE ((((((v ->> 'c1'::text))::bigint / ((v ->> 'c1'::text))::bigint))::double precision * random()) <= '1'::double precision)), (((v ->> 'c2'::text))::integer)
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 234:
explain (verbose, costs off)
select sum((v->>'c2')::int) filter (where (v->>'c2')::int in (select (v->>'c2')::int from ft1 where (v->>'c2')::int < 5)) from ft1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Aggregate
   Output: sum(((ft1.v ->> 'c2'::text))::integer) FILTER (WHERE (hashed SubPlan 1))
   ->  Foreign Scan on public.ft1
         Output: ft1.v
         Reader: Single File
         Row groups: 1
   SubPlan 1
     ->  Foreign Scan on public.ft1 ft1_1
           Output: ((ft1_1.v ->> 'c2'::text))::integer
           Filter: (((ft1_1.v ->> 'c2'::text))::integer < 5)
           Reader: Single File
           Row groups: 1
(12 rows)

-- Ordered-sets within aggregate
--Testcase 235:
explain (verbose, costs off)
select (v->>'c2')::int as c2, rank('10'::varchar) within group (order by v->>'c6'), percentile_cont((v->>'c2')::int/10::numeric) within group (order by (v->>'c1')::int8) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int having percentile_cont((v->>'c2')::int/10::numeric) within group (order by (v->>'c1')::int8) < 500 order by (v->>'c2')::int;
                                                                                                                                      QUERY PLAN                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c2'::text))::integer), rank('10'::text) WITHIN GROUP (ORDER BY (v ->> 'c6'::text)), percentile_cont(((((((v ->> 'c2'::text))::integer))::numeric / '10'::numeric))::double precision) WITHIN GROUP (ORDER BY ((((v ->> 'c1'::text))::bigint)::double precision))
   Group Key: (((ft1.v ->> 'c2'::text))::integer)
   Filter: (percentile_cont(((((((ft1.v ->> 'c2'::text))::integer))::numeric / '10'::numeric))::double precision) WITHIN GROUP (ORDER BY ((((ft1.v ->> 'c1'::text))::bigint)::double precision)) < '500'::double precision)
   ->  Sort
         Output: (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 10)
               Reader: Single File
               Row groups: 1
(12 rows)

--Testcase 236:
select (v->>'c2')::int as c2, rank('10'::varchar) within group (order by v->>'c6'), percentile_cont((v->>'c2')::int/10::numeric) within group (order by (v->>'c1')::int8) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int having percentile_cont((v->>'c2')::int/10::numeric) within group (order by (v->>'c1')::int8) < 500 order by (v->>'c2')::int;
 c2 | rank | percentile_cont 
----+------+-----------------
  0 |  101 |              10
  1 |  101 |             100
  2 |    1 |             200
  3 |    1 |             300
  4 |    1 |             400
(5 rows)

-- Using multiple arguments within aggregates
--Testcase 237:
explain (verbose, costs off)
select (v->>'c1')::int8 as c1, rank((v->>'c1')::int8, (v->>'c2')::int) within group (order by (v->>'c1')::int8, (v->>'c2')::int) from ft1 group by (v->>'c1')::int8, (v->>'c2')::int, v having (v->>'c1')::int8 = 6 order by 1;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c1'::text))::bigint), rank((((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer)) WITHIN GROUP (ORDER BY (((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer)), (((v ->> 'c2'::text))::integer), v
   Group Key: (((ft1.v ->> 'c1'::text))::bigint), (((ft1.v ->> 'c2'::text))::integer), ft1.v
   ->  Sort
         Output: (((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer), ft1.v
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c1'::text))::bigint, ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c1'::text))::bigint = 6)
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 238:
select (v->>'c1')::int8 as c1, rank((v->>'c1')::int8, (v->>'c2')::int) within group (order by (v->>'c1')::int8, (v->>'c2')::int) from ft1 group by (v->>'c1')::int8, (v->>'c2')::int, v having (v->>'c1')::int8 = 6 order by 1;
 c1 | rank 
----+------
  6 |    1
(1 row)

-- User defined function for user defined aggregate, VARIADIC
--Testcase 239:
create function least_accum(anyelement, variadic anyarray)
returns anyelement language sql as
  'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
--Testcase 240:
create aggregate least_agg(variadic items anyarray) (
  stype = anyelement, sfunc = least_accum
);
-- Disable hash aggregation for plan stability.
--Testcase 473:
set enable_hashagg to false;
-- Not pushed down due to user defined aggregate
--Testcase 241:
explain (verbose, costs off)
select (v->>'c2')::int as c2, least_agg((v->>'c1')::int8) from ft1 group by (v->>'c2')::int order by (v->>'c2')::int;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c2'::text))::integer), least_agg(VARIADIC ARRAY[((v ->> 'c1'::text))::bigint])
   Group Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  Sort
         Output: (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

-- Add function and aggregate into extension
--Testcase 474:
alter extension parquet_s3_fdw add function least_accum(anyelement, variadic anyarray);
--Testcase 475:
alter extension parquet_s3_fdw add aggregate least_agg(variadic items anyarray);
--Testcase 476:
alter server parquet_s3_srv options (set extensions 'parquet_s3_fdw');
-- Now aggregate will be pushed.  Aggregate will display VARIADIC argument.
--Testcase 242:
explain (verbose, costs off)
select (v->>'c2')::int as c2, least_agg((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 100 group by (v->>'c2')::int order by (v->>'c2')::int;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c2'::text))::integer), least_agg(VARIADIC ARRAY[((v ->> 'c1'::text))::bigint])
   Group Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  Sort
         Output: (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 100)
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 243:
select (v->>'c2')::int as c2, least_agg((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 100 group by (v->>'c2')::int order by (v->>'c2')::int;
 c2 | least_agg 
----+-----------
  0 |        10
  1 |         1
  2 |         2
  3 |         3
  4 |         4
  5 |         5
  6 |         6
  7 |         7
  8 |         8
  9 |         9
(10 rows)

-- Remove function and aggregate from extension
--Testcase 477:
alter extension parquet_s3_fdw drop function least_accum(anyelement, variadic anyarray);
--Testcase 478:
alter extension parquet_s3_fdw drop aggregate least_agg(variadic items anyarray);
--Testcase 479:
alter server parquet_s3_srv options (set extensions 'parquet_s3_fdw');
-- Not pushed down as we have dropped objects from extension.
--Testcase 244:
explain (verbose, costs off)
select (v->>'c2')::int as c2, least_agg((v->>'c1')::int8) from ft1 group by (v->>'c2')::int order by (v->>'c2')::int;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c2'::text))::integer), least_agg(VARIADIC ARRAY[((v ->> 'c1'::text))::bigint])
   Group Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  Sort
         Output: (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

-- Cleanup
--Testcase 480:
reset enable_hashagg;
--Testcase 245:
drop aggregate least_agg(variadic items anyarray);
--Testcase 246:
drop function least_accum(anyelement, variadic anyarray);
-- Testing USING OPERATOR() in ORDER BY within aggregate.
-- For this, we need user defined operators along with operator family and
-- operator class.  Create those and then add them in extension.  Note that
-- user defined objects are considered unshippable unless they are part of
-- the extension.
--Testcase 247:
create operator public.<^ (
 leftarg = int4,
 rightarg = int4,
 procedure = int4eq
);
--Testcase 248:
create operator public.=^ (
 leftarg = int4,
 rightarg = int4,
 procedure = int4lt
);
--Testcase 249:
create operator public.>^ (
 leftarg = int4,
 rightarg = int4,
 procedure = int4gt
);
--Testcase 250:
create operator family my_op_family using btree;
--Testcase 251:
create function my_op_cmp(a int, b int) returns int as
  $$begin return btint4cmp(a, b); end $$ language plpgsql;
--Testcase 252:
create operator class my_op_class for type int using btree family my_op_family as
 operator 1 public.<^,
 operator 3 public.=^,
 operator 5 public.>^,
 function 1 my_op_cmp(int, int);
-- This will not be pushed as user defined sort operator is not part of the
-- extension yet.
--Testcase 253:
explain (verbose, costs off)
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int using operator(public.<^)) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 100 group by (v->>'c2')::int;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::integer USING <^ NULLS LAST), (((v ->> 'c2'::text))::integer)
   Group Key: ((ft2.v ->> 'c2'::text))::integer
   ->  Foreign Scan on public.ft2
         Output: ((v ->> 'c2'::text))::integer, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint < 100) AND (((ft2.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
(8 rows)

-- Update local stats on ft2
-- ANALYZE ft2;
-- Add into extension
--Testcase 481:
alter extension parquet_s3_fdw add operator class my_op_class using btree;
--Testcase 482:
alter extension parquet_s3_fdw add function my_op_cmp(a int, b int);
--Testcase 483:
alter extension parquet_s3_fdw add operator family my_op_family using btree;
--Testcase 484:
alter extension parquet_s3_fdw add operator public.<^(int, int);
--Testcase 485:
alter extension parquet_s3_fdw add operator public.=^(int, int);
--Testcase 486:
alter extension parquet_s3_fdw add operator public.>^(int, int);
--Testcase 487:
alter server parquet_s3_srv options (set extensions 'parquet_s3_fdw');
-- Now this will be pushed as sort operator is part of the extension.
--Testcase 254:
explain (verbose, costs off)
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int using operator(public.<^)) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 100 group by (v->>'c2')::int;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::integer USING <^ NULLS LAST), (((v ->> 'c2'::text))::integer)
   Group Key: ((ft2.v ->> 'c2'::text))::integer
   ->  Foreign Scan on public.ft2
         Output: ((v ->> 'c2'::text))::integer, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint < 100) AND (((ft2.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
(8 rows)

--Testcase 255:
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int using operator(public.<^)) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 100 group by (v->>'c2')::int;
           array_agg            
--------------------------------
 {6,16,26,36,46,56,66,76,86,96}
(1 row)

-- Remove from extension
--Testcase 488:
alter extension parquet_s3_fdw drop operator class my_op_class using btree;
--Testcase 489:
alter extension parquet_s3_fdw drop function my_op_cmp(a int, b int);
--Testcase 490:
alter extension parquet_s3_fdw drop operator family my_op_family using btree;
--Testcase 491:
alter extension parquet_s3_fdw drop operator public.<^(int, int);
--Testcase 492:
alter extension parquet_s3_fdw drop operator public.=^(int, int);
--Testcase 493:
alter extension parquet_s3_fdw drop operator public.>^(int, int);
--Testcase 494:
alter server parquet_s3_srv options (set extensions 'parquet_s3_fdw');
-- This will not be pushed as sort operator is now removed from the extension.
--Testcase 256:
explain (verbose, costs off)
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int using operator(public.<^)) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 100 group by (v->>'c2')::int;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::integer USING <^ NULLS LAST), (((v ->> 'c2'::text))::integer)
   Group Key: ((ft2.v ->> 'c2'::text))::integer
   ->  Foreign Scan on public.ft2
         Output: ((v ->> 'c2'::text))::integer, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint < 100) AND (((ft2.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
(8 rows)

-- Cleanup
--Testcase 257:
drop operator class my_op_class using btree;
--Testcase 258:
drop function my_op_cmp(a int, b int);
--Testcase 259:
drop operator family my_op_family using btree;
--Testcase 260:
drop operator public.>^(int, int);
--Testcase 261:
drop operator public.=^(int, int);
--Testcase 262:
drop operator public.<^(int, int);
-- Input relation to aggregate push down hook is not safe to pushdown and thus
-- the aggregate cannot be pushed down to foreign server.
--Testcase 263:
explain (verbose, costs off)
select count(t1.v->>'c3') from ft2 t1 left join ft2 t2 on ((t1.v->>'c1')::int8 = random() * (t2.v->>'c2')::int);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count((t1.v ->> 'c3'::text))
   ->  Nested Loop Left Join
         Output: t1.v
         Join Filter: ((((t1.v ->> 'c1'::text))::bigint)::double precision = (random() * (((t2.v ->> 'c2'::text))::integer)::double precision))
         ->  Foreign Scan on public.ft2 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(15 rows)

-- Subquery in FROM clause having aggregate
--Testcase 264:
explain (verbose, costs off)
select count(*), x.b from ft1, (select (v->>'c2')::int a, sum((v->>'c1')::int8) b from ft1 group by (v->>'c2')::int) x where (ft1.v->>'c2')::int = x.a group by x.b order by 1, 2;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (count(*)), x.b
   Sort Key: (count(*)), x.b
   ->  HashAggregate
         Output: count(*), x.b
         Group Key: x.b
         ->  Hash Join
               Output: x.b
               Inner Unique: true
               Hash Cond: (((ft1.v ->> 'c2'::text))::integer = x.a)
               ->  Foreign Scan on public.ft1
                     Output: ft1.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: x.b, x.a
                     ->  Subquery Scan on x
                           Output: x.b, x.a
                           ->  HashAggregate
                                 Output: (((ft1_1.v ->> 'c2'::text))::integer), sum(((ft1_1.v ->> 'c1'::text))::bigint)
                                 Group Key: ((ft1_1.v ->> 'c2'::text))::integer
                                 ->  Foreign Scan on public.ft1 ft1_1
                                       Output: ((ft1_1.v ->> 'c2'::text))::integer, ft1_1.v
                                       Reader: Single File
                                       Row groups: 1
(25 rows)

--Testcase 265:
select count(*), x.b from ft1, (select (v->>'c2')::int a, sum((v->>'c1')::int8) b from ft1 group by (v->>'c2')::int) x where (ft1.v->>'c2')::int = x.a group by x.b order by 1, 2;
 count |   b   
-------+-------
   100 | 49600
   100 | 49700
   100 | 49800
   100 | 49900
   100 | 50000
   100 | 50100
   100 | 50200
   100 | 50300
   100 | 50400
   100 | 50500
(10 rows)

-- FULL join with IS NULL check in HAVING
--Testcase 266:
explain (verbose, costs off)
select avg((t1.v->>'c1')::int8), sum((t2.v->>'c1')::int8) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) group by (t2.v->>'c1')::int8 having (avg((t1.v->>'c1')::int8) is null and sum((t2.v->>'c1')::int8) < 10) or sum((t2.v->>'c1')::int8) is null order by 1 nulls last, 2;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (avg(((t1.v ->> 'c1'::text))::bigint)), (sum((((t2.v ->> 'c1'::text))::bigint))), (((t2.v ->> 'c1'::text))::bigint)
   Sort Key: (avg(((t1.v ->> 'c1'::text))::bigint)), (sum((((t2.v ->> 'c1'::text))::bigint)))
   ->  HashAggregate
         Output: avg(((t1.v ->> 'c1'::text))::bigint), sum((((t2.v ->> 'c1'::text))::bigint)), (((t2.v ->> 'c1'::text))::bigint)
         Group Key: ((t2.v ->> 'c1'::text))::bigint
         Filter: (((avg(((t1.v ->> 'c1'::text))::bigint) IS NULL) AND (sum((((t2.v ->> 'c1'::text))::bigint)) < '10'::numeric)) OR (sum((((t2.v ->> 'c1'::text))::bigint)) IS NULL))
         ->  Hash Full Join
               Output: ((t2.v ->> 'c1'::text))::bigint, t1.v, t2.v
               Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(20 rows)

--Testcase 267:
select avg((t1.v->>'c1')::int8), sum((t2.v->>'c1')::int8) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) group by (t2.v->>'c1')::int8 having (avg((t1.v->>'c1')::int8) is null and sum((t2.v->>'c1')::int8) < 10) or sum((t2.v->>'c1')::int8) is null order by 1 nulls last, 2;
         avg         | sum 
---------------------+-----
 51.0000000000000000 |    
                     |   3
                     |   9
(3 rows)

-- Aggregate over FULL join needing to deparse the joining relations as
-- subqueries.
--Testcase 268:
explain (verbose, costs off)
select count(*), sum(t1.c1), avg(t2.c1) from (select (v->>'c1')::int8 as c1 from ft4 where (v->>'c1')::int8 between 50 and 60) t1 full join (select (v->>'c1')::int8 as c1 from ft5 where (v->>'c1')::int8 between 50 and 60) t2 on (t1.c1 = t2.c1);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(*), sum(((ft4.v ->> 'c1'::text))::bigint), avg(((ft5.v ->> 'c1'::text))::bigint)
   ->  Hash Full Join
         Output: ft4.v, ft5.v
         Hash Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4
               Output: ft4.v
               Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: ft5.v
               ->  Foreign Scan on public.ft5
                     Output: ft5.v
                     Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(17 rows)

--Testcase 269:
select count(*), sum(t1.c1), avg(t2.c1) from (select (v->>'c1')::int8 as c1 from ft4 where (v->>'c1')::int8 between 50 and 60) t1 full join (select (v->>'c1')::int8 as c1 from ft5 where (v->>'c1')::int8 between 50 and 60) t2 on (t1.c1 = t2.c1);
 count | sum |         avg         
-------+-----+---------------------
     8 | 330 | 55.5000000000000000
(1 row)

-- ORDER BY expression is part of the target list but not pushed down to
-- foreign server.
--Testcase 270:
explain (verbose, costs off)
select sum((v->>'c2')::int) * (random() <= 1)::int as sum from ft1 order by 1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort
   Output: ((sum(((v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer))
   Sort Key: ((sum(((ft1.v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer))
   ->  Aggregate
         Output: (sum(((v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer)
         ->  Foreign Scan on public.ft1
               Output: v
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 271:
select sum((v->>'c2')::int) * (random() <= 1)::int as sum from ft1 order by 1;
 sum  
------
 4500
(1 row)

-- LATERAL join, with parameterization
--Testcase 495:
set enable_hashagg to false;
--Testcase 272:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum from "S 1"."T1" t1, lateral (select sum((t2.v->>'c1')::int8 + (t1.v->>'c1')::int8) sum from ft2 t2 group by (t2.v->>'c1')::int8) qry where (t1.v->>'c2')::int * 2 = qry.sum and (t1.v->>'c2')::int < 3 and (t1.v->>'c1')::int8 < 100 order by 1;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((t1.v ->> 'c2'::text))::integer), qry.sum
   Sort Key: (((t1.v ->> 'c2'::text))::integer)
   ->  Nested Loop
         Output: ((t1.v ->> 'c2'::text))::integer, qry.sum
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Filter: ((((t1.v ->> 'c2'::text))::integer < 3) AND (((t1.v ->> 'c1'::text))::bigint < 100))
               Reader: Single File
               Row groups: 1
         ->  Subquery Scan on qry
               Output: qry.sum, (((t2.v ->> 'c1'::text))::bigint)
               Filter: (((((t1.v ->> 'c2'::text))::integer * 2))::numeric = qry.sum)
               ->  GroupAggregate
                     Output: sum(((((t2.v ->> 'c1'::text))::bigint) + ((t1.v ->> 'c1'::text))::bigint)), (((t2.v ->> 'c1'::text))::bigint)
                     Group Key: ((t2.v ->> 'c1'::text))::bigint
                     ->  Foreign Scan on public.ft2 t2
                           Output: ((t2.v ->> 'c1'::text))::bigint, t2.v
                           Reader: Single File
                           Row groups: 1
(20 rows)

--Testcase 273:
select (v->>'c2')::int as c2, sum from "S 1"."T1" t1, lateral (select sum((t2.v->>'c1')::int8 + (t1.v->>'c1')::int8) sum from ft2 t2 group by (t2.v->>'c1')::int8) qry where (t1.v->>'c2')::int * 2 = qry.sum and (t1.v->>'c2')::int < 3 and (t1.v->>'c1')::int8 < 100 order by 1;
 c2 | sum 
----+-----
  1 |   2
  2 |   4
(2 rows)

--Testcase 496:
reset enable_hashagg;
-- bug #15613: bad plan for foreign table scan with lateral reference
--Testcase 274:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (ref_0.v->>'c2')::int8 AS c2, subq_1.*
FROM
    "S 1"."T1" AS ref_0,
    LATERAL (
        SELECT (ref_0.v->>'c1')::int8 c1, subq_0.*
        FROM (SELECT (ref_0.v->>'c2')::int as c2, (ref_1.v->>'c3') as c3
              FROM ft1 AS ref_1) AS subq_0
             RIGHT JOIN ft2 AS ref_3 ON (subq_0.c3 = (ref_3.v->>'c3'))
    ) AS subq_1
WHERE (ref_0.v->>'c1')::int8 < 10 AND subq_1.c3 = '00001'
ORDER BY (ref_0.v->>'c1')::int8;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: ((ref_0.v ->> 'c2'::text))::bigint, ((ref_0.v ->> 'c1'::text))::bigint, (((ref_0.v ->> 'c2'::text))::integer), (ref_1.v ->> 'c3'::text), ((ref_0.v ->> 'c1'::text))::bigint
   ->  Nested Loop
         Output: ref_0.v, ref_1.v, (((ref_0.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on "S 1"."T1" ref_0
               Output: ref_0.v
               Filter: (((ref_0.v ->> 'c1'::text))::bigint < 10)
               Reader: Single File
               Row groups: 1
         ->  Foreign Scan on public.ft1 ref_1
               Output: ref_1.v, ((ref_0.v ->> 'c2'::text))::integer
               Filter: ((ref_1.v ->> 'c3'::text) = '00001'::text)
               Reader: Single File
               Row groups: 1
   ->  Materialize
         Output: ref_3.v
         ->  Foreign Scan on public.ft2 ref_3
               Output: ref_3.v
               Filter: ((ref_3.v ->> 'c3'::text) = '00001'::text)
               Reader: Single File
               Row groups: 1
(21 rows)

--Testcase 275:
SELECT (ref_0.v->>'c2')::int8 AS c2, subq_1.*
FROM
    "S 1"."T1" AS ref_0,
    LATERAL (
        SELECT (ref_0.v->>'c1')::int8 c1, subq_0.*
        FROM (SELECT (ref_0.v->>'c2')::int as c2, (ref_1.v->>'c3') as c3
              FROM ft1 AS ref_1) AS subq_0
             RIGHT JOIN ft2 AS ref_3 ON (subq_0.c3 = (ref_3.v->>'c3'))
    ) AS subq_1
WHERE (ref_0.v->>'c1')::int8 < 10 AND subq_1.c3 = '00001'
ORDER BY (ref_0.v->>'c1')::int8;
 c2 | c1 | c2 |  c3   
----+----+----+-------
  1 |  1 |  1 | 00001
  2 |  2 |  2 | 00001
  3 |  3 |  3 | 00001
  4 |  4 |  4 | 00001
  5 |  5 |  5 | 00001
  6 |  6 |  6 | 00001
  7 |  7 |  7 | 00001
  8 |  8 |  8 | 00001
  9 |  9 |  9 | 00001
(9 rows)

-- Check with placeHolderVars
--Testcase 276:
explain (verbose, costs off)
select sum(q.a), count(q.b) from ft4 left join (select 13, avg((ft1.v->>'c1')::int8), sum((ft2.v->>'c1')::int8) from ft1 right join ft2 on ((ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8)) q(a, b, c) on ((ft4.v->>'c1')::int8 <= q.b);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum(q.a), count(q.b)
   ->  Nested Loop Left Join
         Output: q.a, q.b
         Inner Unique: true
         Join Filter: ((((ft4.v ->> 'c1'::text))::bigint)::numeric <= q.b)
         ->  Foreign Scan on public.ft4
               Output: ft4.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: q.a, q.b
               ->  Subquery Scan on q
                     Output: q.a, q.b
                     ->  Aggregate
                           Output: 13, avg(((ft1.v ->> 'c1'::text))::bigint), NULL::numeric
                           ->  Merge Left Join
                                 Output: ft1.v
                                 Merge Cond: (((ft2.v ->> 'c1'::text))::bigint = ((ft1.v ->> 'c1'::text))::bigint)
                                 ->  Foreign Scan on public.ft2
                                       Output: ft2.v
                                       Reader: Single File
                                       Row groups: 1
                                 ->  Materialize
                                       Output: ft1.v
                                       ->  Foreign Scan on public.ft1
                                             Output: ft1.v
                                             Reader: Single File
                                             Row groups: 1
(29 rows)

--Testcase 277:
select sum(q.a), count(q.b) from ft4 left join (select 13, avg((ft1.v->>'c1')::int8), sum((ft2.v->>'c1')::int8) from ft1 right join ft2 on ((ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8)) q(a, b, c) on ((ft4.v->>'c1')::int8 <= q.b);
 sum | count 
-----+-------
 650 |    50
(1 row)

-- Not supported cases
-- Grouping sets
--Testcase 278:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by rollup((v->>'c2')::int) order by 1 nulls last;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  MixedAggregate
         Output: (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint)
         Hash Key: ((ft1.v ->> 'c2'::text))::integer
         Group Key: ()
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 3)
               Reader: Single File
               Row groups: 1
(12 rows)

--Testcase 279:
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by rollup((v->>'c2')::int) order by 1 nulls last;
 c2 |  sum   
----+--------
  0 |  50500
  1 |  49600
  2 |  49700
    | 149800
(4 rows)

--Testcase 280:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by cube((v->>'c2')::int) order by 1 nulls last;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  MixedAggregate
         Output: (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint)
         Hash Key: ((ft1.v ->> 'c2'::text))::integer
         Group Key: ()
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 3)
               Reader: Single File
               Row groups: 1
(12 rows)

--Testcase 281:
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by cube((v->>'c2')::int) order by 1 nulls last;
 c2 |  sum   
----+--------
  0 |  50500
  1 |  49600
  2 |  49700
    | 149800
(4 rows)

--Testcase 282:
explain (verbose, costs off)
select (v->>'c2')::int as c2, (v->>'c6') as c6, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by grouping sets((v->>'c2')::int, (v->>'c6')) order by 1 nulls last, 2 nulls last;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), ((v ->> 'c6'::text)), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer), ((ft1.v ->> 'c6'::text))
   ->  HashAggregate
         Output: (((v ->> 'c2'::text))::integer), ((v ->> 'c6'::text)), sum(((v ->> 'c1'::text))::bigint)
         Hash Key: ((ft1.v ->> 'c2'::text))::integer
         Hash Key: (ft1.v ->> 'c6'::text)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, (v ->> 'c6'::text), v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 3)
               Reader: Single File
               Row groups: 1
(12 rows)

--Testcase 283:
select (v->>'c2')::int as c2, (v->>'c6') as c6, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by grouping sets((v->>'c2')::int, (v->>'c6')) order by 1 nulls last, 2 nulls last;
 c2 | c6 |  sum  
----+----+-------
  0 |    | 50500
  1 |    | 49600
  2 |    | 49700
    | 0  | 50500
    | 1  | 49600
    | 2  | 49700
(6 rows)

--Testcase 284:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c1')::int8), grouping((v->>'c2')::int) from ft1 where (v->>'c2')::int < 3 group by (v->>'c2')::int order by 1 nulls last;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint)), (GROUPING((((v ->> 'c2'::text))::integer)))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  HashAggregate
         Output: (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint), GROUPING((((v ->> 'c2'::text))::integer))
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 3)
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 285:
select (v->>'c2')::int as c2, sum((v->>'c1')::int8), grouping((v->>'c2')::int) from ft1 where (v->>'c2')::int < 3 group by (v->>'c2')::int order by 1 nulls last;
 c2 |  sum  | grouping 
----+-------+----------
  0 | 50500 |        0
  1 | 49600 |        0
  2 | 49700 |        0
(3 rows)

-- DISTINCT itself is not pushed down, whereas underneath aggregate is pushed
--Testcase 286:
explain (verbose, costs off)
select distinct sum((v->>'c1')::int4)/1000 s from ft2 where (v->>'c2')::int < 6 group by (v->>'c2')::int order by 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Unique
   Output: ((sum(((v ->> 'c1'::text))::integer) / 1000)), (((v ->> 'c2'::text))::integer)
   ->  Sort
         Output: ((sum(((v ->> 'c1'::text))::integer) / 1000)), (((v ->> 'c2'::text))::integer)
         Sort Key: ((sum(((ft2.v ->> 'c1'::text))::integer) / 1000))
         ->  HashAggregate
               Output: (sum(((v ->> 'c1'::text))::integer) / 1000), (((v ->> 'c2'::text))::integer)
               Group Key: ((ft2.v ->> 'c2'::text))::integer
               ->  Foreign Scan on public.ft2
                     Output: ((v ->> 'c2'::text))::integer, v
                     Filter: (((ft2.v ->> 'c2'::text))::integer < 6)
                     Reader: Single File
                     Row groups: 1
(13 rows)

--Testcase 287:
select distinct sum((v->>'c1')::int4)/1000 s from ft2 where (v->>'c2')::int < 6 group by (v->>'c2')::int order by 1;
 s  
----
 49
 50
(2 rows)

-- WindowAgg
--Testcase 288:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c2')::int), count((v->>'c2')::int) over (partition by (v->>'c2')::int%2) from ft2 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum((((v ->> 'c2'::text))::integer))), (count((((v ->> 'c2'::text))::integer)) OVER (?)), (((((v ->> 'c2'::text))::integer) % 2))
   Sort Key: (((ft2.v ->> 'c2'::text))::integer)
   ->  WindowAgg
         Output: (((v ->> 'c2'::text))::integer), (sum((((v ->> 'c2'::text))::integer))), count((((v ->> 'c2'::text))::integer)) OVER (?), (((((v ->> 'c2'::text))::integer) % 2))
         ->  Sort
               Output: (((v ->> 'c2'::text))::integer), (((((v ->> 'c2'::text))::integer) % 2)), (sum((((v ->> 'c2'::text))::integer))), v
               Sort Key: (((((ft2.v ->> 'c2'::text))::integer) % 2))
               ->  HashAggregate
                     Output: (((v ->> 'c2'::text))::integer), ((((v ->> 'c2'::text))::integer) % 2), sum((((v ->> 'c2'::text))::integer)), v
                     Group Key: ((ft2.v ->> 'c2'::text))::integer
                     ->  Foreign Scan on public.ft2
                           Output: ((v ->> 'c2'::text))::integer, v
                           Filter: (((ft2.v ->> 'c2'::text))::integer < 10)
                           Reader: Single File
                           Row groups: 1
(16 rows)

--Testcase 289:
select (v->>'c2')::int as c2, sum((v->>'c2')::int), count((v->>'c2')::int) over (partition by (v->>'c2')::int%2) from ft2 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
 c2 | sum | count 
----+-----+-------
  0 |   0 |     5
  1 | 100 |     5
  2 | 200 |     5
  3 | 300 |     5
  4 | 400 |     5
  5 | 500 |     5
  6 | 600 |     5
  7 | 700 |     5
  8 | 800 |     5
  9 | 900 |     5
(10 rows)

--Testcase 290:
explain (verbose, costs off)
select (v->>'c2')::int as c2, array_agg((v->>'c2')::int) over (partition by (v->>'c2')::int%2 order by (v->>'c2')::int desc) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (array_agg((((v ->> 'c2'::text))::integer)) OVER (?)), (((((v ->> 'c2'::text))::integer) % 2))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  WindowAgg
         Output: (((v ->> 'c2'::text))::integer), array_agg((((v ->> 'c2'::text))::integer)) OVER (?), (((((v ->> 'c2'::text))::integer) % 2))
         ->  Sort
               Output: (((v ->> 'c2'::text))::integer), (((((v ->> 'c2'::text))::integer) % 2)), v
               Sort Key: (((((ft1.v ->> 'c2'::text))::integer) % 2)), (((ft1.v ->> 'c2'::text))::integer) DESC
               ->  HashAggregate
                     Output: (((v ->> 'c2'::text))::integer), ((((v ->> 'c2'::text))::integer) % 2), v
                     Group Key: ((ft1.v ->> 'c2'::text))::integer
                     ->  Foreign Scan on public.ft1
                           Output: ((v ->> 'c2'::text))::integer, v
                           Filter: (((ft1.v ->> 'c2'::text))::integer < 10)
                           Reader: Single File
                           Row groups: 1
(16 rows)

--Testcase 291:
select (v->>'c2')::int as c2, array_agg((v->>'c2')::int) over (partition by (v->>'c2')::int%2 order by (v->>'c2')::int desc) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
 c2 |  array_agg  
----+-------------
  0 | {8,6,4,2,0}
  1 | {9,7,5,3,1}
  2 | {8,6,4,2}
  3 | {9,7,5,3}
  4 | {8,6,4}
  5 | {9,7,5}
  6 | {8,6}
  7 | {9,7}
  8 | {8}
  9 | {9}
(10 rows)

--Testcase 292:
explain (verbose, costs off)
select (v->>'c2')::int as c2, array_agg((v->>'c2')::int) over (partition by (v->>'c2')::int%2 order by (v->>'c2')::int range between current row and unbounded following) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (array_agg((((v ->> 'c2'::text))::integer)) OVER (?)), (((((v ->> 'c2'::text))::integer) % 2))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  WindowAgg
         Output: (((v ->> 'c2'::text))::integer), array_agg((((v ->> 'c2'::text))::integer)) OVER (?), (((((v ->> 'c2'::text))::integer) % 2))
         ->  Sort
               Output: (((v ->> 'c2'::text))::integer), (((((v ->> 'c2'::text))::integer) % 2)), v
               Sort Key: (((((ft1.v ->> 'c2'::text))::integer) % 2)), (((ft1.v ->> 'c2'::text))::integer)
               ->  HashAggregate
                     Output: (((v ->> 'c2'::text))::integer), ((((v ->> 'c2'::text))::integer) % 2), v
                     Group Key: ((ft1.v ->> 'c2'::text))::integer
                     ->  Foreign Scan on public.ft1
                           Output: ((v ->> 'c2'::text))::integer, v
                           Filter: (((ft1.v ->> 'c2'::text))::integer < 10)
                           Reader: Single File
                           Row groups: 1
(16 rows)

--Testcase 293:
select (v->>'c2')::int as c2, array_agg((v->>'c2')::int) over (partition by (v->>'c2')::int%2 order by (v->>'c2')::int range between current row and unbounded following) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
 c2 |  array_agg  
----+-------------
  0 | {0,2,4,6,8}
  1 | {1,3,5,7,9}
  2 | {2,4,6,8}
  3 | {3,5,7,9}
  4 | {4,6,8}
  5 | {5,7,9}
  6 | {6,8}
  7 | {7,9}
  8 | {8}
  9 | {9}
(10 rows)

-- ===================================================================
-- parameterized queries
-- ===================================================================
-- simple join
--Testcase 294:
PREPARE st1(int, int) AS SELECT (t1.v->>'c3') as c3, (t2.v->>'c3') as c3 FROM ft1 t1, ft2 t2 WHERE (t1.v->>'c1')::int8 = $1 AND (t2.v->>'c1')::int8 = $2;
--Testcase 295:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st1(1, 2);
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop
   Output: (t1.v ->> 'c3'::text), (t2.v ->> 'c3'::text)
   ->  Foreign Scan on public.ft1 t1
         Output: t1.v
         Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
         Reader: Single File
         Row groups: 1
   ->  Materialize
         Output: t2.v
         ->  Foreign Scan on public.ft2 t2
               Output: t2.v
               Filter: (((t2.v ->> 'c1'::text))::bigint = 2)
               Reader: Single File
               Row groups: 1
(14 rows)

--Testcase 296:
EXECUTE st1(1, 1);
  c3   |  c3   
-------+-------
 00001 | 00001
(1 row)

--Testcase 297:
EXECUTE st1(101, 101);
  c3   |  c3   
-------+-------
 00101 | 00101
(1 row)

-- subquery using stable function (can't be sent to remote)
--Testcase 298:
PREPARE st2(int) AS SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 < $2 AND (t1.v->>'c3')::int IN (SELECT (v->>'c3')::int as c3 FROM ft2 t2 WHERE (v->>'c1')::int8 > $1 AND date((v->>'c5')::timestamp) = '1970-01-17'::date) ORDER BY (v->>'c1')::int8;
--Testcase 299:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st2(10, 20);
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.v, (((t1.v ->> 'c1'::text))::bigint)
   Sort Key: (((t1.v ->> 'c1'::text))::bigint)
   ->  Hash Semi Join
         Output: t1.v, ((t1.v ->> 'c1'::text))::bigint
         Hash Cond: (((t1.v ->> 'c3'::text))::integer = ((t2.v ->> 'c3'::text))::integer)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Filter: (((t1.v ->> 'c1'::text))::bigint < '20'::bigint)
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Filter: ((((t2.v ->> 'c1'::text))::bigint > 10) AND (date(((t2.v ->> 'c5'::text))::timestamp without time zone) = '01-17-1970'::date))
                     Reader: Single File
                     Row groups: 1
(18 rows)

--Testcase 300:
EXECUTE st2(10, 20);
                                                    v                                                    
---------------------------------------------------------------------------------------------------------
 {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
(1 row)

--Testcase 301:
EXECUTE st2(101, 121);
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 116, "c2": 6, "c3": "00116", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
(1 row)

-- subquery using immutable function (can be sent to remote)
--Testcase 302:
PREPARE st3(int) AS SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 < $2 AND (t1.v->>'c3')::int IN (SELECT (v->>'c3')::int as c3 FROM ft2 t2 WHERE (v->>'c1')::int8 > $1 AND date((v->>'c5')::timestamp) = '1970-01-17'::date) ORDER BY (v->>'c1')::int8;
--Testcase 303:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st3(10, 20);
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.v, (((t1.v ->> 'c1'::text))::bigint)
   Sort Key: (((t1.v ->> 'c1'::text))::bigint)
   ->  Hash Semi Join
         Output: t1.v, ((t1.v ->> 'c1'::text))::bigint
         Hash Cond: (((t1.v ->> 'c3'::text))::integer = ((t2.v ->> 'c3'::text))::integer)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Filter: (((t1.v ->> 'c1'::text))::bigint < '20'::bigint)
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Filter: ((((t2.v ->> 'c1'::text))::bigint > 10) AND (date(((t2.v ->> 'c5'::text))::timestamp without time zone) = '01-17-1970'::date))
                     Reader: Single File
                     Row groups: 1
(18 rows)

--Testcase 304:
EXECUTE st3(10, 20);
                                                    v                                                    
---------------------------------------------------------------------------------------------------------
 {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
(1 row)

--Testcase 305:
EXECUTE st3(20, 30);
 v 
---
(0 rows)

-- custom plan should be chosen initially
--Testcase 306:
PREPARE st4(int) AS SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = $1;
--Testcase 307:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 308:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 309:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 310:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 311:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

-- once we try it enough times, should switch to generic plan
--Testcase 312:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                    QUERY PLAN                    
--------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = $1)
   Reader: Single File
   Row groups: 1
(5 rows)

-- value of $1 should not be sent to remote
--Testcase 313:
PREPARE st5(user_enum,int) AS SELECT * FROM ft1 t1 WHERE v->>'c8' = $1::text and (v->>'c1')::int8 = $2;
--Testcase 314:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 315:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 316:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 317:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 318:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 319:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ($1)::text) AND (((t1.v ->> 'c1'::text))::bigint = $2))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 320:
EXECUTE st5('foo', 1);
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- altering FDW options requires replanning
--Testcase 321:
PREPARE st6 AS SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = (t1.v->>'c2')::int;
--Testcase 322:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st6;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c2'::text))::integer)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 497:
PREPARE st7 AS INSERT INTO ft1 VALUES (json_build_object('c1', 1001, 'c2', 101, 'c3', 'foo'));
--Testcase 498:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st7;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.ft1
   ->  Result
         Output: NULL::integer, json_build_object('c1', 1001, 'c2', 101, 'c3', 'foo')
(3 rows)

-- ALTER TABLE "S 1"."T1" RENAME TO "T0";
\set var :PATH_FILENAME'/ported_postgres/T0.parquet'
--Testcase 499:
ALTER FOREIGN TABLE ft1 OPTIONS (SET filename :'var');
--Testcase 323:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st6;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c2'::text))::integer)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 324:
EXECUTE st6;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 2, "c2": 2, "c3": "00002", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 3, "c2": 3, "c3": "00003", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 4, "c2": 4, "c3": "00004", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
 {"c1": 5, "c2": 5, "c3": "00005", "c5": "Tue Jan 06 00:00:00 1970", "c6": "5", "c7": "5", "c8": "foo"}
 {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 7, "c2": 7, "c3": "00007", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 8, "c2": 8, "c3": "00008", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 9, "c2": 9, "c3": "00009", "c5": "Sat Jan 10 00:00:00 1970", "c6": "9", "c7": "9", "c8": "foo"}
(9 rows)

-- EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st7;
-- ALTER TABLE "S 1"."T0" RENAME TO "T1";
\set var :PATH_FILENAME'/ported_postgres/T1.parquet'
--Testcase 500:
ALTER FOREIGN TABLE ft1 OPTIONS (SET filename :'var');
--Testcase 325:
PREPARE st8 AS SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
--Testcase 326:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st8;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 501:
ALTER SERVER parquet_s3_srv OPTIONS (DROP extensions);
--Testcase 327:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st8;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 328:
EXECUTE st8;
 count 
-------
     9
(1 row)

--Testcase 502:
ALTER SERVER parquet_s3_srv OPTIONS (ADD extensions 'parquet_s3_fdw');
-- cleanup
DEALLOCATE st1;
DEALLOCATE st2;
DEALLOCATE st3;
DEALLOCATE st4;
DEALLOCATE st5;
DEALLOCATE st6;
-- DEALLOCATE st7;
DEALLOCATE st8;
-- System columns, except ctid and oid, should not be sent to remote
--Testcase 329:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM ft1 t1 WHERE t1.tableoid = 'pg_class'::regclass LIMIT 1;
                 QUERY PLAN                  
---------------------------------------------
 Limit
   Output: v
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (t1.tableoid = '1259'::oid)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 330:
SELECT * FROM ft1 t1 WHERE t1.tableoid = 'ft1'::regclass LIMIT 1;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

--Testcase 331:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT tableoid::regclass, * FROM ft1 t1 LIMIT 1;
               QUERY PLAN                
-----------------------------------------
 Limit
   Output: ((tableoid)::regclass), v
   ->  Foreign Scan on public.ft1 t1
         Output: (tableoid)::regclass, v
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 332:
SELECT tableoid::regclass, * FROM ft1 t1 LIMIT 1;
 tableoid |                                                   v                                                    
----------+--------------------------------------------------------------------------------------------------------
 ft1      | {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

--Testcase 333:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM ft1 t1 WHERE t1.ctid = '(0,2)';
             QUERY PLAN             
------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (t1.ctid = '(0,2)'::tid)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 334:
SELECT * FROM ft1 t1 WHERE t1.ctid = '(0,2)';
 v 
---
(0 rows)

--Testcase 335:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT ctid, * FROM ft1 t1 LIMIT 1;
             QUERY PLAN              
-------------------------------------
 Limit
   Output: ctid, v
   ->  Foreign Scan on public.ft1 t1
         Output: ctid, v
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 336:
SELECT ctid, * FROM ft1 t1 LIMIT 1;
      ctid      |                                                   v                                                    
----------------+--------------------------------------------------------------------------------------------------------
 (4294967295,0) | {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- ===================================================================
-- used in PL/pgSQL function
-- ===================================================================
--Testcase 337:
CREATE OR REPLACE FUNCTION f_test(p_c1 int) RETURNS int AS $$
DECLARE
	v_c1 int;
BEGIN
--Testcase 338:
    SELECT (v->>'c1')::int8 INTO v_c1 FROM ft1 WHERE (v->>'c1')::int8 = p_c1 LIMIT 1;
    PERFORM (v->>'c1')::int8 FROM ft1 WHERE (v->>'c1')::int8 = p_c1 AND p_c1 = v_c1 LIMIT 1;
    RETURN v_c1;
END;
$$ LANGUAGE plpgsql;
--Testcase 339:
SELECT f_test(100);
 f_test 
--------
    100
(1 row)

--Testcase 340:
DROP FUNCTION f_test(int);
-- ===================================================================
-- REINDEX
-- ===================================================================
-- remote table is not created here
-- raise error when creating foreign table with local file
-- do not raise error with minio/s3 servers but raise error when selecting table
\set var :PATH_FILENAME'/ported_postgres/reindex_local.parquet'
--Testcase 341:
CREATE FOREIGN TABLE reindex_foreign (v jsonb)
  SERVER parquet_s3_srv_2 OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1439: ERROR:  parquet_s3_fdw: No such file or directory ('/tmp/data_local/ported_postgres/reindex_local.parquet')
REINDEX TABLE reindex_foreign; -- error
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1440: ERROR:  relation "reindex_foreign" does not exist
REINDEX TABLE CONCURRENTLY reindex_foreign; -- error
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1441: ERROR:  relation "reindex_foreign" does not exist
--Testcase 342:
DROP FOREIGN TABLE reindex_foreign;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1443: ERROR:  foreign table "reindex_foreign" does not exist
-- partitions and foreign tables
-- CREATE TABLE reind_fdw_parent (c1 int) PARTITION BY RANGE ((v->>'c1')::int8);
-- CREATE TABLE reind_fdw_0_10 PARTITION OF reind_fdw_parent
--   FOR VALUES FROM (0) TO (10);
-- CREATE FOREIGN TABLE reind_fdw_10_20 PARTITION OF reind_fdw_parent
--   FOR VALUES FROM (10) TO (20)
--   SERVER loopback OPTIONS (table_name 'reind_local_10_20');
-- REINDEX TABLE reind_fdw_parent; -- ok
-- REINDEX TABLE CONCURRENTLY reind_fdw_parent; -- ok
-- DROP TABLE reind_fdw_parent;
-- ===================================================================
-- conversion error
-- ===================================================================
-- ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE int;
-- SELECT * FROM ft1 ftx(x1,x2,x3,x4,x5,x6,x7,x8) WHERE x1 = 1;  -- ERROR
-- SELECT ftx.x1, ft2.v->>'c2', ftx.x8 FROM ft1 ftx(x1,x2,x3,x4,x5,x6,x7,x8), ft2
--   WHERE ftx.x1 = ft2.v->>'c1' AND ftx.x1 = 1; -- ERROR
-- SELECT ftx.x1, ft2.v->>'c2', ftx FROM ft1 ftx(x1,x2,x3,x4,x5,x6,x7,x8), ft2
--   WHERE ftx.x1 = ft2.v->>'c1' AND ftx.x1 = 1; -- ERROR
-- SELECT sum((v->>'c2')::int), array_agg(c8) FROM ft1 GROUP BY c8; -- ERROR
-- ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE text;
-- ===================================================================
-- subtransaction
--  + local/remote error doesn't break cursor
-- ===================================================================
-- BEGIN;
-- DECLARE c CURSOR FOR SELECT * FROM ft1 ORDER BY v->>'c1';
-- FETCH c;
-- SAVEPOINT s;
-- ERROR OUT;          -- ERROR
-- ROLLBACK TO s;
-- FETCH c;
-- SAVEPOINT s;
-- SELECT * FROM ft1 WHERE 1 / (c1 - 1) > 0;  -- ERROR
-- ROLLBACK TO s;
-- FETCH c;
-- SELECT * FROM ft1 ORDER BY v->>'c1' LIMIT 1;
-- COMMIT;
-- ===================================================================
-- test handling of collations
-- schemaless foreign table does not have text column, this test is skipped
-- ===================================================================
-- \set var :PATH_FILENAME'/ported_postgres/loct3.parquet'
-- --Testcase 343:
-- create foreign table loct3 (f1 text collate "C", f2 text, f3 varchar(10))
--   server parquet_s3_srv options (filename :'var');
-- --Testcase 344:
-- create foreign table ft3 (f1 text collate "C", f2 text, f3 varchar(10))
--   server parquet_s3_srv options (filename :'var');
-- -- can be sent to remote
-- --Testcase 345:
-- explain (verbose, costs off) select * from ft3 where f1 = 'foo';
-- --Testcase 346:
-- explain (verbose, costs off) select * from ft3 where f1 COLLATE "C" = 'foo';
-- --Testcase 347:
-- explain (verbose, costs off) select * from ft3 where f2 = 'foo';
-- --Testcase 348:
-- explain (verbose, costs off) select * from ft3 where f3 = 'foo';
-- --Testcase 349:
-- explain (verbose, costs off) select * from ft3 f, loct3 l
--   where f.f3 = l.f3 and l.f1 = 'foo';
-- -- can't be sent to remote
-- --Testcase 350:
-- explain (verbose, costs off) select * from ft3 where f1 COLLATE "POSIX" = 'foo';
-- --Testcase 351:
-- explain (verbose, costs off) select * from ft3 where f1 = 'foo' COLLATE "C";
-- --Testcase 352:
-- explain (verbose, costs off) select * from ft3 where f2 COLLATE "C" = 'foo';
-- --Testcase 353:
-- explain (verbose, costs off) select * from ft3 where f2 = 'foo' COLLATE "C";
-- --Testcase 354:
-- explain (verbose, costs off) select * from ft3 f, loct3 l
--   where f.f3 = l.f3 COLLATE "POSIX" and l.f1 = 'foo';
-- ===================================================================
-- test writable foreign table stuff
-- ===================================================================
--Testcase 503:
EXPLAIN (verbose, costs off)
INSERT INTO ft2 (v) SELECT json_build_object('c1', (v->>'c1')::int8+1000, 'c2', (v->>'c2')::int8 + 100, 'c3', (v->>'c3') || (v->>'c3')) FROM ft2 LIMIT 20;
                                                                                                    QUERY PLAN                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Insert on public.ft2
   ->  Subquery Scan on "*SELECT*"
         Output: "*SELECT*".json_build_object, NULL::integer
         ->  Limit
               Output: (json_build_object('c1', (((ft2_1.v ->> 'c1'::text))::bigint + 1000), 'c2', (((ft2_1.v ->> 'c2'::text))::bigint + 100), 'c3', ((ft2_1.v ->> 'c3'::text) || (ft2_1.v ->> 'c3'::text))))
               ->  Foreign Scan on public.ft2 ft2_1
                     Output: json_build_object('c1', (((ft2_1.v ->> 'c1'::text))::bigint + 1000), 'c2', (((ft2_1.v ->> 'c2'::text))::bigint + 100), 'c3', ((ft2_1.v ->> 'c3'::text) || (ft2_1.v ->> 'c3'::text)))
                     Reader: Single File
                     Row groups: 1
(9 rows)

--Testcase 504:
INSERT INTO ft2 (v) SELECT json_build_object('c1', (v->>'c1')::int8+1000, 'c2', (v->>'c2')::int8 + 100, 'c3', (v->>'c3') || (v->>'c3')) FROM ft2 LIMIT 20;
--Testcase 505:
INSERT INTO ft2 (v)
  VALUES (json_build_object('c1', 1101, 'c2', 201, 'c3', 'aaa')), (json_build_object('c1', 1102,'c2', 202,'c3', 'bbb')), (json_build_object('c1', 1103,'c2', 203,'c3', 'ccc'));
--Testcase 506:
INSERT INTO ft2 (v) VALUES (json_build_object('c1', 1104, 'c2', 204, 'c3', 'ddd')), (json_build_object('c1', 1105, 'c2', 205, 'c3', 'eee'));
--Testcase 507:
EXPLAIN (verbose, costs off)
UPDATE ft2 SET v = json_build_object('c2', (v->>'c2')::int8 + 300, 'c3' ,v->>'c3' || '_update3') WHERE (v->>'c1')::int8 % 10 = 3;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.ft2
   ->  Foreign Scan on public.ft2
         Output: json_build_object('c2', (((v ->> 'c2'::text))::bigint + 300), 'c3', ((v ->> 'c3'::text) || '_update3'::text)), NULL::integer, v, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint % '10'::bigint) = 3)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 508:
UPDATE ft2 SET v = json_build_object('c2', (v->>'c2')::int8 + 300, 'c3' ,v->>'c3' || '_update3') WHERE (v->>'c1')::int8 % 10 = 3;
--Testcase 509:
SELECT * FROM ft2 WHERE (v->>'c1')::int8 % 10 = 3;
                                                         v                                                          
--------------------------------------------------------------------------------------------------------------------
 {"c1": 3, "c2": 303, "c3": "00003_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 13, "c2": 303, "c3": "00013_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 23, "c2": 303, "c3": "00023_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 33, "c2": 303, "c3": "00033_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 43, "c2": 303, "c3": "00043_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 53, "c2": 303, "c3": "00053_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 63, "c2": 303, "c3": "00063_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 73, "c2": 303, "c3": "00073_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 83, "c2": 303, "c3": "00083_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 93, "c2": 303, "c3": "00093_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 103, "c2": 303, "c3": "00103_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 113, "c2": 303, "c3": "00113_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 123, "c2": 303, "c3": "00123_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 133, "c2": 303, "c3": "00133_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 143, "c2": 303, "c3": "00143_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 153, "c2": 303, "c3": "00153_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 163, "c2": 303, "c3": "00163_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 173, "c2": 303, "c3": "00173_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 183, "c2": 303, "c3": "00183_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 193, "c2": 303, "c3": "00193_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 203, "c2": 303, "c3": "00203_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 213, "c2": 303, "c3": "00213_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 223, "c2": 303, "c3": "00223_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 233, "c2": 303, "c3": "00233_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 243, "c2": 303, "c3": "00243_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 253, "c2": 303, "c3": "00253_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 263, "c2": 303, "c3": "00263_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 273, "c2": 303, "c3": "00273_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 283, "c2": 303, "c3": "00283_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 293, "c2": 303, "c3": "00293_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 303, "c2": 303, "c3": "00303_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 313, "c2": 303, "c3": "00313_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 323, "c2": 303, "c3": "00323_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 333, "c2": 303, "c3": "00333_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 343, "c2": 303, "c3": "00343_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 353, "c2": 303, "c3": "00353_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 363, "c2": 303, "c3": "00363_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 373, "c2": 303, "c3": "00373_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 383, "c2": 303, "c3": "00383_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 393, "c2": 303, "c3": "00393_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 403, "c2": 303, "c3": "00403_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 413, "c2": 303, "c3": "00413_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 423, "c2": 303, "c3": "00423_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 433, "c2": 303, "c3": "00433_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 443, "c2": 303, "c3": "00443_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 453, "c2": 303, "c3": "00453_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 463, "c2": 303, "c3": "00463_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 473, "c2": 303, "c3": "00473_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 483, "c2": 303, "c3": "00483_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 493, "c2": 303, "c3": "00493_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 503, "c2": 303, "c3": "00503_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 513, "c2": 303, "c3": "00513_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 523, "c2": 303, "c3": "00523_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 533, "c2": 303, "c3": "00533_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 543, "c2": 303, "c3": "00543_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 553, "c2": 303, "c3": "00553_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 563, "c2": 303, "c3": "00563_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 573, "c2": 303, "c3": "00573_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 583, "c2": 303, "c3": "00583_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 593, "c2": 303, "c3": "00593_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 603, "c2": 303, "c3": "00603_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 613, "c2": 303, "c3": "00613_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 623, "c2": 303, "c3": "00623_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 633, "c2": 303, "c3": "00633_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 643, "c2": 303, "c3": "00643_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 653, "c2": 303, "c3": "00653_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 663, "c2": 303, "c3": "00663_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 673, "c2": 303, "c3": "00673_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 683, "c2": 303, "c3": "00683_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 693, "c2": 303, "c3": "00693_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 703, "c2": 303, "c3": "00703_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 713, "c2": 303, "c3": "00713_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 723, "c2": 303, "c3": "00723_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 733, "c2": 303, "c3": "00733_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 743, "c2": 303, "c3": "00743_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 753, "c2": 303, "c3": "00753_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 763, "c2": 303, "c3": "00763_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 773, "c2": 303, "c3": "00773_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 783, "c2": 303, "c3": "00783_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 793, "c2": 303, "c3": "00793_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 803, "c2": 303, "c3": "00803_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 813, "c2": 303, "c3": "00813_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 823, "c2": 303, "c3": "00823_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 833, "c2": 303, "c3": "00833_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 843, "c2": 303, "c3": "00843_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 853, "c2": 303, "c3": "00853_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 863, "c2": 303, "c3": "00863_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 873, "c2": 303, "c3": "00873_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 883, "c2": 303, "c3": "00883_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 893, "c2": 303, "c3": "00893_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 903, "c2": 303, "c3": "00903_update3", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 913, "c2": 303, "c3": "00913_update3", "c5": "Wed Jan 14 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 923, "c2": 303, "c3": "00923_update3", "c5": "Sat Jan 24 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 933, "c2": 303, "c3": "00933_update3", "c5": "Tue Feb 03 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 943, "c2": 303, "c3": "00943_update3", "c5": "Fri Feb 13 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 953, "c2": 303, "c3": "00953_update3", "c5": "Mon Feb 23 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 963, "c2": 303, "c3": "00963_update3", "c5": "Thu Mar 05 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 973, "c2": 303, "c3": "00973_update3", "c5": "Sun Mar 15 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 983, "c2": 303, "c3": "00983_update3", "c5": "Wed Mar 25 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 993, "c2": 303, "c3": "00993_update3", "c5": "Sat Apr 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 1003, "c2": 403, "c3": "0000300003_update3", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 1013, "c2": 403, "c3": "0001300013_update3", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 1103, "c2": 503, "c3": "ccc_update3", "c5": null, "c6": null, "c7": null, "c8": null}
(103 rows)

--Testcase 510:
EXPLAIN (verbose, costs off)
UPDATE ft2 SET v = json_build_object('c2', (v->>'c2')::int8 + 400, 'c3', v->>'c3' || '_update7') WHERE (v->>'c1')::int8 % 10 = 7;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.ft2
   ->  Foreign Scan on public.ft2
         Output: json_build_object('c2', (((v ->> 'c2'::text))::bigint + 400), 'c3', ((v ->> 'c3'::text) || '_update7'::text)), NULL::integer, v, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint % '10'::bigint) = 7)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 511:
UPDATE ft2 SET v = json_build_object('c2', (v->>'c2')::int8 + 400, 'c3', v->>'c3' || '_update7') WHERE (v->>'c1')::int8 % 10 = 7;
--Testcase 512:
SELECT * FROM ft2 WHERE (v->>'c1')::int8 % 10 = 7;
                                                         v                                                          
--------------------------------------------------------------------------------------------------------------------
 {"c1": 7, "c2": 407, "c3": "00007_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 17, "c2": 407, "c3": "00017_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 27, "c2": 407, "c3": "00027_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 37, "c2": 407, "c3": "00037_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 47, "c2": 407, "c3": "00047_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 57, "c2": 407, "c3": "00057_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 67, "c2": 407, "c3": "00067_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 77, "c2": 407, "c3": "00077_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 87, "c2": 407, "c3": "00087_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 97, "c2": 407, "c3": "00097_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 107, "c2": 407, "c3": "00107_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 117, "c2": 407, "c3": "00117_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 127, "c2": 407, "c3": "00127_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 137, "c2": 407, "c3": "00137_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 147, "c2": 407, "c3": "00147_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 157, "c2": 407, "c3": "00157_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 167, "c2": 407, "c3": "00167_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 177, "c2": 407, "c3": "00177_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 187, "c2": 407, "c3": "00187_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 197, "c2": 407, "c3": "00197_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 207, "c2": 407, "c3": "00207_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 217, "c2": 407, "c3": "00217_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 227, "c2": 407, "c3": "00227_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 237, "c2": 407, "c3": "00237_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 247, "c2": 407, "c3": "00247_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 257, "c2": 407, "c3": "00257_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 267, "c2": 407, "c3": "00267_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 277, "c2": 407, "c3": "00277_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 287, "c2": 407, "c3": "00287_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 297, "c2": 407, "c3": "00297_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 307, "c2": 407, "c3": "00307_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 317, "c2": 407, "c3": "00317_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 327, "c2": 407, "c3": "00327_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 337, "c2": 407, "c3": "00337_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 347, "c2": 407, "c3": "00347_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 357, "c2": 407, "c3": "00357_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 367, "c2": 407, "c3": "00367_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 377, "c2": 407, "c3": "00377_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 387, "c2": 407, "c3": "00387_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 397, "c2": 407, "c3": "00397_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 407, "c2": 407, "c3": "00407_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 417, "c2": 407, "c3": "00417_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 427, "c2": 407, "c3": "00427_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 437, "c2": 407, "c3": "00437_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 447, "c2": 407, "c3": "00447_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 457, "c2": 407, "c3": "00457_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 467, "c2": 407, "c3": "00467_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 477, "c2": 407, "c3": "00477_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 487, "c2": 407, "c3": "00487_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 497, "c2": 407, "c3": "00497_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 507, "c2": 407, "c3": "00507_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 517, "c2": 407, "c3": "00517_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 527, "c2": 407, "c3": "00527_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 537, "c2": 407, "c3": "00537_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 547, "c2": 407, "c3": "00547_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 557, "c2": 407, "c3": "00557_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 567, "c2": 407, "c3": "00567_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 577, "c2": 407, "c3": "00577_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 587, "c2": 407, "c3": "00587_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 597, "c2": 407, "c3": "00597_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 607, "c2": 407, "c3": "00607_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 617, "c2": 407, "c3": "00617_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 627, "c2": 407, "c3": "00627_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 637, "c2": 407, "c3": "00637_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 647, "c2": 407, "c3": "00647_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 657, "c2": 407, "c3": "00657_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 667, "c2": 407, "c3": "00667_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 677, "c2": 407, "c3": "00677_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 687, "c2": 407, "c3": "00687_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 697, "c2": 407, "c3": "00697_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 707, "c2": 407, "c3": "00707_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 717, "c2": 407, "c3": "00717_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 727, "c2": 407, "c3": "00727_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 737, "c2": 407, "c3": "00737_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 747, "c2": 407, "c3": "00747_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 757, "c2": 407, "c3": "00757_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 767, "c2": 407, "c3": "00767_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 777, "c2": 407, "c3": "00777_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 787, "c2": 407, "c3": "00787_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 797, "c2": 407, "c3": "00797_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 807, "c2": 407, "c3": "00807_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 817, "c2": 407, "c3": "00817_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 827, "c2": 407, "c3": "00827_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 837, "c2": 407, "c3": "00837_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 847, "c2": 407, "c3": "00847_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 857, "c2": 407, "c3": "00857_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 867, "c2": 407, "c3": "00867_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 877, "c2": 407, "c3": "00877_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 887, "c2": 407, "c3": "00887_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 897, "c2": 407, "c3": "00897_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 907, "c2": 407, "c3": "00907_update7", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 917, "c2": 407, "c3": "00917_update7", "c5": "Sun Jan 18 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 927, "c2": 407, "c3": "00927_update7", "c5": "Wed Jan 28 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 937, "c2": 407, "c3": "00937_update7", "c5": "Sat Feb 07 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 947, "c2": 407, "c3": "00947_update7", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 957, "c2": 407, "c3": "00957_update7", "c5": "Fri Feb 27 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 967, "c2": 407, "c3": "00967_update7", "c5": "Mon Mar 09 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 977, "c2": 407, "c3": "00977_update7", "c5": "Thu Mar 19 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 987, "c2": 407, "c3": "00987_update7", "c5": "Sun Mar 29 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 997, "c2": 407, "c3": "00997_update7", "c5": "Wed Apr 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 1007, "c2": 507, "c3": "0000700007_update7", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 1017, "c2": 507, "c3": "0001700017_update7", "c5": null, "c6": null, "c7": null, "c8": null}
(102 rows)

--Testcase 513:
EXPLAIN (verbose, costs off)
UPDATE ft2 SET v = json_build_object('c2', (ft2.v->>'c2')::int8 + 500, 'c3', ft2.v->>'c3' || '_update9', 'c7', 'ft2')
  FROM ft1 WHERE (ft1.v->>'c1')::int8 = (ft2.v->>'c2')::int8 AND (ft1.v->>'c1')::int8 % 10 = 9;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.ft2
   ->  Hash Join
         Output: json_build_object('c2', (((ft2.v ->> 'c2'::text))::bigint + 500), 'c3', ((ft2.v ->> 'c3'::text) || '_update9'::text), 'c7', 'ft2'), NULL::integer, ft2.v, ft2.v, ft1.*
         Hash Cond: (((ft2.v ->> 'c2'::text))::bigint = ((ft1.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft2
               Output: ft2.v
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: ft1.*, ft1.v
               ->  Foreign Scan on public.ft1
                     Output: ft1.*, ft1.v
                     Filter: ((((ft1.v ->> 'c1'::text))::bigint % '10'::bigint) = 9)
                     Reader: Single File
                     Row groups: 1
(15 rows)

--Testcase 514:
UPDATE ft2 SET v = json_build_object('c2', (ft2.v->>'c2')::int8 + 500, 'c3', ft2.v->>'c3' || '_update9', 'c7', 'ft2')
  FROM ft1 WHERE (ft1.v->>'c1')::int8 = (ft2.v->>'c2')::int8 AND (ft1.v->>'c1')::int8 % 10 = 9;
--Testcase 515:
EXPLAIN (verbose, costs off)
  DELETE FROM ft2 WHERE (v->>'c1')::int8 % 10 = 5;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Delete on public.ft2
   ->  Foreign Scan on public.ft2
         Output: v, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint % '10'::bigint) = 5)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 516:
DELETE FROM ft2 WHERE (v->>'c1')::int8 % 10 = 5;
--Testcase 517:
EXPLAIN (verbose, costs off)
DELETE FROM ft2 USING ft1 WHERE (ft1.v->>'c1')::int8 = (ft2.v->>'c2')::int8 AND (ft1.v->>'c1')::int8 % 10 = 2;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Delete on public.ft2
   ->  Hash Join
         Output: ft2.v, ft2.v, ft1.*
         Hash Cond: (((ft2.v ->> 'c2'::text))::bigint = ((ft1.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft2
               Output: ft2.v
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: ft1.*, ft1.v
               ->  Foreign Scan on public.ft1
                     Output: ft1.*, ft1.v
                     Filter: ((((ft1.v ->> 'c1'::text))::bigint % '10'::bigint) = 2)
                     Reader: Single File
                     Row groups: 1
(15 rows)

--Testcase 518:
DELETE FROM ft2 USING ft1 WHERE (ft1.v->>'c1')::int8 = (ft2.v->>'c2')::int8 AND (ft1.v->>'c1')::int8 % 10 = 2;
--Testcase 519:
SELECT (v->>'c1')::int8 AS c1,(v->>'c2')::int AS c2,v->>'c3' AS c3,v->>'c5' AS c5 FROM ft2 ORDER BY (v->>'c1')::int8;
  c1  | c2  |         c3         |            c5            
------+-----+--------------------+--------------------------
    1 |   1 | 00001              | Fri Jan 02 00:00:00 1970
    3 | 303 | 00003_update3      | Sun Jan 04 00:00:00 1970
    4 |   4 | 00004              | Mon Jan 05 00:00:00 1970
    6 |   6 | 00006              | Wed Jan 07 00:00:00 1970
    7 | 407 | 00007_update7      | Thu Jan 08 00:00:00 1970
    8 |   8 | 00008              | Fri Jan 09 00:00:00 1970
    9 | 509 | 00009_update9      | Sat Jan 10 00:00:00 1970
   10 |   0 | 00010              | Sun Jan 11 00:00:00 1970
   11 |   1 | 00011              | Mon Jan 12 00:00:00 1970
   13 | 303 | 00013_update3      | Wed Jan 14 00:00:00 1970
   14 |   4 | 00014              | Thu Jan 15 00:00:00 1970
   16 |   6 | 00016              | Sat Jan 17 00:00:00 1970
   17 | 407 | 00017_update7      | Sun Jan 18 00:00:00 1970
   18 |   8 | 00018              | Mon Jan 19 00:00:00 1970
   19 | 509 | 00019_update9      | Tue Jan 20 00:00:00 1970
   20 |   0 | 00020              | Wed Jan 21 00:00:00 1970
   21 |   1 | 00021              | Thu Jan 22 00:00:00 1970
   23 | 303 | 00023_update3      | Sat Jan 24 00:00:00 1970
   24 |   4 | 00024              | Sun Jan 25 00:00:00 1970
   26 |   6 | 00026              | Tue Jan 27 00:00:00 1970
   27 | 407 | 00027_update7      | Wed Jan 28 00:00:00 1970
   28 |   8 | 00028              | Thu Jan 29 00:00:00 1970
   29 | 509 | 00029_update9      | Fri Jan 30 00:00:00 1970
   30 |   0 | 00030              | Sat Jan 31 00:00:00 1970
   31 |   1 | 00031              | Sun Feb 01 00:00:00 1970
   33 | 303 | 00033_update3      | Tue Feb 03 00:00:00 1970
   34 |   4 | 00034              | Wed Feb 04 00:00:00 1970
   36 |   6 | 00036              | Fri Feb 06 00:00:00 1970
   37 | 407 | 00037_update7      | Sat Feb 07 00:00:00 1970
   38 |   8 | 00038              | Sun Feb 08 00:00:00 1970
   39 | 509 | 00039_update9      | Mon Feb 09 00:00:00 1970
   40 |   0 | 00040              | Tue Feb 10 00:00:00 1970
   41 |   1 | 00041              | Wed Feb 11 00:00:00 1970
   43 | 303 | 00043_update3      | Fri Feb 13 00:00:00 1970
   44 |   4 | 00044              | Sat Feb 14 00:00:00 1970
   46 |   6 | 00046              | Mon Feb 16 00:00:00 1970
   47 | 407 | 00047_update7      | Tue Feb 17 00:00:00 1970
   48 |   8 | 00048              | Wed Feb 18 00:00:00 1970
   49 | 509 | 00049_update9      | Thu Feb 19 00:00:00 1970
   50 |   0 | 00050              | Fri Feb 20 00:00:00 1970
   51 |   1 | 00051              | Sat Feb 21 00:00:00 1970
   53 | 303 | 00053_update3      | Mon Feb 23 00:00:00 1970
   54 |   4 | 00054              | Tue Feb 24 00:00:00 1970
   56 |   6 | 00056              | Thu Feb 26 00:00:00 1970
   57 | 407 | 00057_update7      | Fri Feb 27 00:00:00 1970
   58 |   8 | 00058              | Sat Feb 28 00:00:00 1970
   59 | 509 | 00059_update9      | Sun Mar 01 00:00:00 1970
   60 |   0 | 00060              | Mon Mar 02 00:00:00 1970
   61 |   1 | 00061              | Tue Mar 03 00:00:00 1970
   63 | 303 | 00063_update3      | Thu Mar 05 00:00:00 1970
   64 |   4 | 00064              | Fri Mar 06 00:00:00 1970
   66 |   6 | 00066              | Sun Mar 08 00:00:00 1970
   67 | 407 | 00067_update7      | Mon Mar 09 00:00:00 1970
   68 |   8 | 00068              | Tue Mar 10 00:00:00 1970
   69 | 509 | 00069_update9      | Wed Mar 11 00:00:00 1970
   70 |   0 | 00070              | Thu Mar 12 00:00:00 1970
   71 |   1 | 00071              | Fri Mar 13 00:00:00 1970
   73 | 303 | 00073_update3      | Sun Mar 15 00:00:00 1970
   74 |   4 | 00074              | Mon Mar 16 00:00:00 1970
   76 |   6 | 00076              | Wed Mar 18 00:00:00 1970
   77 | 407 | 00077_update7      | Thu Mar 19 00:00:00 1970
   78 |   8 | 00078              | Fri Mar 20 00:00:00 1970
   79 | 509 | 00079_update9      | Sat Mar 21 00:00:00 1970
   80 |   0 | 00080              | Sun Mar 22 00:00:00 1970
   81 |   1 | 00081              | Mon Mar 23 00:00:00 1970
   83 | 303 | 00083_update3      | Wed Mar 25 00:00:00 1970
   84 |   4 | 00084              | Thu Mar 26 00:00:00 1970
   86 |   6 | 00086              | Sat Mar 28 00:00:00 1970
   87 | 407 | 00087_update7      | Sun Mar 29 00:00:00 1970
   88 |   8 | 00088              | Mon Mar 30 00:00:00 1970
   89 | 509 | 00089_update9      | Tue Mar 31 00:00:00 1970
   90 |   0 | 00090              | Wed Apr 01 00:00:00 1970
   91 |   1 | 00091              | Thu Apr 02 00:00:00 1970
   93 | 303 | 00093_update3      | Sat Apr 04 00:00:00 1970
   94 |   4 | 00094              | Sun Apr 05 00:00:00 1970
   96 |   6 | 00096              | Tue Apr 07 00:00:00 1970
   97 | 407 | 00097_update7      | Wed Apr 08 00:00:00 1970
   98 |   8 | 00098              | Thu Apr 09 00:00:00 1970
   99 | 509 | 00099_update9      | Fri Apr 10 00:00:00 1970
  100 |   0 | 00100              | Thu Jan 01 00:00:00 1970
  101 |   1 | 00101              | Fri Jan 02 00:00:00 1970
  103 | 303 | 00103_update3      | Sun Jan 04 00:00:00 1970
  104 |   4 | 00104              | Mon Jan 05 00:00:00 1970
  106 |   6 | 00106              | Wed Jan 07 00:00:00 1970
  107 | 407 | 00107_update7      | Thu Jan 08 00:00:00 1970
  108 |   8 | 00108              | Fri Jan 09 00:00:00 1970
  109 | 509 | 00109_update9      | Sat Jan 10 00:00:00 1970
  110 |   0 | 00110              | Sun Jan 11 00:00:00 1970
  111 |   1 | 00111              | Mon Jan 12 00:00:00 1970
  113 | 303 | 00113_update3      | Wed Jan 14 00:00:00 1970
  114 |   4 | 00114              | Thu Jan 15 00:00:00 1970
  116 |   6 | 00116              | Sat Jan 17 00:00:00 1970
  117 | 407 | 00117_update7      | Sun Jan 18 00:00:00 1970
  118 |   8 | 00118              | Mon Jan 19 00:00:00 1970
  119 | 509 | 00119_update9      | Tue Jan 20 00:00:00 1970
  120 |   0 | 00120              | Wed Jan 21 00:00:00 1970
  121 |   1 | 00121              | Thu Jan 22 00:00:00 1970
  123 | 303 | 00123_update3      | Sat Jan 24 00:00:00 1970
  124 |   4 | 00124              | Sun Jan 25 00:00:00 1970
  126 |   6 | 00126              | Tue Jan 27 00:00:00 1970
  127 | 407 | 00127_update7      | Wed Jan 28 00:00:00 1970
  128 |   8 | 00128              | Thu Jan 29 00:00:00 1970
  129 | 509 | 00129_update9      | Fri Jan 30 00:00:00 1970
  130 |   0 | 00130              | Sat Jan 31 00:00:00 1970
  131 |   1 | 00131              | Sun Feb 01 00:00:00 1970
  133 | 303 | 00133_update3      | Tue Feb 03 00:00:00 1970
  134 |   4 | 00134              | Wed Feb 04 00:00:00 1970
  136 |   6 | 00136              | Fri Feb 06 00:00:00 1970
  137 | 407 | 00137_update7      | Sat Feb 07 00:00:00 1970
  138 |   8 | 00138              | Sun Feb 08 00:00:00 1970
  139 | 509 | 00139_update9      | Mon Feb 09 00:00:00 1970
  140 |   0 | 00140              | Tue Feb 10 00:00:00 1970
  141 |   1 | 00141              | Wed Feb 11 00:00:00 1970
  143 | 303 | 00143_update3      | Fri Feb 13 00:00:00 1970
  144 |   4 | 00144              | Sat Feb 14 00:00:00 1970
  146 |   6 | 00146              | Mon Feb 16 00:00:00 1970
  147 | 407 | 00147_update7      | Tue Feb 17 00:00:00 1970
  148 |   8 | 00148              | Wed Feb 18 00:00:00 1970
  149 | 509 | 00149_update9      | Thu Feb 19 00:00:00 1970
  150 |   0 | 00150              | Fri Feb 20 00:00:00 1970
  151 |   1 | 00151              | Sat Feb 21 00:00:00 1970
  153 | 303 | 00153_update3      | Mon Feb 23 00:00:00 1970
  154 |   4 | 00154              | Tue Feb 24 00:00:00 1970
  156 |   6 | 00156              | Thu Feb 26 00:00:00 1970
  157 | 407 | 00157_update7      | Fri Feb 27 00:00:00 1970
  158 |   8 | 00158              | Sat Feb 28 00:00:00 1970
  159 | 509 | 00159_update9      | Sun Mar 01 00:00:00 1970
  160 |   0 | 00160              | Mon Mar 02 00:00:00 1970
  161 |   1 | 00161              | Tue Mar 03 00:00:00 1970
  163 | 303 | 00163_update3      | Thu Mar 05 00:00:00 1970
  164 |   4 | 00164              | Fri Mar 06 00:00:00 1970
  166 |   6 | 00166              | Sun Mar 08 00:00:00 1970
  167 | 407 | 00167_update7      | Mon Mar 09 00:00:00 1970
  168 |   8 | 00168              | Tue Mar 10 00:00:00 1970
  169 | 509 | 00169_update9      | Wed Mar 11 00:00:00 1970
  170 |   0 | 00170              | Thu Mar 12 00:00:00 1970
  171 |   1 | 00171              | Fri Mar 13 00:00:00 1970
  173 | 303 | 00173_update3      | Sun Mar 15 00:00:00 1970
  174 |   4 | 00174              | Mon Mar 16 00:00:00 1970
  176 |   6 | 00176              | Wed Mar 18 00:00:00 1970
  177 | 407 | 00177_update7      | Thu Mar 19 00:00:00 1970
  178 |   8 | 00178              | Fri Mar 20 00:00:00 1970
  179 | 509 | 00179_update9      | Sat Mar 21 00:00:00 1970
  180 |   0 | 00180              | Sun Mar 22 00:00:00 1970
  181 |   1 | 00181              | Mon Mar 23 00:00:00 1970
  183 | 303 | 00183_update3      | Wed Mar 25 00:00:00 1970
  184 |   4 | 00184              | Thu Mar 26 00:00:00 1970
  186 |   6 | 00186              | Sat Mar 28 00:00:00 1970
  187 | 407 | 00187_update7      | Sun Mar 29 00:00:00 1970
  188 |   8 | 00188              | Mon Mar 30 00:00:00 1970
  189 | 509 | 00189_update9      | Tue Mar 31 00:00:00 1970
  190 |   0 | 00190              | Wed Apr 01 00:00:00 1970
  191 |   1 | 00191              | Thu Apr 02 00:00:00 1970
  193 | 303 | 00193_update3      | Sat Apr 04 00:00:00 1970
  194 |   4 | 00194              | Sun Apr 05 00:00:00 1970
  196 |   6 | 00196              | Tue Apr 07 00:00:00 1970
  197 | 407 | 00197_update7      | Wed Apr 08 00:00:00 1970
  198 |   8 | 00198              | Thu Apr 09 00:00:00 1970
  199 | 509 | 00199_update9      | Fri Apr 10 00:00:00 1970
  200 |   0 | 00200              | Thu Jan 01 00:00:00 1970
  201 |   1 | 00201              | Fri Jan 02 00:00:00 1970
  203 | 303 | 00203_update3      | Sun Jan 04 00:00:00 1970
  204 |   4 | 00204              | Mon Jan 05 00:00:00 1970
  206 |   6 | 00206              | Wed Jan 07 00:00:00 1970
  207 | 407 | 00207_update7      | Thu Jan 08 00:00:00 1970
  208 |   8 | 00208              | Fri Jan 09 00:00:00 1970
  209 | 509 | 00209_update9      | Sat Jan 10 00:00:00 1970
  210 |   0 | 00210              | Sun Jan 11 00:00:00 1970
  211 |   1 | 00211              | Mon Jan 12 00:00:00 1970
  213 | 303 | 00213_update3      | Wed Jan 14 00:00:00 1970
  214 |   4 | 00214              | Thu Jan 15 00:00:00 1970
  216 |   6 | 00216              | Sat Jan 17 00:00:00 1970
  217 | 407 | 00217_update7      | Sun Jan 18 00:00:00 1970
  218 |   8 | 00218              | Mon Jan 19 00:00:00 1970
  219 | 509 | 00219_update9      | Tue Jan 20 00:00:00 1970
  220 |   0 | 00220              | Wed Jan 21 00:00:00 1970
  221 |   1 | 00221              | Thu Jan 22 00:00:00 1970
  223 | 303 | 00223_update3      | Sat Jan 24 00:00:00 1970
  224 |   4 | 00224              | Sun Jan 25 00:00:00 1970
  226 |   6 | 00226              | Tue Jan 27 00:00:00 1970
  227 | 407 | 00227_update7      | Wed Jan 28 00:00:00 1970
  228 |   8 | 00228              | Thu Jan 29 00:00:00 1970
  229 | 509 | 00229_update9      | Fri Jan 30 00:00:00 1970
  230 |   0 | 00230              | Sat Jan 31 00:00:00 1970
  231 |   1 | 00231              | Sun Feb 01 00:00:00 1970
  233 | 303 | 00233_update3      | Tue Feb 03 00:00:00 1970
  234 |   4 | 00234              | Wed Feb 04 00:00:00 1970
  236 |   6 | 00236              | Fri Feb 06 00:00:00 1970
  237 | 407 | 00237_update7      | Sat Feb 07 00:00:00 1970
  238 |   8 | 00238              | Sun Feb 08 00:00:00 1970
  239 | 509 | 00239_update9      | Mon Feb 09 00:00:00 1970
  240 |   0 | 00240              | Tue Feb 10 00:00:00 1970
  241 |   1 | 00241              | Wed Feb 11 00:00:00 1970
  243 | 303 | 00243_update3      | Fri Feb 13 00:00:00 1970
  244 |   4 | 00244              | Sat Feb 14 00:00:00 1970
  246 |   6 | 00246              | Mon Feb 16 00:00:00 1970
  247 | 407 | 00247_update7      | Tue Feb 17 00:00:00 1970
  248 |   8 | 00248              | Wed Feb 18 00:00:00 1970
  249 | 509 | 00249_update9      | Thu Feb 19 00:00:00 1970
  250 |   0 | 00250              | Fri Feb 20 00:00:00 1970
  251 |   1 | 00251              | Sat Feb 21 00:00:00 1970
  253 | 303 | 00253_update3      | Mon Feb 23 00:00:00 1970
  254 |   4 | 00254              | Tue Feb 24 00:00:00 1970
  256 |   6 | 00256              | Thu Feb 26 00:00:00 1970
  257 | 407 | 00257_update7      | Fri Feb 27 00:00:00 1970
  258 |   8 | 00258              | Sat Feb 28 00:00:00 1970
  259 | 509 | 00259_update9      | Sun Mar 01 00:00:00 1970
  260 |   0 | 00260              | Mon Mar 02 00:00:00 1970
  261 |   1 | 00261              | Tue Mar 03 00:00:00 1970
  263 | 303 | 00263_update3      | Thu Mar 05 00:00:00 1970
  264 |   4 | 00264              | Fri Mar 06 00:00:00 1970
  266 |   6 | 00266              | Sun Mar 08 00:00:00 1970
  267 | 407 | 00267_update7      | Mon Mar 09 00:00:00 1970
  268 |   8 | 00268              | Tue Mar 10 00:00:00 1970
  269 | 509 | 00269_update9      | Wed Mar 11 00:00:00 1970
  270 |   0 | 00270              | Thu Mar 12 00:00:00 1970
  271 |   1 | 00271              | Fri Mar 13 00:00:00 1970
  273 | 303 | 00273_update3      | Sun Mar 15 00:00:00 1970
  274 |   4 | 00274              | Mon Mar 16 00:00:00 1970
  276 |   6 | 00276              | Wed Mar 18 00:00:00 1970
  277 | 407 | 00277_update7      | Thu Mar 19 00:00:00 1970
  278 |   8 | 00278              | Fri Mar 20 00:00:00 1970
  279 | 509 | 00279_update9      | Sat Mar 21 00:00:00 1970
  280 |   0 | 00280              | Sun Mar 22 00:00:00 1970
  281 |   1 | 00281              | Mon Mar 23 00:00:00 1970
  283 | 303 | 00283_update3      | Wed Mar 25 00:00:00 1970
  284 |   4 | 00284              | Thu Mar 26 00:00:00 1970
  286 |   6 | 00286              | Sat Mar 28 00:00:00 1970
  287 | 407 | 00287_update7      | Sun Mar 29 00:00:00 1970
  288 |   8 | 00288              | Mon Mar 30 00:00:00 1970
  289 | 509 | 00289_update9      | Tue Mar 31 00:00:00 1970
  290 |   0 | 00290              | Wed Apr 01 00:00:00 1970
  291 |   1 | 00291              | Thu Apr 02 00:00:00 1970
  293 | 303 | 00293_update3      | Sat Apr 04 00:00:00 1970
  294 |   4 | 00294              | Sun Apr 05 00:00:00 1970
  296 |   6 | 00296              | Tue Apr 07 00:00:00 1970
  297 | 407 | 00297_update7      | Wed Apr 08 00:00:00 1970
  298 |   8 | 00298              | Thu Apr 09 00:00:00 1970
  299 | 509 | 00299_update9      | Fri Apr 10 00:00:00 1970
  300 |   0 | 00300              | Thu Jan 01 00:00:00 1970
  301 |   1 | 00301              | Fri Jan 02 00:00:00 1970
  303 | 303 | 00303_update3      | Sun Jan 04 00:00:00 1970
  304 |   4 | 00304              | Mon Jan 05 00:00:00 1970
  306 |   6 | 00306              | Wed Jan 07 00:00:00 1970
  307 | 407 | 00307_update7      | Thu Jan 08 00:00:00 1970
  308 |   8 | 00308              | Fri Jan 09 00:00:00 1970
  309 | 509 | 00309_update9      | Sat Jan 10 00:00:00 1970
  310 |   0 | 00310              | Sun Jan 11 00:00:00 1970
  311 |   1 | 00311              | Mon Jan 12 00:00:00 1970
  313 | 303 | 00313_update3      | Wed Jan 14 00:00:00 1970
  314 |   4 | 00314              | Thu Jan 15 00:00:00 1970
  316 |   6 | 00316              | Sat Jan 17 00:00:00 1970
  317 | 407 | 00317_update7      | Sun Jan 18 00:00:00 1970
  318 |   8 | 00318              | Mon Jan 19 00:00:00 1970
  319 | 509 | 00319_update9      | Tue Jan 20 00:00:00 1970
  320 |   0 | 00320              | Wed Jan 21 00:00:00 1970
  321 |   1 | 00321              | Thu Jan 22 00:00:00 1970
  323 | 303 | 00323_update3      | Sat Jan 24 00:00:00 1970
  324 |   4 | 00324              | Sun Jan 25 00:00:00 1970
  326 |   6 | 00326              | Tue Jan 27 00:00:00 1970
  327 | 407 | 00327_update7      | Wed Jan 28 00:00:00 1970
  328 |   8 | 00328              | Thu Jan 29 00:00:00 1970
  329 | 509 | 00329_update9      | Fri Jan 30 00:00:00 1970
  330 |   0 | 00330              | Sat Jan 31 00:00:00 1970
  331 |   1 | 00331              | Sun Feb 01 00:00:00 1970
  333 | 303 | 00333_update3      | Tue Feb 03 00:00:00 1970
  334 |   4 | 00334              | Wed Feb 04 00:00:00 1970
  336 |   6 | 00336              | Fri Feb 06 00:00:00 1970
  337 | 407 | 00337_update7      | Sat Feb 07 00:00:00 1970
  338 |   8 | 00338              | Sun Feb 08 00:00:00 1970
  339 | 509 | 00339_update9      | Mon Feb 09 00:00:00 1970
  340 |   0 | 00340              | Tue Feb 10 00:00:00 1970
  341 |   1 | 00341              | Wed Feb 11 00:00:00 1970
  343 | 303 | 00343_update3      | Fri Feb 13 00:00:00 1970
  344 |   4 | 00344              | Sat Feb 14 00:00:00 1970
  346 |   6 | 00346              | Mon Feb 16 00:00:00 1970
  347 | 407 | 00347_update7      | Tue Feb 17 00:00:00 1970
  348 |   8 | 00348              | Wed Feb 18 00:00:00 1970
  349 | 509 | 00349_update9      | Thu Feb 19 00:00:00 1970
  350 |   0 | 00350              | Fri Feb 20 00:00:00 1970
  351 |   1 | 00351              | Sat Feb 21 00:00:00 1970
  353 | 303 | 00353_update3      | Mon Feb 23 00:00:00 1970
  354 |   4 | 00354              | Tue Feb 24 00:00:00 1970
  356 |   6 | 00356              | Thu Feb 26 00:00:00 1970
  357 | 407 | 00357_update7      | Fri Feb 27 00:00:00 1970
  358 |   8 | 00358              | Sat Feb 28 00:00:00 1970
  359 | 509 | 00359_update9      | Sun Mar 01 00:00:00 1970
  360 |   0 | 00360              | Mon Mar 02 00:00:00 1970
  361 |   1 | 00361              | Tue Mar 03 00:00:00 1970
  363 | 303 | 00363_update3      | Thu Mar 05 00:00:00 1970
  364 |   4 | 00364              | Fri Mar 06 00:00:00 1970
  366 |   6 | 00366              | Sun Mar 08 00:00:00 1970
  367 | 407 | 00367_update7      | Mon Mar 09 00:00:00 1970
  368 |   8 | 00368              | Tue Mar 10 00:00:00 1970
  369 | 509 | 00369_update9      | Wed Mar 11 00:00:00 1970
  370 |   0 | 00370              | Thu Mar 12 00:00:00 1970
  371 |   1 | 00371              | Fri Mar 13 00:00:00 1970
  373 | 303 | 00373_update3      | Sun Mar 15 00:00:00 1970
  374 |   4 | 00374              | Mon Mar 16 00:00:00 1970
  376 |   6 | 00376              | Wed Mar 18 00:00:00 1970
  377 | 407 | 00377_update7      | Thu Mar 19 00:00:00 1970
  378 |   8 | 00378              | Fri Mar 20 00:00:00 1970
  379 | 509 | 00379_update9      | Sat Mar 21 00:00:00 1970
  380 |   0 | 00380              | Sun Mar 22 00:00:00 1970
  381 |   1 | 00381              | Mon Mar 23 00:00:00 1970
  383 | 303 | 00383_update3      | Wed Mar 25 00:00:00 1970
  384 |   4 | 00384              | Thu Mar 26 00:00:00 1970
  386 |   6 | 00386              | Sat Mar 28 00:00:00 1970
  387 | 407 | 00387_update7      | Sun Mar 29 00:00:00 1970
  388 |   8 | 00388              | Mon Mar 30 00:00:00 1970
  389 | 509 | 00389_update9      | Tue Mar 31 00:00:00 1970
  390 |   0 | 00390              | Wed Apr 01 00:00:00 1970
  391 |   1 | 00391              | Thu Apr 02 00:00:00 1970
  393 | 303 | 00393_update3      | Sat Apr 04 00:00:00 1970
  394 |   4 | 00394              | Sun Apr 05 00:00:00 1970
  396 |   6 | 00396              | Tue Apr 07 00:00:00 1970
  397 | 407 | 00397_update7      | Wed Apr 08 00:00:00 1970
  398 |   8 | 00398              | Thu Apr 09 00:00:00 1970
  399 | 509 | 00399_update9      | Fri Apr 10 00:00:00 1970
  400 |   0 | 00400              | Thu Jan 01 00:00:00 1970
  401 |   1 | 00401              | Fri Jan 02 00:00:00 1970
  403 | 303 | 00403_update3      | Sun Jan 04 00:00:00 1970
  404 |   4 | 00404              | Mon Jan 05 00:00:00 1970
  406 |   6 | 00406              | Wed Jan 07 00:00:00 1970
  407 | 407 | 00407_update7      | Thu Jan 08 00:00:00 1970
  408 |   8 | 00408              | Fri Jan 09 00:00:00 1970
  409 | 509 | 00409_update9      | Sat Jan 10 00:00:00 1970
  410 |   0 | 00410              | Sun Jan 11 00:00:00 1970
  411 |   1 | 00411              | Mon Jan 12 00:00:00 1970
  413 | 303 | 00413_update3      | Wed Jan 14 00:00:00 1970
  414 |   4 | 00414              | Thu Jan 15 00:00:00 1970
  416 |   6 | 00416              | Sat Jan 17 00:00:00 1970
  417 | 407 | 00417_update7      | Sun Jan 18 00:00:00 1970
  418 |   8 | 00418              | Mon Jan 19 00:00:00 1970
  419 | 509 | 00419_update9      | Tue Jan 20 00:00:00 1970
  420 |   0 | 00420              | Wed Jan 21 00:00:00 1970
  421 |   1 | 00421              | Thu Jan 22 00:00:00 1970
  423 | 303 | 00423_update3      | Sat Jan 24 00:00:00 1970
  424 |   4 | 00424              | Sun Jan 25 00:00:00 1970
  426 |   6 | 00426              | Tue Jan 27 00:00:00 1970
  427 | 407 | 00427_update7      | Wed Jan 28 00:00:00 1970
  428 |   8 | 00428              | Thu Jan 29 00:00:00 1970
  429 | 509 | 00429_update9      | Fri Jan 30 00:00:00 1970
  430 |   0 | 00430              | Sat Jan 31 00:00:00 1970
  431 |   1 | 00431              | Sun Feb 01 00:00:00 1970
  433 | 303 | 00433_update3      | Tue Feb 03 00:00:00 1970
  434 |   4 | 00434              | Wed Feb 04 00:00:00 1970
  436 |   6 | 00436              | Fri Feb 06 00:00:00 1970
  437 | 407 | 00437_update7      | Sat Feb 07 00:00:00 1970
  438 |   8 | 00438              | Sun Feb 08 00:00:00 1970
  439 | 509 | 00439_update9      | Mon Feb 09 00:00:00 1970
  440 |   0 | 00440              | Tue Feb 10 00:00:00 1970
  441 |   1 | 00441              | Wed Feb 11 00:00:00 1970
  443 | 303 | 00443_update3      | Fri Feb 13 00:00:00 1970
  444 |   4 | 00444              | Sat Feb 14 00:00:00 1970
  446 |   6 | 00446              | Mon Feb 16 00:00:00 1970
  447 | 407 | 00447_update7      | Tue Feb 17 00:00:00 1970
  448 |   8 | 00448              | Wed Feb 18 00:00:00 1970
  449 | 509 | 00449_update9      | Thu Feb 19 00:00:00 1970
  450 |   0 | 00450              | Fri Feb 20 00:00:00 1970
  451 |   1 | 00451              | Sat Feb 21 00:00:00 1970
  453 | 303 | 00453_update3      | Mon Feb 23 00:00:00 1970
  454 |   4 | 00454              | Tue Feb 24 00:00:00 1970
  456 |   6 | 00456              | Thu Feb 26 00:00:00 1970
  457 | 407 | 00457_update7      | Fri Feb 27 00:00:00 1970
  458 |   8 | 00458              | Sat Feb 28 00:00:00 1970
  459 | 509 | 00459_update9      | Sun Mar 01 00:00:00 1970
  460 |   0 | 00460              | Mon Mar 02 00:00:00 1970
  461 |   1 | 00461              | Tue Mar 03 00:00:00 1970
  463 | 303 | 00463_update3      | Thu Mar 05 00:00:00 1970
  464 |   4 | 00464              | Fri Mar 06 00:00:00 1970
  466 |   6 | 00466              | Sun Mar 08 00:00:00 1970
  467 | 407 | 00467_update7      | Mon Mar 09 00:00:00 1970
  468 |   8 | 00468              | Tue Mar 10 00:00:00 1970
  469 | 509 | 00469_update9      | Wed Mar 11 00:00:00 1970
  470 |   0 | 00470              | Thu Mar 12 00:00:00 1970
  471 |   1 | 00471              | Fri Mar 13 00:00:00 1970
  473 | 303 | 00473_update3      | Sun Mar 15 00:00:00 1970
  474 |   4 | 00474              | Mon Mar 16 00:00:00 1970
  476 |   6 | 00476              | Wed Mar 18 00:00:00 1970
  477 | 407 | 00477_update7      | Thu Mar 19 00:00:00 1970
  478 |   8 | 00478              | Fri Mar 20 00:00:00 1970
  479 | 509 | 00479_update9      | Sat Mar 21 00:00:00 1970
  480 |   0 | 00480              | Sun Mar 22 00:00:00 1970
  481 |   1 | 00481              | Mon Mar 23 00:00:00 1970
  483 | 303 | 00483_update3      | Wed Mar 25 00:00:00 1970
  484 |   4 | 00484              | Thu Mar 26 00:00:00 1970
  486 |   6 | 00486              | Sat Mar 28 00:00:00 1970
  487 | 407 | 00487_update7      | Sun Mar 29 00:00:00 1970
  488 |   8 | 00488              | Mon Mar 30 00:00:00 1970
  489 | 509 | 00489_update9      | Tue Mar 31 00:00:00 1970
  490 |   0 | 00490              | Wed Apr 01 00:00:00 1970
  491 |   1 | 00491              | Thu Apr 02 00:00:00 1970
  493 | 303 | 00493_update3      | Sat Apr 04 00:00:00 1970
  494 |   4 | 00494              | Sun Apr 05 00:00:00 1970
  496 |   6 | 00496              | Tue Apr 07 00:00:00 1970
  497 | 407 | 00497_update7      | Wed Apr 08 00:00:00 1970
  498 |   8 | 00498              | Thu Apr 09 00:00:00 1970
  499 | 509 | 00499_update9      | Fri Apr 10 00:00:00 1970
  500 |   0 | 00500              | Thu Jan 01 00:00:00 1970
  501 |   1 | 00501              | Fri Jan 02 00:00:00 1970
  503 | 303 | 00503_update3      | Sun Jan 04 00:00:00 1970
  504 |   4 | 00504              | Mon Jan 05 00:00:00 1970
  506 |   6 | 00506              | Wed Jan 07 00:00:00 1970
  507 | 407 | 00507_update7      | Thu Jan 08 00:00:00 1970
  508 |   8 | 00508              | Fri Jan 09 00:00:00 1970
  509 | 509 | 00509_update9      | Sat Jan 10 00:00:00 1970
  510 |   0 | 00510              | Sun Jan 11 00:00:00 1970
  511 |   1 | 00511              | Mon Jan 12 00:00:00 1970
  513 | 303 | 00513_update3      | Wed Jan 14 00:00:00 1970
  514 |   4 | 00514              | Thu Jan 15 00:00:00 1970
  516 |   6 | 00516              | Sat Jan 17 00:00:00 1970
  517 | 407 | 00517_update7      | Sun Jan 18 00:00:00 1970
  518 |   8 | 00518              | Mon Jan 19 00:00:00 1970
  519 | 509 | 00519_update9      | Tue Jan 20 00:00:00 1970
  520 |   0 | 00520              | Wed Jan 21 00:00:00 1970
  521 |   1 | 00521              | Thu Jan 22 00:00:00 1970
  523 | 303 | 00523_update3      | Sat Jan 24 00:00:00 1970
  524 |   4 | 00524              | Sun Jan 25 00:00:00 1970
  526 |   6 | 00526              | Tue Jan 27 00:00:00 1970
  527 | 407 | 00527_update7      | Wed Jan 28 00:00:00 1970
  528 |   8 | 00528              | Thu Jan 29 00:00:00 1970
  529 | 509 | 00529_update9      | Fri Jan 30 00:00:00 1970
  530 |   0 | 00530              | Sat Jan 31 00:00:00 1970
  531 |   1 | 00531              | Sun Feb 01 00:00:00 1970
  533 | 303 | 00533_update3      | Tue Feb 03 00:00:00 1970
  534 |   4 | 00534              | Wed Feb 04 00:00:00 1970
  536 |   6 | 00536              | Fri Feb 06 00:00:00 1970
  537 | 407 | 00537_update7      | Sat Feb 07 00:00:00 1970
  538 |   8 | 00538              | Sun Feb 08 00:00:00 1970
  539 | 509 | 00539_update9      | Mon Feb 09 00:00:00 1970
  540 |   0 | 00540              | Tue Feb 10 00:00:00 1970
  541 |   1 | 00541              | Wed Feb 11 00:00:00 1970
  543 | 303 | 00543_update3      | Fri Feb 13 00:00:00 1970
  544 |   4 | 00544              | Sat Feb 14 00:00:00 1970
  546 |   6 | 00546              | Mon Feb 16 00:00:00 1970
  547 | 407 | 00547_update7      | Tue Feb 17 00:00:00 1970
  548 |   8 | 00548              | Wed Feb 18 00:00:00 1970
  549 | 509 | 00549_update9      | Thu Feb 19 00:00:00 1970
  550 |   0 | 00550              | Fri Feb 20 00:00:00 1970
  551 |   1 | 00551              | Sat Feb 21 00:00:00 1970
  553 | 303 | 00553_update3      | Mon Feb 23 00:00:00 1970
  554 |   4 | 00554              | Tue Feb 24 00:00:00 1970
  556 |   6 | 00556              | Thu Feb 26 00:00:00 1970
  557 | 407 | 00557_update7      | Fri Feb 27 00:00:00 1970
  558 |   8 | 00558              | Sat Feb 28 00:00:00 1970
  559 | 509 | 00559_update9      | Sun Mar 01 00:00:00 1970
  560 |   0 | 00560              | Mon Mar 02 00:00:00 1970
  561 |   1 | 00561              | Tue Mar 03 00:00:00 1970
  563 | 303 | 00563_update3      | Thu Mar 05 00:00:00 1970
  564 |   4 | 00564              | Fri Mar 06 00:00:00 1970
  566 |   6 | 00566              | Sun Mar 08 00:00:00 1970
  567 | 407 | 00567_update7      | Mon Mar 09 00:00:00 1970
  568 |   8 | 00568              | Tue Mar 10 00:00:00 1970
  569 | 509 | 00569_update9      | Wed Mar 11 00:00:00 1970
  570 |   0 | 00570              | Thu Mar 12 00:00:00 1970
  571 |   1 | 00571              | Fri Mar 13 00:00:00 1970
  573 | 303 | 00573_update3      | Sun Mar 15 00:00:00 1970
  574 |   4 | 00574              | Mon Mar 16 00:00:00 1970
  576 |   6 | 00576              | Wed Mar 18 00:00:00 1970
  577 | 407 | 00577_update7      | Thu Mar 19 00:00:00 1970
  578 |   8 | 00578              | Fri Mar 20 00:00:00 1970
  579 | 509 | 00579_update9      | Sat Mar 21 00:00:00 1970
  580 |   0 | 00580              | Sun Mar 22 00:00:00 1970
  581 |   1 | 00581              | Mon Mar 23 00:00:00 1970
  583 | 303 | 00583_update3      | Wed Mar 25 00:00:00 1970
  584 |   4 | 00584              | Thu Mar 26 00:00:00 1970
  586 |   6 | 00586              | Sat Mar 28 00:00:00 1970
  587 | 407 | 00587_update7      | Sun Mar 29 00:00:00 1970
  588 |   8 | 00588              | Mon Mar 30 00:00:00 1970
  589 | 509 | 00589_update9      | Tue Mar 31 00:00:00 1970
  590 |   0 | 00590              | Wed Apr 01 00:00:00 1970
  591 |   1 | 00591              | Thu Apr 02 00:00:00 1970
  593 | 303 | 00593_update3      | Sat Apr 04 00:00:00 1970
  594 |   4 | 00594              | Sun Apr 05 00:00:00 1970
  596 |   6 | 00596              | Tue Apr 07 00:00:00 1970
  597 | 407 | 00597_update7      | Wed Apr 08 00:00:00 1970
  598 |   8 | 00598              | Thu Apr 09 00:00:00 1970
  599 | 509 | 00599_update9      | Fri Apr 10 00:00:00 1970
  600 |   0 | 00600              | Thu Jan 01 00:00:00 1970
  601 |   1 | 00601              | Fri Jan 02 00:00:00 1970
  603 | 303 | 00603_update3      | Sun Jan 04 00:00:00 1970
  604 |   4 | 00604              | Mon Jan 05 00:00:00 1970
  606 |   6 | 00606              | Wed Jan 07 00:00:00 1970
  607 | 407 | 00607_update7      | Thu Jan 08 00:00:00 1970
  608 |   8 | 00608              | Fri Jan 09 00:00:00 1970
  609 | 509 | 00609_update9      | Sat Jan 10 00:00:00 1970
  610 |   0 | 00610              | Sun Jan 11 00:00:00 1970
  611 |   1 | 00611              | Mon Jan 12 00:00:00 1970
  613 | 303 | 00613_update3      | Wed Jan 14 00:00:00 1970
  614 |   4 | 00614              | Thu Jan 15 00:00:00 1970
  616 |   6 | 00616              | Sat Jan 17 00:00:00 1970
  617 | 407 | 00617_update7      | Sun Jan 18 00:00:00 1970
  618 |   8 | 00618              | Mon Jan 19 00:00:00 1970
  619 | 509 | 00619_update9      | Tue Jan 20 00:00:00 1970
  620 |   0 | 00620              | Wed Jan 21 00:00:00 1970
  621 |   1 | 00621              | Thu Jan 22 00:00:00 1970
  623 | 303 | 00623_update3      | Sat Jan 24 00:00:00 1970
  624 |   4 | 00624              | Sun Jan 25 00:00:00 1970
  626 |   6 | 00626              | Tue Jan 27 00:00:00 1970
  627 | 407 | 00627_update7      | Wed Jan 28 00:00:00 1970
  628 |   8 | 00628              | Thu Jan 29 00:00:00 1970
  629 | 509 | 00629_update9      | Fri Jan 30 00:00:00 1970
  630 |   0 | 00630              | Sat Jan 31 00:00:00 1970
  631 |   1 | 00631              | Sun Feb 01 00:00:00 1970
  633 | 303 | 00633_update3      | Tue Feb 03 00:00:00 1970
  634 |   4 | 00634              | Wed Feb 04 00:00:00 1970
  636 |   6 | 00636              | Fri Feb 06 00:00:00 1970
  637 | 407 | 00637_update7      | Sat Feb 07 00:00:00 1970
  638 |   8 | 00638              | Sun Feb 08 00:00:00 1970
  639 | 509 | 00639_update9      | Mon Feb 09 00:00:00 1970
  640 |   0 | 00640              | Tue Feb 10 00:00:00 1970
  641 |   1 | 00641              | Wed Feb 11 00:00:00 1970
  643 | 303 | 00643_update3      | Fri Feb 13 00:00:00 1970
  644 |   4 | 00644              | Sat Feb 14 00:00:00 1970
  646 |   6 | 00646              | Mon Feb 16 00:00:00 1970
  647 | 407 | 00647_update7      | Tue Feb 17 00:00:00 1970
  648 |   8 | 00648              | Wed Feb 18 00:00:00 1970
  649 | 509 | 00649_update9      | Thu Feb 19 00:00:00 1970
  650 |   0 | 00650              | Fri Feb 20 00:00:00 1970
  651 |   1 | 00651              | Sat Feb 21 00:00:00 1970
  653 | 303 | 00653_update3      | Mon Feb 23 00:00:00 1970
  654 |   4 | 00654              | Tue Feb 24 00:00:00 1970
  656 |   6 | 00656              | Thu Feb 26 00:00:00 1970
  657 | 407 | 00657_update7      | Fri Feb 27 00:00:00 1970
  658 |   8 | 00658              | Sat Feb 28 00:00:00 1970
  659 | 509 | 00659_update9      | Sun Mar 01 00:00:00 1970
  660 |   0 | 00660              | Mon Mar 02 00:00:00 1970
  661 |   1 | 00661              | Tue Mar 03 00:00:00 1970
  663 | 303 | 00663_update3      | Thu Mar 05 00:00:00 1970
  664 |   4 | 00664              | Fri Mar 06 00:00:00 1970
  666 |   6 | 00666              | Sun Mar 08 00:00:00 1970
  667 | 407 | 00667_update7      | Mon Mar 09 00:00:00 1970
  668 |   8 | 00668              | Tue Mar 10 00:00:00 1970
  669 | 509 | 00669_update9      | Wed Mar 11 00:00:00 1970
  670 |   0 | 00670              | Thu Mar 12 00:00:00 1970
  671 |   1 | 00671              | Fri Mar 13 00:00:00 1970
  673 | 303 | 00673_update3      | Sun Mar 15 00:00:00 1970
  674 |   4 | 00674              | Mon Mar 16 00:00:00 1970
  676 |   6 | 00676              | Wed Mar 18 00:00:00 1970
  677 | 407 | 00677_update7      | Thu Mar 19 00:00:00 1970
  678 |   8 | 00678              | Fri Mar 20 00:00:00 1970
  679 | 509 | 00679_update9      | Sat Mar 21 00:00:00 1970
  680 |   0 | 00680              | Sun Mar 22 00:00:00 1970
  681 |   1 | 00681              | Mon Mar 23 00:00:00 1970
  683 | 303 | 00683_update3      | Wed Mar 25 00:00:00 1970
  684 |   4 | 00684              | Thu Mar 26 00:00:00 1970
  686 |   6 | 00686              | Sat Mar 28 00:00:00 1970
  687 | 407 | 00687_update7      | Sun Mar 29 00:00:00 1970
  688 |   8 | 00688              | Mon Mar 30 00:00:00 1970
  689 | 509 | 00689_update9      | Tue Mar 31 00:00:00 1970
  690 |   0 | 00690              | Wed Apr 01 00:00:00 1970
  691 |   1 | 00691              | Thu Apr 02 00:00:00 1970
  693 | 303 | 00693_update3      | Sat Apr 04 00:00:00 1970
  694 |   4 | 00694              | Sun Apr 05 00:00:00 1970
  696 |   6 | 00696              | Tue Apr 07 00:00:00 1970
  697 | 407 | 00697_update7      | Wed Apr 08 00:00:00 1970
  698 |   8 | 00698              | Thu Apr 09 00:00:00 1970
  699 | 509 | 00699_update9      | Fri Apr 10 00:00:00 1970
  700 |   0 | 00700              | Thu Jan 01 00:00:00 1970
  701 |   1 | 00701              | Fri Jan 02 00:00:00 1970
  703 | 303 | 00703_update3      | Sun Jan 04 00:00:00 1970
  704 |   4 | 00704              | Mon Jan 05 00:00:00 1970
  706 |   6 | 00706              | Wed Jan 07 00:00:00 1970
  707 | 407 | 00707_update7      | Thu Jan 08 00:00:00 1970
  708 |   8 | 00708              | Fri Jan 09 00:00:00 1970
  709 | 509 | 00709_update9      | Sat Jan 10 00:00:00 1970
  710 |   0 | 00710              | Sun Jan 11 00:00:00 1970
  711 |   1 | 00711              | Mon Jan 12 00:00:00 1970
  713 | 303 | 00713_update3      | Wed Jan 14 00:00:00 1970
  714 |   4 | 00714              | Thu Jan 15 00:00:00 1970
  716 |   6 | 00716              | Sat Jan 17 00:00:00 1970
  717 | 407 | 00717_update7      | Sun Jan 18 00:00:00 1970
  718 |   8 | 00718              | Mon Jan 19 00:00:00 1970
  719 | 509 | 00719_update9      | Tue Jan 20 00:00:00 1970
  720 |   0 | 00720              | Wed Jan 21 00:00:00 1970
  721 |   1 | 00721              | Thu Jan 22 00:00:00 1970
  723 | 303 | 00723_update3      | Sat Jan 24 00:00:00 1970
  724 |   4 | 00724              | Sun Jan 25 00:00:00 1970
  726 |   6 | 00726              | Tue Jan 27 00:00:00 1970
  727 | 407 | 00727_update7      | Wed Jan 28 00:00:00 1970
  728 |   8 | 00728              | Thu Jan 29 00:00:00 1970
  729 | 509 | 00729_update9      | Fri Jan 30 00:00:00 1970
  730 |   0 | 00730              | Sat Jan 31 00:00:00 1970
  731 |   1 | 00731              | Sun Feb 01 00:00:00 1970
  733 | 303 | 00733_update3      | Tue Feb 03 00:00:00 1970
  734 |   4 | 00734              | Wed Feb 04 00:00:00 1970
  736 |   6 | 00736              | Fri Feb 06 00:00:00 1970
  737 | 407 | 00737_update7      | Sat Feb 07 00:00:00 1970
  738 |   8 | 00738              | Sun Feb 08 00:00:00 1970
  739 | 509 | 00739_update9      | Mon Feb 09 00:00:00 1970
  740 |   0 | 00740              | Tue Feb 10 00:00:00 1970
  741 |   1 | 00741              | Wed Feb 11 00:00:00 1970
  743 | 303 | 00743_update3      | Fri Feb 13 00:00:00 1970
  744 |   4 | 00744              | Sat Feb 14 00:00:00 1970
  746 |   6 | 00746              | Mon Feb 16 00:00:00 1970
  747 | 407 | 00747_update7      | Tue Feb 17 00:00:00 1970
  748 |   8 | 00748              | Wed Feb 18 00:00:00 1970
  749 | 509 | 00749_update9      | Thu Feb 19 00:00:00 1970
  750 |   0 | 00750              | Fri Feb 20 00:00:00 1970
  751 |   1 | 00751              | Sat Feb 21 00:00:00 1970
  753 | 303 | 00753_update3      | Mon Feb 23 00:00:00 1970
  754 |   4 | 00754              | Tue Feb 24 00:00:00 1970
  756 |   6 | 00756              | Thu Feb 26 00:00:00 1970
  757 | 407 | 00757_update7      | Fri Feb 27 00:00:00 1970
  758 |   8 | 00758              | Sat Feb 28 00:00:00 1970
  759 | 509 | 00759_update9      | Sun Mar 01 00:00:00 1970
  760 |   0 | 00760              | Mon Mar 02 00:00:00 1970
  761 |   1 | 00761              | Tue Mar 03 00:00:00 1970
  763 | 303 | 00763_update3      | Thu Mar 05 00:00:00 1970
  764 |   4 | 00764              | Fri Mar 06 00:00:00 1970
  766 |   6 | 00766              | Sun Mar 08 00:00:00 1970
  767 | 407 | 00767_update7      | Mon Mar 09 00:00:00 1970
  768 |   8 | 00768              | Tue Mar 10 00:00:00 1970
  769 | 509 | 00769_update9      | Wed Mar 11 00:00:00 1970
  770 |   0 | 00770              | Thu Mar 12 00:00:00 1970
  771 |   1 | 00771              | Fri Mar 13 00:00:00 1970
  773 | 303 | 00773_update3      | Sun Mar 15 00:00:00 1970
  774 |   4 | 00774              | Mon Mar 16 00:00:00 1970
  776 |   6 | 00776              | Wed Mar 18 00:00:00 1970
  777 | 407 | 00777_update7      | Thu Mar 19 00:00:00 1970
  778 |   8 | 00778              | Fri Mar 20 00:00:00 1970
  779 | 509 | 00779_update9      | Sat Mar 21 00:00:00 1970
  780 |   0 | 00780              | Sun Mar 22 00:00:00 1970
  781 |   1 | 00781              | Mon Mar 23 00:00:00 1970
  783 | 303 | 00783_update3      | Wed Mar 25 00:00:00 1970
  784 |   4 | 00784              | Thu Mar 26 00:00:00 1970
  786 |   6 | 00786              | Sat Mar 28 00:00:00 1970
  787 | 407 | 00787_update7      | Sun Mar 29 00:00:00 1970
  788 |   8 | 00788              | Mon Mar 30 00:00:00 1970
  789 | 509 | 00789_update9      | Tue Mar 31 00:00:00 1970
  790 |   0 | 00790              | Wed Apr 01 00:00:00 1970
  791 |   1 | 00791              | Thu Apr 02 00:00:00 1970
  793 | 303 | 00793_update3      | Sat Apr 04 00:00:00 1970
  794 |   4 | 00794              | Sun Apr 05 00:00:00 1970
  796 |   6 | 00796              | Tue Apr 07 00:00:00 1970
  797 | 407 | 00797_update7      | Wed Apr 08 00:00:00 1970
  798 |   8 | 00798              | Thu Apr 09 00:00:00 1970
  799 | 509 | 00799_update9      | Fri Apr 10 00:00:00 1970
  800 |   0 | 00800              | Thu Jan 01 00:00:00 1970
  801 |   1 | 00801              | Fri Jan 02 00:00:00 1970
  803 | 303 | 00803_update3      | Sun Jan 04 00:00:00 1970
  804 |   4 | 00804              | Mon Jan 05 00:00:00 1970
  806 |   6 | 00806              | Wed Jan 07 00:00:00 1970
  807 | 407 | 00807_update7      | Thu Jan 08 00:00:00 1970
  808 |   8 | 00808              | Fri Jan 09 00:00:00 1970
  809 | 509 | 00809_update9      | Sat Jan 10 00:00:00 1970
  810 |   0 | 00810              | Sun Jan 11 00:00:00 1970
  811 |   1 | 00811              | Mon Jan 12 00:00:00 1970
  813 | 303 | 00813_update3      | Wed Jan 14 00:00:00 1970
  814 |   4 | 00814              | Thu Jan 15 00:00:00 1970
  816 |   6 | 00816              | Sat Jan 17 00:00:00 1970
  817 | 407 | 00817_update7      | Sun Jan 18 00:00:00 1970
  818 |   8 | 00818              | Mon Jan 19 00:00:00 1970
  819 | 509 | 00819_update9      | Tue Jan 20 00:00:00 1970
  820 |   0 | 00820              | Wed Jan 21 00:00:00 1970
  821 |   1 | 00821              | Thu Jan 22 00:00:00 1970
  823 | 303 | 00823_update3      | Sat Jan 24 00:00:00 1970
  824 |   4 | 00824              | Sun Jan 25 00:00:00 1970
  826 |   6 | 00826              | Tue Jan 27 00:00:00 1970
  827 | 407 | 00827_update7      | Wed Jan 28 00:00:00 1970
  828 |   8 | 00828              | Thu Jan 29 00:00:00 1970
  829 | 509 | 00829_update9      | Fri Jan 30 00:00:00 1970
  830 |   0 | 00830              | Sat Jan 31 00:00:00 1970
  831 |   1 | 00831              | Sun Feb 01 00:00:00 1970
  833 | 303 | 00833_update3      | Tue Feb 03 00:00:00 1970
  834 |   4 | 00834              | Wed Feb 04 00:00:00 1970
  836 |   6 | 00836              | Fri Feb 06 00:00:00 1970
  837 | 407 | 00837_update7      | Sat Feb 07 00:00:00 1970
  838 |   8 | 00838              | Sun Feb 08 00:00:00 1970
  839 | 509 | 00839_update9      | Mon Feb 09 00:00:00 1970
  840 |   0 | 00840              | Tue Feb 10 00:00:00 1970
  841 |   1 | 00841              | Wed Feb 11 00:00:00 1970
  843 | 303 | 00843_update3      | Fri Feb 13 00:00:00 1970
  844 |   4 | 00844              | Sat Feb 14 00:00:00 1970
  846 |   6 | 00846              | Mon Feb 16 00:00:00 1970
  847 | 407 | 00847_update7      | Tue Feb 17 00:00:00 1970
  848 |   8 | 00848              | Wed Feb 18 00:00:00 1970
  849 | 509 | 00849_update9      | Thu Feb 19 00:00:00 1970
  850 |   0 | 00850              | Fri Feb 20 00:00:00 1970
  851 |   1 | 00851              | Sat Feb 21 00:00:00 1970
  853 | 303 | 00853_update3      | Mon Feb 23 00:00:00 1970
  854 |   4 | 00854              | Tue Feb 24 00:00:00 1970
  856 |   6 | 00856              | Thu Feb 26 00:00:00 1970
  857 | 407 | 00857_update7      | Fri Feb 27 00:00:00 1970
  858 |   8 | 00858              | Sat Feb 28 00:00:00 1970
  859 | 509 | 00859_update9      | Sun Mar 01 00:00:00 1970
  860 |   0 | 00860              | Mon Mar 02 00:00:00 1970
  861 |   1 | 00861              | Tue Mar 03 00:00:00 1970
  863 | 303 | 00863_update3      | Thu Mar 05 00:00:00 1970
  864 |   4 | 00864              | Fri Mar 06 00:00:00 1970
  866 |   6 | 00866              | Sun Mar 08 00:00:00 1970
  867 | 407 | 00867_update7      | Mon Mar 09 00:00:00 1970
  868 |   8 | 00868              | Tue Mar 10 00:00:00 1970
  869 | 509 | 00869_update9      | Wed Mar 11 00:00:00 1970
  870 |   0 | 00870              | Thu Mar 12 00:00:00 1970
  871 |   1 | 00871              | Fri Mar 13 00:00:00 1970
  873 | 303 | 00873_update3      | Sun Mar 15 00:00:00 1970
  874 |   4 | 00874              | Mon Mar 16 00:00:00 1970
  876 |   6 | 00876              | Wed Mar 18 00:00:00 1970
  877 | 407 | 00877_update7      | Thu Mar 19 00:00:00 1970
  878 |   8 | 00878              | Fri Mar 20 00:00:00 1970
  879 | 509 | 00879_update9      | Sat Mar 21 00:00:00 1970
  880 |   0 | 00880              | Sun Mar 22 00:00:00 1970
  881 |   1 | 00881              | Mon Mar 23 00:00:00 1970
  883 | 303 | 00883_update3      | Wed Mar 25 00:00:00 1970
  884 |   4 | 00884              | Thu Mar 26 00:00:00 1970
  886 |   6 | 00886              | Sat Mar 28 00:00:00 1970
  887 | 407 | 00887_update7      | Sun Mar 29 00:00:00 1970
  888 |   8 | 00888              | Mon Mar 30 00:00:00 1970
  889 | 509 | 00889_update9      | Tue Mar 31 00:00:00 1970
  890 |   0 | 00890              | Wed Apr 01 00:00:00 1970
  891 |   1 | 00891              | Thu Apr 02 00:00:00 1970
  893 | 303 | 00893_update3      | Sat Apr 04 00:00:00 1970
  894 |   4 | 00894              | Sun Apr 05 00:00:00 1970
  896 |   6 | 00896              | Tue Apr 07 00:00:00 1970
  897 | 407 | 00897_update7      | Wed Apr 08 00:00:00 1970
  898 |   8 | 00898              | Thu Apr 09 00:00:00 1970
  899 | 509 | 00899_update9      | Fri Apr 10 00:00:00 1970
  900 |   0 | 00900              | Thu Jan 01 00:00:00 1970
  901 |   1 | 00901              | Fri Jan 02 00:00:00 1970
  903 | 303 | 00903_update3      | Sun Jan 04 00:00:00 1970
  904 |   4 | 00904              | Mon Jan 05 00:00:00 1970
  906 |   6 | 00906              | Wed Jan 07 00:00:00 1970
  907 | 407 | 00907_update7      | Thu Jan 08 00:00:00 1970
  908 |   8 | 00908              | Fri Jan 09 00:00:00 1970
  909 | 509 | 00909_update9      | Sat Jan 10 00:00:00 1970
  910 |   0 | 00910              | Sun Jan 11 00:00:00 1970
  911 |   1 | 00911              | Mon Jan 12 00:00:00 1970
  913 | 303 | 00913_update3      | Wed Jan 14 00:00:00 1970
  914 |   4 | 00914              | Thu Jan 15 00:00:00 1970
  916 |   6 | 00916              | Sat Jan 17 00:00:00 1970
  917 | 407 | 00917_update7      | Sun Jan 18 00:00:00 1970
  918 |   8 | 00918              | Mon Jan 19 00:00:00 1970
  919 | 509 | 00919_update9      | Tue Jan 20 00:00:00 1970
  920 |   0 | 00920              | Wed Jan 21 00:00:00 1970
  921 |   1 | 00921              | Thu Jan 22 00:00:00 1970
  923 | 303 | 00923_update3      | Sat Jan 24 00:00:00 1970
  924 |   4 | 00924              | Sun Jan 25 00:00:00 1970
  926 |   6 | 00926              | Tue Jan 27 00:00:00 1970
  927 | 407 | 00927_update7      | Wed Jan 28 00:00:00 1970
  928 |   8 | 00928              | Thu Jan 29 00:00:00 1970
  929 | 509 | 00929_update9      | Fri Jan 30 00:00:00 1970
  930 |   0 | 00930              | Sat Jan 31 00:00:00 1970
  931 |   1 | 00931              | Sun Feb 01 00:00:00 1970
  933 | 303 | 00933_update3      | Tue Feb 03 00:00:00 1970
  934 |   4 | 00934              | Wed Feb 04 00:00:00 1970
  936 |   6 | 00936              | Fri Feb 06 00:00:00 1970
  937 | 407 | 00937_update7      | Sat Feb 07 00:00:00 1970
  938 |   8 | 00938              | Sun Feb 08 00:00:00 1970
  939 | 509 | 00939_update9      | Mon Feb 09 00:00:00 1970
  940 |   0 | 00940              | Tue Feb 10 00:00:00 1970
  941 |   1 | 00941              | Wed Feb 11 00:00:00 1970
  943 | 303 | 00943_update3      | Fri Feb 13 00:00:00 1970
  944 |   4 | 00944              | Sat Feb 14 00:00:00 1970
  946 |   6 | 00946              | Mon Feb 16 00:00:00 1970
  947 | 407 | 00947_update7      | Tue Feb 17 00:00:00 1970
  948 |   8 | 00948              | Wed Feb 18 00:00:00 1970
  949 | 509 | 00949_update9      | Thu Feb 19 00:00:00 1970
  950 |   0 | 00950              | Fri Feb 20 00:00:00 1970
  951 |   1 | 00951              | Sat Feb 21 00:00:00 1970
  953 | 303 | 00953_update3      | Mon Feb 23 00:00:00 1970
  954 |   4 | 00954              | Tue Feb 24 00:00:00 1970
  956 |   6 | 00956              | Thu Feb 26 00:00:00 1970
  957 | 407 | 00957_update7      | Fri Feb 27 00:00:00 1970
  958 |   8 | 00958              | Sat Feb 28 00:00:00 1970
  959 | 509 | 00959_update9      | Sun Mar 01 00:00:00 1970
  960 |   0 | 00960              | Mon Mar 02 00:00:00 1970
  961 |   1 | 00961              | Tue Mar 03 00:00:00 1970
  963 | 303 | 00963_update3      | Thu Mar 05 00:00:00 1970
  964 |   4 | 00964              | Fri Mar 06 00:00:00 1970
  966 |   6 | 00966              | Sun Mar 08 00:00:00 1970
  967 | 407 | 00967_update7      | Mon Mar 09 00:00:00 1970
  968 |   8 | 00968              | Tue Mar 10 00:00:00 1970
  969 | 509 | 00969_update9      | Wed Mar 11 00:00:00 1970
  970 |   0 | 00970              | Thu Mar 12 00:00:00 1970
  971 |   1 | 00971              | Fri Mar 13 00:00:00 1970
  973 | 303 | 00973_update3      | Sun Mar 15 00:00:00 1970
  974 |   4 | 00974              | Mon Mar 16 00:00:00 1970
  976 |   6 | 00976              | Wed Mar 18 00:00:00 1970
  977 | 407 | 00977_update7      | Thu Mar 19 00:00:00 1970
  978 |   8 | 00978              | Fri Mar 20 00:00:00 1970
  979 | 509 | 00979_update9      | Sat Mar 21 00:00:00 1970
  980 |   0 | 00980              | Sun Mar 22 00:00:00 1970
  981 |   1 | 00981              | Mon Mar 23 00:00:00 1970
  983 | 303 | 00983_update3      | Wed Mar 25 00:00:00 1970
  984 |   4 | 00984              | Thu Mar 26 00:00:00 1970
  986 |   6 | 00986              | Sat Mar 28 00:00:00 1970
  987 | 407 | 00987_update7      | Sun Mar 29 00:00:00 1970
  988 |   8 | 00988              | Mon Mar 30 00:00:00 1970
  989 | 509 | 00989_update9      | Tue Mar 31 00:00:00 1970
  990 |   0 | 00990              | Wed Apr 01 00:00:00 1970
  991 |   1 | 00991              | Thu Apr 02 00:00:00 1970
  993 | 303 | 00993_update3      | Sat Apr 04 00:00:00 1970
  994 |   4 | 00994              | Sun Apr 05 00:00:00 1970
  996 |   6 | 00996              | Tue Apr 07 00:00:00 1970
  997 | 407 | 00997_update7      | Wed Apr 08 00:00:00 1970
  998 |   8 | 00998              | Thu Apr 09 00:00:00 1970
  999 | 509 | 00999_update9      | Fri Apr 10 00:00:00 1970
 1000 |   0 | 01000              | Thu Jan 01 00:00:00 1970
 1001 | 101 | 0000100001         | 
 1003 | 403 | 0000300003_update3 | 
 1004 | 104 | 0000400004         | 
 1006 | 106 | 0000600006         | 
 1007 | 507 | 0000700007_update7 | 
 1008 | 108 | 0000800008         | 
 1009 | 609 | 0000900009_update9 | 
 1010 | 100 | 0001000010         | 
 1011 | 101 | 0001100011         | 
 1013 | 403 | 0001300013_update3 | 
 1014 | 104 | 0001400014         | 
 1016 | 106 | 0001600016         | 
 1017 | 507 | 0001700017_update7 | 
 1018 | 108 | 0001800018         | 
 1019 | 609 | 0001900019_update9 | 
 1020 | 100 | 0002000020         | 
 1101 | 201 | aaa                | 
 1103 | 503 | ccc_update3        | 
 1104 | 204 | ddd                | 
(819 rows)

--Testcase 520:
EXPLAIN (verbose, costs off)
INSERT INTO ft2 VALUES (json_build_object('c1', 1200, 'c2', 999, 'c3', 'foo'));
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Insert on public.ft2
   ->  Result
         Output: json_build_object('c1', 1200, 'c2', 999, 'c3', 'foo'), NULL::integer
(3 rows)

--Testcase 521:
INSERT INTO ft2 VALUES (json_build_object('c1', 1200, 'c2', 999, 'c3', 'foo'));
--Testcase 522:
EXPLAIN (verbose, costs off)
UPDATE ft2 SET v = json_build_object('c3', 'bar') WHERE (v->>'c1')::int8 = 1200;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Update on public.ft2
   ->  Foreign Scan on public.ft2
         Output: json_build_object('c3', 'bar'), NULL::integer, v, v
         Filter: (((ft2.v ->> 'c1'::text))::bigint = 1200)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 523:
UPDATE ft2 SET v = json_build_object('c3', 'bar') WHERE (v->>'c1')::int8 = 1200;
--Testcase 524:
EXPLAIN (verbose, costs off)
DELETE FROM ft2 WHERE (v->>'c1')::int8 = 1200;
                        QUERY PLAN                         
-----------------------------------------------------------
 Delete on public.ft2
   ->  Foreign Scan on public.ft2
         Output: v, v
         Filter: (((ft2.v ->> 'c1'::text))::bigint = 1200)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 525:
DELETE FROM ft2 WHERE (v->>'c1')::int8 = 1200;
-- Test UPDATE/DELETE with RETURNING on a three-table join
--Testcase 526:
INSERT INTO ft2
  SELECT json_build_object('c1', id, 'c2', id - 1200, 'c3', to_char(id, 'FM00000')) FROM generate_series(1201, 1300) id;
--Testcase 527:
EXPLAIN (verbose, costs off)
UPDATE ft2 SET v = json_build_object('c3', 'foo')
  FROM ft4 INNER JOIN ft5 ON ((ft4.v->>'c1')::int = (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int8 > 1200 AND (ft2.v->>'c2')::int = (ft4.v->>'c1')::int;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Update on public.ft2
   ->  Hash Join
         Output: json_build_object('c3', 'foo'), NULL::integer, ft2.v, ft2.v, ft4.*, ft5.*
         Hash Cond: (((ft2.v ->> 'c2'::text))::integer = ((ft4.v ->> 'c1'::text))::integer)
         ->  Foreign Scan on public.ft2
               Output: ft2.v
               Filter: (((ft2.v ->> 'c1'::text))::bigint > 1200)
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: ft4.*, ft4.v, ft5.*, ft5.v
               ->  Hash Join
                     Output: ft4.*, ft4.v, ft5.*, ft5.v
                     Hash Cond: (((ft4.v ->> 'c1'::text))::integer = ((ft5.v ->> 'c1'::text))::integer)
                     ->  Foreign Scan on public.ft4
                           Output: ft4.*, ft4.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: ft5.*, ft5.v
                           ->  Foreign Scan on public.ft5
                                 Output: ft5.*, ft5.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 528:
UPDATE ft2 SET v = json_build_object('c3', 'foo')
  FROM ft4 INNER JOIN ft5 ON ((ft4.v->>'c1')::int = (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int8 > 1200 AND (ft2.v->>'c2')::int = (ft4.v->>'c1')::int;
--Testcase 529:
SELECT ft2, ft2.*, ft4, ft4.*
  FROM ft2 INNER JOIN ft4 ON ((ft2.v->>'c1')::int8 > 1200 AND (ft2.v->>'c2')::int = (ft4.v->>'c1')::int)
  INNER JOIN ft5 ON ((ft4.v->>'c1')::int = (ft5.v->>'c1')::int);
                                                   ft2                                                   |                                          v                                          |                       ft4                        |                  v                   
---------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------+--------------------------------------------------+--------------------------------------
 ("{""c1"": 1206, ""c2"": 6, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}")  | {"c1": 1206, "c2": 6, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null}  | ("{""c1"": 6, ""c2"": 7, ""c3"": ""AAA006""}")   | {"c1": 6, "c2": 7, "c3": "AAA006"}
 ("{""c1"": 1212, ""c2"": 12, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1212, "c2": 12, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 12, ""c2"": 13, ""c3"": ""AAA012""}") | {"c1": 12, "c2": 13, "c3": "AAA012"}
 ("{""c1"": 1218, ""c2"": 18, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1218, "c2": 18, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 18, ""c2"": 19, ""c3"": ""AAA018""}") | {"c1": 18, "c2": 19, "c3": "AAA018"}
 ("{""c1"": 1224, ""c2"": 24, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1224, "c2": 24, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 24, ""c2"": 25, ""c3"": ""AAA024""}") | {"c1": 24, "c2": 25, "c3": "AAA024"}
 ("{""c1"": 1230, ""c2"": 30, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1230, "c2": 30, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 30, ""c2"": 31, ""c3"": ""AAA030""}") | {"c1": 30, "c2": 31, "c3": "AAA030"}
 ("{""c1"": 1236, ""c2"": 36, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1236, "c2": 36, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 36, ""c2"": 37, ""c3"": ""AAA036""}") | {"c1": 36, "c2": 37, "c3": "AAA036"}
 ("{""c1"": 1242, ""c2"": 42, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1242, "c2": 42, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 42, ""c2"": 43, ""c3"": ""AAA042""}") | {"c1": 42, "c2": 43, "c3": "AAA042"}
 ("{""c1"": 1248, ""c2"": 48, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1248, "c2": 48, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 48, ""c2"": 49, ""c3"": ""AAA048""}") | {"c1": 48, "c2": 49, "c3": "AAA048"}
 ("{""c1"": 1254, ""c2"": 54, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1254, "c2": 54, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 54, ""c2"": 55, ""c3"": ""AAA054""}") | {"c1": 54, "c2": 55, "c3": "AAA054"}
 ("{""c1"": 1260, ""c2"": 60, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1260, "c2": 60, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 60, ""c2"": 61, ""c3"": ""AAA060""}") | {"c1": 60, "c2": 61, "c3": "AAA060"}
 ("{""c1"": 1266, ""c2"": 66, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1266, "c2": 66, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 66, ""c2"": 67, ""c3"": ""AAA066""}") | {"c1": 66, "c2": 67, "c3": "AAA066"}
 ("{""c1"": 1272, ""c2"": 72, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1272, "c2": 72, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 72, ""c2"": 73, ""c3"": ""AAA072""}") | {"c1": 72, "c2": 73, "c3": "AAA072"}
 ("{""c1"": 1278, ""c2"": 78, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1278, "c2": 78, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 78, ""c2"": 79, ""c3"": ""AAA078""}") | {"c1": 78, "c2": 79, "c3": "AAA078"}
 ("{""c1"": 1284, ""c2"": 84, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1284, "c2": 84, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 84, ""c2"": 85, ""c3"": ""AAA084""}") | {"c1": 84, "c2": 85, "c3": "AAA084"}
 ("{""c1"": 1290, ""c2"": 90, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1290, "c2": 90, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 90, ""c2"": 91, ""c3"": ""AAA090""}") | {"c1": 90, "c2": 91, "c3": "AAA090"}
 ("{""c1"": 1296, ""c2"": 96, ""c3"": ""foo"", ""c5"": null, ""c6"": null, ""c7"": null, ""c8"": null}") | {"c1": 1296, "c2": 96, "c3": "foo", "c5": null, "c6": null, "c7": null, "c8": null} | ("{""c1"": 96, ""c2"": 97, ""c3"": ""AAA096""}") | {"c1": 96, "c2": 97, "c3": "AAA096"}
(16 rows)

--Testcase 530:
EXPLAIN (verbose, costs off)
DELETE FROM ft2
  USING ft4 LEFT JOIN ft5 ON ((ft4.v->>'c1')::int = (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int8 > 1200 AND (ft2.v->>'c1')::int8 % 10 = 0 AND (ft2.v->>'c2')::int = (ft4.v->>'c1')::int;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Delete on public.ft2
   ->  Hash Left Join
         Output: ft2.v, ft2.v, ft4.*, ft5.*
         Hash Cond: (((ft4.v ->> 'c1'::text))::integer = ((ft5.v ->> 'c1'::text))::integer)
         ->  Hash Join
               Output: ft2.v, ft4.*, ft4.v
               Hash Cond: (((ft2.v ->> 'c2'::text))::integer = ((ft4.v ->> 'c1'::text))::integer)
               ->  Foreign Scan on public.ft2
                     Output: ft2.v
                     Filter: ((((ft2.v ->> 'c1'::text))::bigint > 1200) AND ((((ft2.v ->> 'c1'::text))::bigint % '10'::bigint) = 0))
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: ft4.*, ft4.v
                     ->  Foreign Scan on public.ft4
                           Output: ft4.*, ft4.v
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: ft5.*, ft5.v
               ->  Foreign Scan on public.ft5
                     Output: ft5.*, ft5.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 531:
DELETE FROM ft2
  USING ft4 LEFT JOIN ft5 ON ((ft4.v->>'c1')::int = (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int8 > 1200 AND (ft2.v->>'c1')::int8 % 10 = 0 AND (ft2.v->>'c2')::int = (ft4.v->>'c1')::int;
--Testcase 532:
DELETE FROM ft2 WHERE (ft2.v->>'c1')::int8 > 1200;
-- Test UPDATE with a MULTIEXPR sub-select
-- (maybe someday this'll be remotely executable, but not today)
--Testcase 533:
EXPLAIN (verbose, costs off)
UPDATE ft2 AS target SET (v) = (
    SELECT json_build_object('c2', (v->>'c2')::int * 10, 'c7', v->>'c7')
        FROM ft2 AS src
        WHERE (target.v->>'c1')::int8 = (src.v->>'c1')::int8
) WHERE (v->>'c1')::int > 1100;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Update on public.ft2 target
   ->  Foreign Scan on public.ft2 target
         Output: $1, NULL::integer, (SubPlan 1 (returns $1)), target.v, target.v
         Filter: (((target.v ->> 'c1'::text))::integer > 1100)
         Reader: Single File
         Row groups: 1
         SubPlan 1 (returns $1)
           ->  Foreign Scan on public.ft2 src
                 Output: json_build_object('c2', (((src.v ->> 'c2'::text))::integer * 10), 'c7', (src.v ->> 'c7'::text))
                 Filter: (((target.v ->> 'c1'::text))::bigint = ((src.v ->> 'c1'::text))::bigint)
                 Reader: Single File
                 Row groups: 1
(12 rows)

--Testcase 534:
UPDATE ft2 AS target SET (v) = (
    SELECT json_build_object('c2', (v->>'c2')::int * 10, 'c7', v->>'c7')
        FROM ft2 AS src
        WHERE (target.v->>'c1')::int8 = (src.v->>'c1')::int8
) WHERE (v->>'c1')::int > 1100;
--Testcase 535:
UPDATE ft2 AS target SET (v) = (
    SELECT json_build_object('c2', (v->>'c2')::int / 10)
        FROM ft2 AS src
        WHERE (target.v->>'c1')::int8 = (src.v->>'c1')::int8
) WHERE (v->>'c1')::int > 1100;
-- Test UPDATE involving a join that can be pushed down,
-- but a SET clause that can't be
--Testcase 536:
EXPLAIN (VERBOSE, COSTS OFF)
UPDATE ft2 d SET v = json_build_object('c2', CASE WHEN random() >= 0 THEN (d.v->'c2')::int ELSE 0 END)
  FROM ft2 AS t WHERE (d.v->'c1')::int8 = (t.v->'c1')::int8 AND (d.v->'c1')::int8 > 1000;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Update on public.ft2 d
   ->  Merge Join
         Output: json_build_object('c2', CASE WHEN (random() >= '0'::double precision) THEN ((d.v -> 'c2'::text))::integer ELSE 0 END), NULL::integer, d.v, d.v, t.*
         Merge Cond: ((((d.v -> 'c1'::text))::bigint) = (((t.v -> 'c1'::text))::bigint))
         ->  Sort
               Output: d.v, (((d.v -> 'c1'::text))::bigint)
               Sort Key: (((d.v -> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 d
                     Output: d.v, ((d.v -> 'c1'::text))::bigint
                     Filter: (((d.v -> 'c1'::text))::bigint > 1000)
                     Reader: Single File
                     Row groups: 1
         ->  Sort
               Output: t.*, t.v, (((t.v -> 'c1'::text))::bigint)
               Sort Key: (((t.v -> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t
                     Output: t.*, t.v, ((t.v -> 'c1'::text))::bigint
                     Reader: Single File
                     Row groups: 1
(19 rows)

--Testcase 537:
UPDATE ft2 d SET v = json_build_object('c2', CASE WHEN random() >= 0 THEN (d.v->'c2')::int ELSE 0 END)
  FROM ft2 AS t WHERE (d.v->'c1')::int8 = (t.v->'c1')::int8 AND (d.v->'c1')::int8 > 1000;
-- Test UPDATE/DELETE with WHERE or JOIN/ON conditions containing
-- user-defined operators/functions
-- ALTER SERVER loopback OPTIONS (DROP extensions);
--Testcase 538:
INSERT INTO ft2
  SELECT json_build_object('c1', id, 'c2', id % 10, 'c3', to_char(id, 'FM00000')) FROM generate_series(2001, 2010) id;
--Testcase 539:
EXPLAIN (verbose, costs off)
UPDATE ft2 SET v = json_build_object('c3', 'bar') WHERE parquet_s3_fdw_abs((v->>'c1')::int) > 2000;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Update on public.ft2
   ->  Foreign Scan on public.ft2
         Output: json_build_object('c3', 'bar'), NULL::integer, v, v
         Filter: (parquet_s3_fdw_abs(((ft2.v ->> 'c1'::text))::integer) > 2000)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 540:
UPDATE ft2 SET v = json_build_object('c3', 'bar') WHERE parquet_s3_fdw_abs((v->>'c1')::int) > 2000;
--Testcase 541:
SELECT * FROM ft2 WHERE parquet_s3_fdw_abs((v->>'c1')::int) > 2000;
                                         v                                          
------------------------------------------------------------------------------------
 {"c1": 2001, "c2": 1, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2002, "c2": 2, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2003, "c2": 3, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2004, "c2": 4, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2005, "c2": 5, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2006, "c2": 6, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2007, "c2": 7, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2008, "c2": 8, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2009, "c2": 9, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 2010, "c2": 0, "c3": "bar", "c5": null, "c6": null, "c7": null, "c8": null}
(10 rows)

--Testcase 542:
EXPLAIN (verbose, costs off)
UPDATE ft2 SET v = json_build_object('c3', 'baz')
  FROM ft4 INNER JOIN ft5 ON ((ft4.v->>'c1')::int = (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int > 2000 AND (ft2.v->>'c2')::int === (ft4.v->>'c1')::int;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Update on public.ft2
   ->  Nested Loop
         Output: json_build_object('c3', 'baz'), NULL::integer, ft2.v, ft2.v, ft4.*, ft5.*
         Join Filter: (((ft2.v ->> 'c2'::text))::integer === ((ft4.v ->> 'c1'::text))::integer)
         ->  Foreign Scan on public.ft2
               Output: ft2.v
               Filter: (((ft2.v ->> 'c1'::text))::integer > 2000)
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: ft4.*, ft4.v, ft5.*
               ->  Hash Join
                     Output: ft4.*, ft4.v, ft5.*
                     Hash Cond: (((ft4.v ->> 'c1'::text))::integer = ((ft5.v ->> 'c1'::text))::integer)
                     ->  Foreign Scan on public.ft4
                           Output: ft4.*, ft4.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: ft5.*, ft5.v
                           ->  Foreign Scan on public.ft5
                                 Output: ft5.*, ft5.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 543:
UPDATE ft2 SET v = json_build_object('c3', 'baz')
  FROM ft4 INNER JOIN ft5 ON ((ft4.v->>'c1')::int = (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int > 2000 AND (ft2.v->>'c2')::int === (ft4.v->>'c1')::int;
--Testcase 544:
SELECT ft2.*, ft4.*, ft5.*
  FROM ft2, ft4 INNER JOIN ft5 ON ((ft4.v->>'c1')::int = (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int > 2000 AND (ft2.v->>'c2')::int === (ft4.v->>'c1')::int;
                                         v                                          |                 v                  |                 v                  
------------------------------------------------------------------------------------+------------------------------------+------------------------------------
 {"c1": 2006, "c2": 6, "c3": "baz", "c5": null, "c6": null, "c7": null, "c8": null} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"}
(1 row)

--Testcase 545:
EXPLAIN (verbose, costs off)
DELETE FROM ft2
  USING ft4 INNER JOIN ft5 ON ((ft4.v->>'c1')::int === (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int > 2000 AND (ft2.v->>'c2')::int = (ft4.v->>'c1')::int;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Delete on public.ft2
   ->  Nested Loop
         Output: ft2.v, ft2.v, ft4.*, ft5.*
         Join Filter: (((ft4.v ->> 'c1'::text))::integer === ((ft5.v ->> 'c1'::text))::integer)
         ->  Hash Join
               Output: ft2.v, ft4.*, ft4.v
               Hash Cond: (((ft2.v ->> 'c2'::text))::integer = ((ft4.v ->> 'c1'::text))::integer)
               ->  Foreign Scan on public.ft2
                     Output: ft2.v
                     Filter: (((ft2.v ->> 'c1'::text))::integer > 2000)
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: ft4.*, ft4.v
                     ->  Foreign Scan on public.ft4
                           Output: ft4.*, ft4.v
                           Reader: Single File
                           Row groups: 1
         ->  Materialize
               Output: ft5.*, ft5.v
               ->  Foreign Scan on public.ft5
                     Output: ft5.*, ft5.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 546:
DELETE FROM ft2
  USING ft4 INNER JOIN ft5 ON ((ft4.v->>'c1')::int === (ft5.v->>'c1')::int)
  WHERE (ft2.v->>'c1')::int > 2000 AND (ft2.v->>'c2')::int = (ft4.v->>'c1')::int;
--Testcase 547:
DELETE FROM ft2 WHERE (ft2.v->>'c1')::int8 > 2000;
-- ALTER SERVER loopback OPTIONS (ADD extensions 'postgres_fdw');
-- Test that trigger on remote table works as expected
--Testcase 548:
CREATE OR REPLACE FUNCTION "S 1".F_BRTRIG() RETURNS trigger AS $$
BEGIN
    NEW.v =  jsonb_set(NEW.v, '{c3}', to_jsonb(NEW.v->>'c3' || '_trig_update'), false);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
--Testcase 549:
CREATE TRIGGER t1_br_insert BEFORE INSERT OR UPDATE
    ON ft2 FOR EACH ROW EXECUTE PROCEDURE "S 1".F_BRTRIG();
--Testcase 550:
INSERT INTO ft2 VALUES (json_build_object('c1', 1208, 'c2', 818, 'c3', 'fff'));
--Testcase 551:
SELECT * FROM ft2 WHERE (v->>'c1')::int8 = 1208;
                                                v                                                 
--------------------------------------------------------------------------------------------------
 {"c1": 1208, "c2": 818, "c3": "fff_trig_update", "c5": null, "c6": null, "c7": null, "c8": null}
(1 row)

--Testcase 552:
INSERT INTO ft2 VALUES (json_build_object('c1', 1218, 'c2', 818, 'c3', 'ggg', 'c6', '(--;'));
--Testcase 553:
SELECT * FROM ft2 WHERE (v->>'c1')::int8 = 1218;
                                                 v                                                  
----------------------------------------------------------------------------------------------------
 {"c1": 1218, "c2": 818, "c3": "ggg_trig_update", "c5": null, "c6": "(--;", "c7": null, "c8": null}
(1 row)

--Testcase 554:
UPDATE ft2 SET v = json_build_object('c2', (ft2.v->>'c2')::int + 600, 'c3', v->>'c3') WHERE (v->>'c1')::int8 % 10 = 8 AND (v->>'c1')::int8 < 1200;
--Testcase 555:
SELECT * FROM ft2 WHERE (v->>'c1')::int8 % 10 = 8 AND (v->>'c1')::int8 < 1200;
                                                           v                                                            
------------------------------------------------------------------------------------------------------------------------
 {"c1": 8, "c2": 608, "c3": "00008_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 18, "c2": 608, "c3": "00018_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 28, "c2": 608, "c3": "00028_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 38, "c2": 608, "c3": "00038_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 48, "c2": 608, "c3": "00048_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 58, "c2": 608, "c3": "00058_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 68, "c2": 608, "c3": "00068_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 78, "c2": 608, "c3": "00078_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 88, "c2": 608, "c3": "00088_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 98, "c2": 608, "c3": "00098_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 108, "c2": 608, "c3": "00108_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 118, "c2": 608, "c3": "00118_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 128, "c2": 608, "c3": "00128_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 138, "c2": 608, "c3": "00138_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 148, "c2": 608, "c3": "00148_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 158, "c2": 608, "c3": "00158_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 168, "c2": 608, "c3": "00168_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 178, "c2": 608, "c3": "00178_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 188, "c2": 608, "c3": "00188_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 198, "c2": 608, "c3": "00198_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 208, "c2": 608, "c3": "00208_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 218, "c2": 608, "c3": "00218_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 228, "c2": 608, "c3": "00228_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 238, "c2": 608, "c3": "00238_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 248, "c2": 608, "c3": "00248_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 258, "c2": 608, "c3": "00258_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 268, "c2": 608, "c3": "00268_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 278, "c2": 608, "c3": "00278_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 288, "c2": 608, "c3": "00288_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 298, "c2": 608, "c3": "00298_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 308, "c2": 608, "c3": "00308_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 318, "c2": 608, "c3": "00318_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 328, "c2": 608, "c3": "00328_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 338, "c2": 608, "c3": "00338_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 348, "c2": 608, "c3": "00348_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 358, "c2": 608, "c3": "00358_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 368, "c2": 608, "c3": "00368_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 378, "c2": 608, "c3": "00378_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 388, "c2": 608, "c3": "00388_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 398, "c2": 608, "c3": "00398_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 408, "c2": 608, "c3": "00408_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 418, "c2": 608, "c3": "00418_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 428, "c2": 608, "c3": "00428_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 438, "c2": 608, "c3": "00438_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 448, "c2": 608, "c3": "00448_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 458, "c2": 608, "c3": "00458_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 468, "c2": 608, "c3": "00468_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 478, "c2": 608, "c3": "00478_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 488, "c2": 608, "c3": "00488_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 498, "c2": 608, "c3": "00498_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 508, "c2": 608, "c3": "00508_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 518, "c2": 608, "c3": "00518_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 528, "c2": 608, "c3": "00528_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 538, "c2": 608, "c3": "00538_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 548, "c2": 608, "c3": "00548_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 558, "c2": 608, "c3": "00558_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 568, "c2": 608, "c3": "00568_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 578, "c2": 608, "c3": "00578_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 588, "c2": 608, "c3": "00588_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 598, "c2": 608, "c3": "00598_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 608, "c2": 608, "c3": "00608_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 618, "c2": 608, "c3": "00618_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 628, "c2": 608, "c3": "00628_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 638, "c2": 608, "c3": "00638_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 648, "c2": 608, "c3": "00648_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 658, "c2": 608, "c3": "00658_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 668, "c2": 608, "c3": "00668_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 678, "c2": 608, "c3": "00678_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 688, "c2": 608, "c3": "00688_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 698, "c2": 608, "c3": "00698_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 708, "c2": 608, "c3": "00708_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 718, "c2": 608, "c3": "00718_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 728, "c2": 608, "c3": "00728_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 738, "c2": 608, "c3": "00738_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 748, "c2": 608, "c3": "00748_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 758, "c2": 608, "c3": "00758_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 768, "c2": 608, "c3": "00768_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 778, "c2": 608, "c3": "00778_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 788, "c2": 608, "c3": "00788_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 798, "c2": 608, "c3": "00798_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 808, "c2": 608, "c3": "00808_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 818, "c2": 608, "c3": "00818_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 828, "c2": 608, "c3": "00828_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 838, "c2": 608, "c3": "00838_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 848, "c2": 608, "c3": "00848_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 858, "c2": 608, "c3": "00858_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 868, "c2": 608, "c3": "00868_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 878, "c2": 608, "c3": "00878_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 888, "c2": 608, "c3": "00888_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 898, "c2": 608, "c3": "00898_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 908, "c2": 608, "c3": "00908_trig_update", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 918, "c2": 608, "c3": "00918_trig_update", "c5": "Mon Jan 19 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 928, "c2": 608, "c3": "00928_trig_update", "c5": "Thu Jan 29 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 938, "c2": 608, "c3": "00938_trig_update", "c5": "Sun Feb 08 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 948, "c2": 608, "c3": "00948_trig_update", "c5": "Wed Feb 18 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 958, "c2": 608, "c3": "00958_trig_update", "c5": "Sat Feb 28 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 968, "c2": 608, "c3": "00968_trig_update", "c5": "Tue Mar 10 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 978, "c2": 608, "c3": "00978_trig_update", "c5": "Fri Mar 20 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 988, "c2": 608, "c3": "00988_trig_update", "c5": "Mon Mar 30 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 998, "c2": 608, "c3": "00998_trig_update", "c5": "Thu Apr 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 1008, "c2": 708, "c3": "0000800008_trig_update", "c5": null, "c6": null, "c7": null, "c8": null}
 {"c1": 1018, "c2": 708, "c3": "0001800018_trig_update", "c5": null, "c6": null, "c7": null, "c8": null}
(102 rows)

-- -- Test errors thrown on remote side during update
-- ALTER TABLE "S 1"."T 1" ADD CONSTRAINT c2positive CHECK (c2 >= 0);
-- parquet storage can not check duplicate key / conflict
-- INSERT INTO ft1(c1, c2) VALUES(11, 12);  -- duplicate key
-- INSERT INTO ft1(c1, c2) VALUES(11, 12) ON CONFLICT DO NOTHING; -- works
-- INSERT INTO ft1(c1, c2) VALUES(11, 12) ON CONFLICT (c1, c2) DO NOTHING; -- unsupported
-- INSERT INTO ft1(c1, c2) VALUES(11, 12) ON CONFLICT (c1, c2) DO UPDATE SET c3 = 'ffg'; -- unsupported
-- INSERT INTO ft1(c1, c2) VALUES(1111, -2);  -- c2positive
-- UPDATE ft1 SET c2 = -c2 WHERE v->>'c1' = 1;  -- c2positive
-- Test savepoint/rollback behavior
-- parquet_s3_fdw does not support transaction, the expected will not be same as postgres_fdw
--Testcase 355:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   0 |   100
   1 |   100
   4 |   100
   6 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

--Testcase 356:
select (v->>'c2')::int as c2, count(*) from "S 1"."T1" where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

begin;
--Testcase 556:
update ft2 set v = json_build_object('c2', 42, 'c3', v->>'c3') where (v->>'c2')::int = 0;
--Testcase 357:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
   4 |   100
   6 |   100
  42 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

savepoint s1;
--Testcase 557:
update ft2 set v = json_build_object('c2', 44, 'c3', v->>'c3') where (v->>'c2')::int = 4;
--Testcase 358:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
   6 |   100
  42 |   100
  44 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

release savepoint s1;
--Testcase 359:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
   6 |   100
  42 |   100
  44 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

savepoint s2;
--Testcase 558:
update ft2 set  v = json_build_object('c2', 46, 'c3', v->>'c3') where (v->>'c2')::int = 6;
--Testcase 360:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
  42 |   100
  44 |   100
  46 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

rollback to savepoint s2;
--Testcase 361:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
  42 |   100
  44 |   100
  46 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

release savepoint s2;
--Testcase 362:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
  42 |   100
  44 |   100
  46 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

savepoint s3;
-- update ft2 set c2 = -2 where c2 = 42 and v->>'c1' = 10; -- fail on remote side
rollback to savepoint s3;
--Testcase 363:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
  42 |   100
  44 |   100
  46 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

release savepoint s3;
--Testcase 364:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
  42 |   100
  44 |   100
  46 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

-- none of the above is committed yet remotely
--Testcase 365:
select (v->>'c2')::int as c2, count(*) from "S 1"."T1" where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

commit;
--Testcase 366:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2  | count 
-----+-------
   1 |   100
  42 |   100
  44 |   100
  46 |   100
 100 |     2
 101 |     2
 104 |     2
 106 |     2
 201 |     1
 204 |     1
 303 |   100
 403 |     2
 407 |   100
(13 rows)

--Testcase 367:
select (v->>'c2')::int as c2, count(*) from "S 1"."T1" where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

-- VACUUM ANALYZE "S 1"."T1";
-- Above DMLs add data with v->>'c6' as NULL in ft1, so test ORDER BY NULLS LAST and NULLs
-- FIRST behavior here.
-- ORDER BY DESC NULLS LAST options
\set var :PATH_FILENAME'/ported_postgres/ft1_null.parquet'
--Testcase 368:
CREATE FOREIGN TABLE ft1_null (
	v jsonb
) SERVER parquet_s3_srv
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
--Testcase 369:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1_null ORDER BY v->>'c6' DESC NULLS LAST, (v->>'c1')::int8 OFFSET 795 LIMIT 10;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Limit
   Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
         Sort Key: ((ft1_null.v ->> 'c6'::text)) DESC NULLS LAST, (((ft1_null.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1_null
               Output: v, (v ->> 'c6'::text), ((v ->> 'c1'::text))::bigint
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 370:
SELECT * FROM ft1_null ORDER BY v->>'c6' DESC NULLS LAST, (v->>'c1')::int8 OFFSET 795  LIMIT 10;
                                                    v                                                    
---------------------------------------------------------------------------------------------------------
 {"c1": 591, "c2": 1, "c3": "00591", "c5": "Thu Apr 02 00:00:00 1970", "c6": "", "c7": "1", "c8": "foo"}
 {"c1": 593, "c2": 3, "c3": "00593", "c5": "Sat Apr 04 00:00:00 1970", "c6": "", "c7": "3", "c8": "foo"}
 {"c1": 595, "c2": 5, "c3": "00595", "c5": "Mon Apr 06 00:00:00 1970", "c6": "", "c7": "5", "c8": "foo"}
 {"c1": 597, "c2": 7, "c3": "00597", "c5": "Wed Apr 08 00:00:00 1970", "c6": "", "c7": "7", "c8": "foo"}
 {"c1": 599, "c2": 9, "c3": "00599", "c5": "Fri Apr 10 00:00:00 1970", "c6": "", "c7": "9", "c8": "foo"}
 {"c1": 601, "c2": 1, "c3": "00601", "c5": "Fri Jan 02 00:00:00 1970", "c6": "", "c7": "1", "c8": "foo"}
 {"c1": 603, "c2": 3, "c3": "00603", "c5": "Sun Jan 04 00:00:00 1970", "c6": "", "c7": "3", "c8": "foo"}
 {"c1": 605, "c2": 5, "c3": "00605", "c5": "Tue Jan 06 00:00:00 1970", "c6": "", "c7": "5", "c8": "foo"}
 {"c1": 607, "c2": 7, "c3": "00607", "c5": "Thu Jan 08 00:00:00 1970", "c6": "", "c7": "7", "c8": "foo"}
 {"c1": 609, "c2": 9, "c3": "00609", "c5": "Sat Jan 10 00:00:00 1970", "c6": "", "c7": "9", "c8": "foo"}
(10 rows)

-- ORDER BY DESC NULLS FIRST options
--Testcase 371:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1_null ORDER BY v->>'c6' DESC NULLS FIRST, (v->>'c1')::int8 OFFSET 15 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
         Sort Key: ((ft1_null.v ->> 'c6'::text)) DESC, (((ft1_null.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1_null
               Output: v, (v ->> 'c6'::text), ((v ->> 'c1'::text))::bigint
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 372:
SELECT * FROM ft1_null ORDER BY v->>'c6' DESC NULLS FIRST, (v->>'c1')::int8 OFFSET 15 LIMIT 10;
                                                     v                                                      
------------------------------------------------------------------------------------------------------------
 {"c1": 32, "c2": 2, "c3": "00032", "c5": "Mon Feb 02 00:00:00 1970", "c6": "(--;", "c7": "2", "c8": "foo"}
 {"c1": 34, "c2": 4, "c3": "00034", "c5": "Wed Feb 04 00:00:00 1970", "c6": "(--;", "c7": "4", "c8": "foo"}
 {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "(--;", "c7": "6", "c8": "foo"}
 {"c1": 38, "c2": 8, "c3": "00038", "c5": "Sun Feb 08 00:00:00 1970", "c6": "(--;", "c7": "8", "c8": "foo"}
 {"c1": 40, "c2": 0, "c3": "00040", "c5": "Tue Feb 10 00:00:00 1970", "c6": "(--;", "c7": "0", "c8": "foo"}
 {"c1": 42, "c2": 2, "c3": "00042", "c5": "Thu Feb 12 00:00:00 1970", "c6": "(--;", "c7": "2", "c8": "foo"}
 {"c1": 44, "c2": 4, "c3": "00044", "c5": "Sat Feb 14 00:00:00 1970", "c6": "(--;", "c7": "4", "c8": "foo"}
 {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "(--;", "c7": "6", "c8": "foo"}
 {"c1": 48, "c2": 8, "c3": "00048", "c5": "Wed Feb 18 00:00:00 1970", "c6": "(--;", "c7": "8", "c8": "foo"}
 {"c1": 50, "c2": 0, "c3": "00050", "c5": "Fri Feb 20 00:00:00 1970", "c6": "(--;", "c7": "0", "c8": "foo"}
(10 rows)

-- ORDER BY ASC NULLS FIRST options
--Testcase 373:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1_null ORDER BY v->>'c6' ASC NULLS FIRST, (v->>'c1')::int8 OFFSET 15 LIMIT 10;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
         Sort Key: ((ft1_null.v ->> 'c6'::text)) NULLS FIRST, (((ft1_null.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1_null
               Output: v, (v ->> 'c6'::text), ((v ->> 'c1'::text))::bigint
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 374:
SELECT * FROM ft1_null ORDER BY v->>'c6' ASC NULLS FIRST, (v->>'c1')::int8 OFFSET 15 LIMIT 10;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 31, "c2": 1, "c3": "00031", "c5": "Sun Feb 01 00:00:00 1970", "c6": "", "c7": "1", "c8": "foo"}
 {"c1": 33, "c2": 3, "c3": "00033", "c5": "Tue Feb 03 00:00:00 1970", "c6": "", "c7": "3", "c8": "foo"}
 {"c1": 35, "c2": 5, "c3": "00035", "c5": "Thu Feb 05 00:00:00 1970", "c6": "", "c7": "5", "c8": "foo"}
 {"c1": 37, "c2": 7, "c3": "00037", "c5": "Sat Feb 07 00:00:00 1970", "c6": "", "c7": "7", "c8": "foo"}
 {"c1": 39, "c2": 9, "c3": "00039", "c5": "Mon Feb 09 00:00:00 1970", "c6": "", "c7": "9", "c8": "foo"}
 {"c1": 41, "c2": 1, "c3": "00041", "c5": "Wed Feb 11 00:00:00 1970", "c6": "", "c7": "1", "c8": "foo"}
 {"c1": 43, "c2": 3, "c3": "00043", "c5": "Fri Feb 13 00:00:00 1970", "c6": "", "c7": "3", "c8": "foo"}
 {"c1": 45, "c2": 5, "c3": "00045", "c5": "Sun Feb 15 00:00:00 1970", "c6": "", "c7": "5", "c8": "foo"}
 {"c1": 47, "c2": 7, "c3": "00047", "c5": "Tue Feb 17 00:00:00 1970", "c6": "", "c7": "7", "c8": "foo"}
 {"c1": 49, "c2": 9, "c3": "00049", "c5": "Thu Feb 19 00:00:00 1970", "c6": "", "c7": "9", "c8": "foo"}
(10 rows)

-- ===================================================================
-- test check constraints
-- ===================================================================
-- Consistent check constraints provide consistent results
--Testcase 559:
ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c2positive CHECK ((v->>'c2')::int >= 0);
--Testcase 375:
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM ft1 WHERE (v->>'c2')::int < 0;
                       QUERY PLAN                        
---------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  Foreign Scan on public.ft1
         Filter: (((ft1.v ->> 'c2'::text))::integer < 0)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 376:
SELECT count(*) FROM ft1 WHERE (v->>'c2')::int < 0;
 count 
-------
     0
(1 row)

--Testcase 560:
SET constraint_exclusion = 'on';
--Testcase 377:
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM ft1 WHERE (v->>'c2')::int < 0;
           QUERY PLAN           
--------------------------------
 Aggregate
   Output: count(*)
   ->  Result
         One-Time Filter: false
(4 rows)

--Testcase 378:
SELECT count(*) FROM ft1 WHERE (v->>'c2')::int < 0;
 count 
-------
     0
(1 row)

--Testcase 561:
RESET constraint_exclusion;
-- check constraint is enforced on the remote side, not locally
-- INSERT INTO ft1(c1, c2) VALUES(1111, -2);  -- c2positive
-- UPDATE ft1 SET c2 = -c2 WHERE v->>'c1' = 1;  -- c2positive
--Testcase 562:
ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c2positive;
-- But inconsistent check constraints provide inconsistent results
--Testcase 563:
ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c2negative CHECK ((v->>'c2')::int < 0);
--Testcase 379:
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM ft1 WHERE (v->>'c2')::int >= 0;
                        QUERY PLAN                        
----------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  Foreign Scan on public.ft1
         Filter: (((ft1.v ->> 'c2'::text))::integer >= 0)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 380:
SELECT count(*) FROM ft1 WHERE (v->>'c2')::int >= 0;
 count 
-------
  1000
(1 row)

--Testcase 564:
SET constraint_exclusion = 'on';
--Testcase 381:
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM ft1 WHERE (v->>'c2')::int >= 0;
           QUERY PLAN           
--------------------------------
 Aggregate
   Output: count(*)
   ->  Result
         One-Time Filter: false
(4 rows)

--Testcase 382:
SELECT count(*) FROM ft1 WHERE (v->>'c2')::int >= 0;
 count 
-------
     0
(1 row)

--Testcase 565:
RESET constraint_exclusion;
-- local check constraint is not actually enforced
-- INSERT INTO ft1(c1, c2) VALUES(1111, 2);
-- UPDATE ft1 SET c2 = c2 + 1 WHERE v->>'c1' = 1;
--Testcase 566:
ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c2negative;
-- ===================================================================
-- test WITH CHECK OPTION constraints
-- ===================================================================
--Testcase 383:
CREATE FUNCTION row_before_insupd_trigfunc() RETURNS trigger AS $$BEGIN NEW.v := jsonb_set(NEW.v, '{a}', to_jsonb((NEW.v->>'a')::int + 10), false); RETURN NEW; END$$ LANGUAGE plpgsql;
\set var :PATH_FILENAME'/ported_postgres/base_tbl.parquet'
--Testcase 384:
CREATE FOREIGN TABLE base_tbl (v jsonb)
  SERVER parquet_s3_srv OPTIONS (filename :'var', schemaless 'true', key_columns 'a');
--Testcase 385:
CREATE TRIGGER row_before_insupd_trigger BEFORE INSERT OR UPDATE ON base_tbl FOR EACH ROW EXECUTE PROCEDURE row_before_insupd_trigfunc();
--Testcase 386:
CREATE FOREIGN TABLE foreign_tbl (v jsonb)
  SERVER parquet_s3_srv OPTIONS (filename :'var', schemaless 'true', key_columns 'a');
--Testcase 387:
CREATE VIEW rw_view AS SELECT * FROM foreign_tbl
  WHERE (v->>'a')::int < (v->>'b')::int WITH CHECK OPTION;
--Testcase 388:
\d+ rw_view
                          View "public.rw_view"
 Column | Type  | Collation | Nullable | Default | Storage  | Description 
--------+-------+-----------+----------+---------+----------+-------------
 v      | jsonb |           |          |         | extended | 
View definition:
 SELECT foreign_tbl.v
   FROM foreign_tbl
  WHERE ((foreign_tbl.v ->> 'a'::text)::integer) < ((foreign_tbl.v ->> 'b'::text)::integer);
Options: check_option=cascaded

--Testcase 567:
EXPLAIN (VERBOSE, COSTS OFF)
INSERT INTO rw_view VALUES (json_build_object('a', 0, 'b', 5));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1865: ERROR:  parquet_s3_fdw: unsupported feature WITH CHECK OPTION
--Testcase 568:
INSERT INTO rw_view VALUES (json_build_object('a', 0, 'b', 5)); -- should fail
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1867: ERROR:  parquet_s3_fdw: unsupported feature WITH CHECK OPTION
--Testcase 569:
EXPLAIN (VERBOSE, COSTS OFF)
INSERT INTO rw_view VALUES (json_build_object('a', 0, 'b', 15));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1870: ERROR:  parquet_s3_fdw: unsupported feature WITH CHECK OPTION
--Testcase 570:
INSERT INTO rw_view VALUES (json_build_object('a', 0, 'b', 15)); -- ok
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1872: ERROR:  parquet_s3_fdw: unsupported feature WITH CHECK OPTION
--Testcase 571:
SELECT * FROM foreign_tbl;
 v 
---
(0 rows)

--Testcase 572:
EXPLAIN (VERBOSE, COSTS OFF)
UPDATE rw_view SET v = json_build_object('b', (v->>'b')::int + 5);
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1878: ERROR:  parquet_s3_fdw: unsupported feature WITH CHECK OPTION
--Testcase 573:
UPDATE rw_view SET v = json_build_object('b', (v->>'b')::int + 5); -- should fail
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1880: ERROR:  parquet_s3_fdw: unsupported feature WITH CHECK OPTION
--Testcase 574:
EXPLAIN (VERBOSE, COSTS OFF)
UPDATE rw_view SET v = json_build_object('b', (v->>'b')::int + 15);
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1883: ERROR:  parquet_s3_fdw: unsupported feature WITH CHECK OPTION
--Testcase 575:
UPDATE rw_view SET v = json_build_object('b', (v->>'b')::int + 15); -- ok
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1885: ERROR:  parquet_s3_fdw: unsupported feature WITH CHECK OPTION
--Testcase 576:
SELECT * FROM foreign_tbl;
 v 
---
(0 rows)

--Testcase 389:
DROP FOREIGN TABLE foreign_tbl CASCADE;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:1890: NOTICE:  drop cascades to view rw_view
--Testcase 390:
DROP TRIGGER row_before_insupd_trigger ON base_tbl;
--Testcase 391:
DROP FOREIGN TABLE base_tbl;
-- test WCO for partitions
-- Postgres does not support create partition by range of jsonb elemnent value.
-- The test below is skipped.
-- \set var :PATH_FILENAME'/ported_postgres/child_tbl.parquet'
-- --Testcase 392:
-- CREATE FOREIGN TABLE child_tbl (v jsonb)
--   SERVER parquet_s3_srv OPTIONS (filename :'var', schemaless 'true');
-- --Testcase 393:
-- CREATE TRIGGER row_before_insupd_trigger BEFORE INSERT OR UPDATE ON child_tbl FOR EACH ROW EXECUTE PROCEDURE row_before_insupd_trigfunc();
-- --Testcase 394:
-- CREATE FOREIGN TABLE foreign_tbl (v jsonb)
--   SERVER parquet_s3_srv OPTIONS (filename :'var', schemaless 'true');
-- --Testcase 395:
-- CREATE TABLE parent_tbl (v jsonb) PARTITION BY RANGE((v->>'a')::int);
-- ALTER TABLE parent_tbl ATTACH PARTITION foreign_tbl FOR VALUES FROM (0) TO (100);
-- --Testcase 396:
-- CREATE VIEW rw_view AS SELECT * FROM parent_tbl
--   WHERE (v->>'a')::int < (v->>'b')::int WITH CHECK OPTION;
-- --Testcase 397:
-- \d+ rw_view
-- -- EXPLAIN (VERBOSE, COSTS OFF)
-- -- INSERT INTO rw_view VALUES (0, 5);
-- -- INSERT INTO rw_view VALUES (0, 5); -- should fail
-- -- EXPLAIN (VERBOSE, COSTS OFF)
-- -- INSERT INTO rw_view VALUES (0, 15);
-- -- INSERT INTO rw_view VALUES (0, 15); -- ok
-- -- SELECT * FROM foreign_tbl;
-- -- EXPLAIN (VERBOSE, COSTS OFF)
-- -- UPDATE rw_view SET b = b + 5;
-- -- UPDATE rw_view SET b = b + 5; -- should fail
-- -- EXPLAIN (VERBOSE, COSTS OFF)
-- -- UPDATE rw_view SET b = b + 15;
-- -- UPDATE rw_view SET b = b + 15; -- ok
-- -- SELECT * FROM foreign_tbl;
-- --Testcase 398:
-- DROP FOREIGN TABLE foreign_tbl CASCADE;
-- --Testcase 399:
-- DROP TRIGGER row_before_insupd_trigger ON child_tbl;
-- --Testcase 400:
-- DROP TABLE parent_tbl CASCADE;
--Testcase 401:
DROP FUNCTION row_before_insupd_trigfunc;
-- ===================================================================
-- test serial columns (ie, sequence-based defaults)
-- schemaless-mode does not has serial column
-- ===================================================================
\set var :PATH_FILENAME'/ported_postgres/loc1.parquet'
--Testcase 577:
create foreign table loc1 (v jsonb)
  server parquet_s3_srv options(filename :'var', schemaless 'true', key_columns 'f1');
--Testcase 578:
create foreign table rem1 (v jsonb)
  server parquet_s3_srv options(filename :'var', schemaless 'true', key_columns 'f1');
-- select pg_catalog.setval('rem1_f1_seq', 10, false);
--Testcase 579:
insert into loc1 values (json_build_object('f1', 1, 'f2', 'hi'));
--Testcase 580:
insert into rem1 values (json_build_object('f1', 10, 'f2', 'hi remote'));
--Testcase 581:
insert into loc1 values (json_build_object('f1', 2, 'f2', 'bye'));
--Testcase 582:
insert into rem1 values (json_build_object('f1', 11, 'f2', 'bye remote'));
--Testcase 583:
select * from rem1;
               v                
--------------------------------
 {"f1": 1, "f2": "hi"}
 {"f1": 10, "f2": "hi remote"}
 {"f1": 2, "f2": "bye"}
 {"f1": 11, "f2": "bye remote"}
(4 rows)

-- ===================================================================
-- test generated columns
-- schemaless-mode does not has generated column
-- ===================================================================
\set var :PATH_FILENAME'/ported_postgres/gloc1.parquet'
--Testcase 584:
create foreign table gloc1 (
  v JSONB)
  server parquet_s3_srv options(filename :'var', schemaless 'true', key_columns 'a');
--Testcase 585:
create foreign table grem1 (
  v JSONB)
  server parquet_s3_srv options(filename :'var', schemaless 'true', key_columns 'a');
-- explain (verbose, costs off)
-- insert into grem1 (a) values (1), (2);
-- insert into grem1 (a) values (1), (2);
-- explain (verbose, costs off)
-- update grem1 set a = 22 where a = 2;
-- update grem1 set a = 22 where a = 2;
-- select * from gloc1;
-- select * from grem1;
--Testcase 586:
delete from grem1;
-- parquet_s3_fdw does not support copy from
-- -- test copy from
-- copy grem1 from stdin;
-- 1
-- 2
-- \.
-- select * from gloc1;
-- select * from grem1;
-- delete from grem1;
-- parquet_s3_fdw does not support batch insert
-- -- test batch insert
-- alter server loopback options (add batch_size '10');
-- explain (verbose, costs off)
-- insert into grem1 (a) values (1), (2);
-- insert into grem1 (a) values (1), (2);
-- select * from gloc1;
-- select * from grem1;
-- delete from grem1;
-- alter server loopback options (drop batch_size);
-- ===================================================================
-- test local triggers
-- ===================================================================
-- Trigger functions "borrowed" from triggers regress test.
--Testcase 587:
CREATE FUNCTION trigger_func() RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
	RAISE NOTICE 'trigger_func(%) called: action = %, when = %, level = %',
		TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
	RETURN NULL;
END;$$;
--Testcase 588:
CREATE TRIGGER trig_stmt_before BEFORE DELETE OR INSERT OR UPDATE ON rem1
	FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func();
--Testcase 589:
CREATE TRIGGER trig_stmt_after AFTER DELETE OR INSERT OR UPDATE ON rem1
	FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func();
--Testcase 590:
CREATE OR REPLACE FUNCTION trigger_data()  RETURNS trigger
LANGUAGE plpgsql AS $$

declare
	oldnew text[];
	relid text;
    argstr text;
begin

	relid := TG_relid::regclass;
	argstr := '';
	for i in 0 .. TG_nargs - 1 loop
		if i > 0 then
			argstr := argstr || ', ';
		end if;
		argstr := argstr || TG_argv[i];
	end loop;

    RAISE NOTICE '%(%) % % % ON %',
		tg_name, argstr, TG_when, TG_level, TG_OP, relid;
    oldnew := '{}'::text[];
	if TG_OP != 'INSERT' then
		oldnew := array_append(oldnew, format('OLD: %s', OLD));
	end if;

	if TG_OP != 'DELETE' then
		oldnew := array_append(oldnew, format('NEW: %s', NEW));
	end if;

    RAISE NOTICE '%', array_to_string(oldnew, ',');

	if TG_OP = 'DELETE' then
		return OLD;
	else
		return NEW;
	end if;
end;
$$;
-- Test basic functionality
--Testcase 591:
CREATE TRIGGER trig_row_before
BEFORE INSERT OR UPDATE OR DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 592:
CREATE TRIGGER trig_row_after
AFTER INSERT OR UPDATE OR DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 593:
delete from rem1;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trigger_func(<NULL>) called: action = DELETE, when = BEFORE, level = STATEMENT
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""hi""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  OLD: ("{""f1"": 10, ""f2"": ""hi remote""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  OLD: ("{""f1"": 2, ""f2"": ""bye""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  OLD: ("{""f1"": 11, ""f2"": ""bye remote""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trig_row_after(23, skidoo) AFTER ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""hi""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trig_row_after(23, skidoo) AFTER ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  OLD: ("{""f1"": 10, ""f2"": ""hi remote""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trig_row_after(23, skidoo) AFTER ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  OLD: ("{""f1"": 2, ""f2"": ""bye""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trig_row_after(23, skidoo) AFTER ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  OLD: ("{""f1"": 11, ""f2"": ""bye remote""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2087: NOTICE:  trigger_func(<NULL>) called: action = DELETE, when = AFTER, level = STATEMENT
--Testcase 594:
insert into rem1 values (json_build_object('f1', 1, 'f2', 'insert'));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2089: NOTICE:  trigger_func(<NULL>) called: action = INSERT, when = BEFORE, level = STATEMENT
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2089: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2089: NOTICE:  NEW: ("{""f1"": 1, ""f2"": ""insert""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2089: NOTICE:  trig_row_after(23, skidoo) AFTER ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2089: NOTICE:  NEW: ("{""f1"": 1, ""f2"": ""insert""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2089: NOTICE:  trigger_func(<NULL>) called: action = INSERT, when = AFTER, level = STATEMENT
--Testcase 595:
update rem1 set v = json_build_object('f2', 'update') where (v->>'f1')::int = 1;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2091: NOTICE:  trigger_func(<NULL>) called: action = UPDATE, when = BEFORE, level = STATEMENT
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2091: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2091: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""insert""}"),NEW: ("{""f2"": ""update""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2091: NOTICE:  trig_row_after(23, skidoo) AFTER ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2091: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""insert""}"),NEW: ("{""f2"": ""update""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2091: NOTICE:  trigger_func(<NULL>) called: action = UPDATE, when = AFTER, level = STATEMENT
--Testcase 596:
update rem1 set v = json_build_object('f2', (v->>'f2') || (v->>'f2'));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2093: NOTICE:  trigger_func(<NULL>) called: action = UPDATE, when = BEFORE, level = STATEMENT
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2093: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2093: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""update""}"),NEW: ("{""f2"": ""updateupdate""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2093: NOTICE:  trig_row_after(23, skidoo) AFTER ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2093: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""update""}"),NEW: ("{""f2"": ""updateupdate""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2093: NOTICE:  trigger_func(<NULL>) called: action = UPDATE, when = AFTER, level = STATEMENT
-- cleanup
--Testcase 597:
DROP TRIGGER trig_row_before ON rem1;
--Testcase 598:
DROP TRIGGER trig_row_after ON rem1;
--Testcase 599:
DROP TRIGGER trig_stmt_before ON rem1;
--Testcase 600:
DROP TRIGGER trig_stmt_after ON rem1;
--Testcase 601:
DELETE from rem1;
-- Test multiple AFTER ROW triggers on a foreign table
--Testcase 602:
CREATE TRIGGER trig_row_after1
AFTER INSERT OR UPDATE OR DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 603:
CREATE TRIGGER trig_row_after2
AFTER INSERT OR UPDATE OR DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 604:
insert into rem1 values (json_build_object('f1', 1, 'f2', 'insert'));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2121: NOTICE:  trig_row_after1(23, skidoo) AFTER ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2121: NOTICE:  NEW: ("{""f1"": 1, ""f2"": ""insert""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2121: NOTICE:  trig_row_after2(23, skidoo) AFTER ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2121: NOTICE:  NEW: ("{""f1"": 1, ""f2"": ""insert""}")
--Testcase 605:
update rem1 set v = json_build_object('f2', 'update') where (v->>'f1')::int = 1;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2123: NOTICE:  trig_row_after1(23, skidoo) AFTER ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2123: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""insert""}"),NEW: ("{""f2"": ""update""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2123: NOTICE:  trig_row_after2(23, skidoo) AFTER ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2123: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""insert""}"),NEW: ("{""f2"": ""update""}")
--Testcase 606:
update rem1 set v = json_build_object('f2', (v->>'f2') || (v->>'f2'));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2125: NOTICE:  trig_row_after1(23, skidoo) AFTER ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2125: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""update""}"),NEW: ("{""f2"": ""updateupdate""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2125: NOTICE:  trig_row_after2(23, skidoo) AFTER ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2125: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""update""}"),NEW: ("{""f2"": ""updateupdate""}")
--Testcase 607:
delete from rem1;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2127: NOTICE:  trig_row_after1(23, skidoo) AFTER ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2127: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""updateupdate""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2127: NOTICE:  trig_row_after2(23, skidoo) AFTER ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2127: NOTICE:  OLD: ("{""f1"": 1, ""f2"": ""updateupdate""}")
-- cleanup
--Testcase 608:
DROP TRIGGER trig_row_after1 ON rem1;
--Testcase 609:
DROP TRIGGER trig_row_after2 ON rem1;
-- Test WHEN conditions
--Testcase 610:
CREATE TRIGGER trig_row_before_insupd
BEFORE INSERT OR UPDATE ON rem1
FOR EACH ROW
WHEN (NEW.v->>'f2' like '%update%')
EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 611:
CREATE TRIGGER trig_row_after_insupd
AFTER INSERT OR UPDATE ON rem1
FOR EACH ROW
WHEN (NEW.v->>'f2' like '%update%')
EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- Insert or update not matching: nothing happens
--Testcase 612:
INSERT INTO rem1 values (json_build_object('f1', 1, 'f2', 'insert'));
--Testcase 613:
UPDATE rem1 set v = json_build_object('f2', 'test');
-- Insert or update matching: triggers are fired
--Testcase 614:
INSERT INTO rem1 values (json_build_object('f1', 2, 'f2', 'update'));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2159: NOTICE:  trig_row_before_insupd(23, skidoo) BEFORE ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2159: NOTICE:  NEW: ("{""f1"": 2, ""f2"": ""update""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2159: NOTICE:  trig_row_after_insupd(23, skidoo) AFTER ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2159: NOTICE:  NEW: ("{""f1"": 2, ""f2"": ""update""}")
--Testcase 615:
UPDATE rem1 set v = json_build_object('f2', 'update update') where v->>'f1' = '2';
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2161: NOTICE:  trig_row_before_insupd(23, skidoo) BEFORE ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2161: NOTICE:  OLD: ("{""f1"": 2, ""f2"": ""update""}"),NEW: ("{""f2"": ""update update""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2161: NOTICE:  trig_row_after_insupd(23, skidoo) AFTER ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2161: NOTICE:  OLD: ("{""f1"": 2, ""f2"": ""update""}"),NEW: ("{""f2"": ""update update""}")
--Testcase 616:
CREATE TRIGGER trig_row_before_delete
BEFORE DELETE ON rem1
FOR EACH ROW
WHEN (OLD.v->>'f2' like '%update%')
EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 617:
CREATE TRIGGER trig_row_after_delete
AFTER DELETE ON rem1
FOR EACH ROW
WHEN (OLD.v->>'f2' like '%update%')
EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- Trigger is fired for f1=2, not for f1=1
--Testcase 618:
DELETE FROM rem1;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2179: NOTICE:  trig_row_before_delete(23, skidoo) BEFORE ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2179: NOTICE:  OLD: ("{""f1"": 2, ""f2"": ""update update""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2179: NOTICE:  trig_row_after_delete(23, skidoo) AFTER ROW DELETE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2179: NOTICE:  OLD: ("{""f1"": 2, ""f2"": ""update update""}")
-- cleanup
--Testcase 619:
DROP TRIGGER trig_row_before_insupd ON rem1;
--Testcase 620:
DROP TRIGGER trig_row_after_insupd ON rem1;
--Testcase 621:
DROP TRIGGER trig_row_before_delete ON rem1;
--Testcase 622:
DROP TRIGGER trig_row_after_delete ON rem1;
-- Test various RETURN statements in BEFORE triggers.
--Testcase 623:
CREATE FUNCTION trig_row_before_insupdate() RETURNS TRIGGER AS $$
  BEGIN
    NEW.v := jsonb_set(NEW.v, '{f2}', to_jsonb(NEW.v->>'f2' || ' triggered !'), false);
    RETURN NEW;
  END
$$ language plpgsql;
--Testcase 624:
CREATE TRIGGER trig_row_before_insupd
BEFORE INSERT OR UPDATE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trig_row_before_insupdate();
-- The new values should have 'triggered' appended
--Testcase 625:
INSERT INTO rem1 values (json_build_object('f1', 1, 'f2', 'insert'));
--Testcase 626:
SELECT * from loc1;
                   v                   
---------------------------------------
 {"f1": 1, "f2": "insert triggered !"}
(1 row)

--Testcase 627:
INSERT INTO rem1 values (json_build_object('f1', 2, 'f2', 'insert'));
--Testcase 628:
SELECT * from loc1;
                   v                   
---------------------------------------
 {"f1": 1, "f2": "insert triggered !"}
 {"f1": 2, "f2": "insert triggered !"}
(2 rows)

--Testcase 629:
UPDATE rem1 set v = json_build_object('f2', '');
--Testcase 630:
SELECT * from loc1;
                v                
---------------------------------
 {"f1": 1, "f2": " triggered !"}
 {"f1": 2, "f2": " triggered !"}
(2 rows)

--Testcase 631:
UPDATE rem1 set v = json_build_object('f2', 'skidoo');
--Testcase 632:
SELECT * from loc1;
                   v                   
---------------------------------------
 {"f1": 1, "f2": "skidoo triggered !"}
 {"f1": 2, "f2": "skidoo triggered !"}
(2 rows)

--Testcase 633:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f1', 10);
                       QUERY PLAN                       
--------------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f1', 10), v, rem1.*
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 634:
UPDATE rem1 set v = json_build_object('f1', 10);
--Testcase 635:
SELECT * from loc1;
                   v                   
---------------------------------------
 {"f1": 1, "f2": "skidoo triggered !"}
 {"f1": 2, "f2": "skidoo triggered !"}
(2 rows)

--Testcase 636:
DELETE FROM rem1;
-- Add a second trigger, to check that the changes are propagated correctly
-- from trigger to trigger
--Testcase 637:
CREATE TRIGGER trig_row_before_insupd2
BEFORE INSERT OR UPDATE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trig_row_before_insupdate();
--Testcase 638:
INSERT INTO rem1 values (json_build_object('f1', 1, 'f2', 'insert'));
--Testcase 639:
SELECT * from loc1;
                         v                         
---------------------------------------------------
 {"f1": 1, "f2": "insert triggered ! triggered !"}
(1 row)

--Testcase 640:
INSERT INTO rem1 values (json_build_object('f1', 2, 'f2', 'insert'));
--Testcase 641:
SELECT * from loc1;
                         v                         
---------------------------------------------------
 {"f1": 1, "f2": "insert triggered ! triggered !"}
 {"f1": 2, "f2": "insert triggered ! triggered !"}
(2 rows)

--Testcase 642:
UPDATE rem1 set v = json_build_object('f2', '');
--Testcase 643:
SELECT * from loc1;
                      v                      
---------------------------------------------
 {"f1": 1, "f2": " triggered ! triggered !"}
 {"f1": 2, "f2": " triggered ! triggered !"}
(2 rows)

--Testcase 644:
UPDATE rem1 set v = json_build_object('f2', 'skidoo');
--Testcase 645:
SELECT * from loc1;
                         v                         
---------------------------------------------------
 {"f1": 1, "f2": "skidoo triggered ! triggered !"}
 {"f1": 2, "f2": "skidoo triggered ! triggered !"}
(2 rows)

--Testcase 646:
DROP TRIGGER trig_row_before_insupd ON rem1;
--Testcase 647:
DROP TRIGGER trig_row_before_insupd2 ON rem1;
--Testcase 648:
DELETE from rem1;
--Testcase 649:
INSERT INTO rem1 VALUES (json_build_object('f1', 1, 'f2', 'test'));
-- Test with a trigger returning NULL
--Testcase 650:
CREATE FUNCTION trig_null() RETURNS TRIGGER AS $$
  BEGIN
    RETURN NULL;
  END
$$ language plpgsql;
--Testcase 651:
CREATE TRIGGER trig_null
BEFORE INSERT OR UPDATE OR DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trig_null();
-- Nothing should have changed.
--Testcase 652:
INSERT INTO rem1 VALUES (json_build_object('f1', 2, 'f2', 'test2'));
--Testcase 653:
SELECT * from loc1;
            v            
-------------------------
 {"f1": 1, "f2": "test"}
(1 row)

--Testcase 654:
UPDATE rem1 SET v = json_build_object('f2', 'test2');
--Testcase 655:
SELECT * from loc1;
            v            
-------------------------
 {"f1": 1, "f2": "test"}
(1 row)

--Testcase 656:
DELETE from rem1;
--Testcase 657:
SELECT * from loc1;
            v            
-------------------------
 {"f1": 1, "f2": "test"}
(1 row)

--Testcase 658:
DROP TRIGGER trig_null ON rem1;
--Testcase 659:
DELETE from rem1;
-- Test a combination of local and remote triggers
--Testcase 660:
CREATE TRIGGER trig_row_before
BEFORE INSERT OR UPDATE OR DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 661:
CREATE TRIGGER trig_row_after
AFTER INSERT OR UPDATE OR DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 662:
CREATE TRIGGER trig_local_before BEFORE INSERT OR UPDATE ON loc1
FOR EACH ROW EXECUTE PROCEDURE trig_row_before_insupdate();
--Testcase 663:
INSERT INTO rem1 VALUES (json_build_object('f1', 12, 'f2', 'test'));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2323: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2323: NOTICE:  NEW: ("{""f1"": 12, ""f2"": ""test""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2323: NOTICE:  trig_row_after(23, skidoo) AFTER ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2323: NOTICE:  NEW: ("{""f1"": 12, ""f2"": ""test""}")
--Testcase 664:
UPDATE rem1 SET v = json_build_object('f2', 'testo');
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2325: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2325: NOTICE:  OLD: ("{""f1"": 12, ""f2"": ""test""}"),NEW: ("{""f2"": ""testo""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2325: NOTICE:  trig_row_after(23, skidoo) AFTER ROW UPDATE ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2325: NOTICE:  OLD: ("{""f1"": 12, ""f2"": ""test""}"),NEW: ("{""f2"": ""testo""}")
-- Test returning a system attribute
--Testcase 665:
INSERT INTO rem1 VALUES (json_build_object('f1', 13, 'f2', 'test'));
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2329: NOTICE:  trig_row_before(23, skidoo) BEFORE ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2329: NOTICE:  NEW: ("{""f1"": 13, ""f2"": ""test""}")
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2329: NOTICE:  trig_row_after(23, skidoo) AFTER ROW INSERT ON rem1
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:2329: NOTICE:  NEW: ("{""f1"": 13, ""f2"": ""test""}")
-- cleanup
--Testcase 666:
DROP TRIGGER trig_row_before ON rem1;
--Testcase 667:
DROP TRIGGER trig_row_after ON rem1;
--Testcase 668:
DROP TRIGGER trig_local_before ON loc1;
-- Test direct foreign table modification functionality
--Testcase 669:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 670:
EXPLAIN (verbose, costs off)
DELETE FROM rem1 WHERE false;     -- currently can't be pushed down
           QUERY PLAN           
--------------------------------
 Delete on public.rem1
   ->  Result
         Output: v
         One-Time Filter: false
(4 rows)

-- Test with statement-level triggers
--Testcase 671:
CREATE TRIGGER trig_stmt_before
	BEFORE DELETE OR INSERT OR UPDATE ON rem1
	FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func();
--Testcase 672:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f2', '');
                   QUERY PLAN                   
------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f2', ''), v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 673:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 674:
DROP TRIGGER trig_stmt_before ON rem1;
--Testcase 675:
CREATE TRIGGER trig_stmt_after
	AFTER DELETE OR INSERT OR UPDATE ON rem1
	FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func();
--Testcase 676:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f2', '');
                   QUERY PLAN                   
------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f2', ''), v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 677:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 678:
DROP TRIGGER trig_stmt_after ON rem1;
-- Test with row-level ON INSERT triggers
--Testcase 679:
CREATE TRIGGER trig_row_before_insert
BEFORE INSERT ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 680:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f2', '');
                   QUERY PLAN                   
------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f2', ''), v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 681:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 682:
DROP TRIGGER trig_row_before_insert ON rem1;
--Testcase 683:
CREATE TRIGGER trig_row_after_insert
AFTER INSERT ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 684:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f2', ' ');
                   QUERY PLAN                    
-------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f2', ' '), v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 685:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 686:
DROP TRIGGER trig_row_after_insert ON rem1;
-- Test with row-level ON UPDATE triggers
--Testcase 687:
CREATE TRIGGER trig_row_before_update
BEFORE UPDATE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 688:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f2', '');        -- can't be pushed down
                       QUERY PLAN                       
--------------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f2', ''), v, rem1.*
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 689:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 690:
DROP TRIGGER trig_row_before_update ON rem1;
--Testcase 691:
CREATE TRIGGER trig_row_after_update
AFTER UPDATE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 692:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f2', '');         -- can't be pushed down
                       QUERY PLAN                       
--------------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f2', ''), v, rem1.*
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 693:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 694:
DROP TRIGGER trig_row_after_update ON rem1;
-- Test with row-level ON DELETE triggers
--Testcase 695:
CREATE TRIGGER trig_row_before_delete
BEFORE DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 696:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f2', '');
                   QUERY PLAN                   
------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f2', ''), v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 697:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;                 -- can't be pushed down
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v, rem1.*
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 698:
DROP TRIGGER trig_row_before_delete ON rem1;
--Testcase 699:
CREATE TRIGGER trig_row_after_delete
AFTER DELETE ON rem1
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
--Testcase 700:
EXPLAIN (verbose, costs off)
UPDATE rem1 set v = json_build_object('f2', '');
                   QUERY PLAN                   
------------------------------------------------
 Update on public.rem1
   ->  Foreign Scan on public.rem1
         Output: json_build_object('f2', ''), v
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 701:
EXPLAIN (verbose, costs off)
DELETE FROM rem1;                 -- can't be pushed down
            QUERY PLAN             
-----------------------------------
 Delete on public.rem1
   ->  Foreign Scan on public.rem1
         Output: v, rem1.*
         Reader: Single File
         Row groups: 1
(5 rows)

--Testcase 702:
DROP TRIGGER trig_row_after_delete ON rem1;
-- ===================================================================
-- test inheritance features
-- schemaless mode has only one column ==> can not test
-- ===================================================================
-- CREATE TABLE a (aa TEXT);
-- CREATE TABLE loct (aa TEXT, bb TEXT);
-- ALTER TABLE a SET (autovacuum_enabled = 'false');
-- ALTER TABLE loct SET (autovacuum_enabled = 'false');
-- CREATE FOREIGN TABLE b (bb TEXT) INHERITS (a)
--   SERVER loopback OPTIONS (table_name 'loct');
-- INSERT INTO a(aa) VALUES('aaa');
-- INSERT INTO a(aa) VALUES('aaaa');
-- INSERT INTO a(aa) VALUES('aaaaa');
-- INSERT INTO b(aa) VALUES('bbb');
-- INSERT INTO b(aa) VALUES('bbbb');
-- INSERT INTO b(aa) VALUES('bbbbb');
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- UPDATE a SET aa = 'zzzzzz' WHERE aa LIKE 'aaaa%';
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- UPDATE b SET aa = 'new';
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- UPDATE a SET aa = 'newtoo';
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- DELETE FROM a;
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- DROP TABLE a CASCADE;
-- DROP TABLE loct;
-- Check SELECT FOR UPDATE/SHARE with an inherited source table
-- create table loct1 (f1 int, f2 int, f3 int);
-- create table loct2 (f1 int, f2 int, f3 int);
-- alter table loct1 set (autovacuum_enabled = 'false');
-- alter table loct2 set (autovacuum_enabled = 'false');
-- create table foo (f1 int, f2 int);
-- create foreign table foo2 (f3 int) inherits (foo)
--   server loopback options (table_name 'loct1');
-- create table bar (f1 int, f2 int);
-- create foreign table bar2 (f3 int) inherits (bar)
--   server loopback options (table_name 'loct2');
-- alter table foo set (autovacuum_enabled = 'false');
-- alter table bar set (autovacuum_enabled = 'false');
-- insert into foo values(1,1);
-- insert into foo values(3,3);
-- insert into foo2 values(2,2,2);
-- insert into foo2 values(4,4,4);
-- insert into bar values(1,11);
-- insert into bar values(2,22);
-- insert into bar values(6,66);
-- insert into bar2 values(3,33,33);
-- insert into bar2 values(4,44,44);
-- insert into bar2 values(7,77,77);
-- explain (verbose, costs off)
-- select * from bar where f1 in (select f1 from foo) for update;
-- select * from bar where f1 in (select f1 from foo) for update;
-- explain (verbose, costs off)
-- select * from bar where f1 in (select f1 from foo) for share;
-- select * from bar where f1 in (select f1 from foo) for share;
-- -- Now check SELECT FOR UPDATE/SHARE with an inherited source table,
-- -- where the parent is itself a foreign table
-- create table loct4 (f1 int, f2 int, f3 int);
-- create foreign table foo2child (f3 int) inherits (foo2)
--   server loopback options (table_name 'loct4');
-- explain (verbose, costs off)
-- select * from bar where f1 in (select f1 from foo2) for share;
-- select * from bar where f1 in (select f1 from foo2) for share;
-- drop foreign table foo2child;
-- -- And with a local child relation of the foreign table parent
-- create table foo2child (f3 int) inherits (foo2);
-- explain (verbose, costs off)
-- select * from bar where f1 in (select f1 from foo2) for share;
-- select * from bar where f1 in (select f1 from foo2) for share;
-- drop table foo2child;
-- -- Check UPDATE with inherited target and an inherited source table
-- explain (verbose, costs off)
-- update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
-- update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
-- select tableoid::regclass, * from bar order by 1,2;
-- -- Check UPDATE with inherited target and an appendrel subquery
-- explain (verbose, costs off)
-- update bar set f2 = f2 + 100
-- from
--   ( select f1 from foo union all select f1+3 from foo ) ss
-- where bar.f1 = ss.f1;
-- update bar set f2 = f2 + 100
-- from
--   ( select f1 from foo union all select f1+3 from foo ) ss
-- where bar.f1 = ss.f1;
-- select tableoid::regclass, * from bar order by 1,2;
-- Test forcing the remote server to produce sorted data for a merge join,
-- but the foreign table is an inheritance child.
-- truncate table loct1;
-- truncate table only foo;
-- \set num_rows_foo 2000
-- insert into loct1 select generate_series(0, :num_rows_foo, 2), generate_series(0, :num_rows_foo, 2), generate_series(0, :num_rows_foo, 2);
-- insert into foo select generate_series(1, :num_rows_foo, 2), generate_series(1, :num_rows_foo, 2);
-- SET enable_hashjoin to false;
-- SET enable_nestloop to false;
-- alter foreign table foo2 options (use_remote_estimate 'true');
-- create index i_loct1_f1 on loct1(f1);
-- create index i_foo_f1 on foo(f1);
-- analyze foo;
-- analyze loct1;
-- inner join; expressions in the clauses appear in the equivalence class list
-- explain (verbose, costs off)
-- 	select foo.f1, loct1.f1 from foo join loct1 on (foo.f1 = loct1.f1) order by foo.f2 offset 10 limit 10;
-- select foo.f1, loct1.f1 from foo join loct1 on (foo.f1 = loct1.f1) order by foo.f2 offset 10 limit 10;
-- outer join; expressions in the clauses do not appear in equivalence class
-- list but no output change as compared to the previous query
-- explain (verbose, costs off)
-- 	select foo.f1, loct1.f1 from foo left join loct1 on (foo.f1 = loct1.f1) order by foo.f2 offset 10 limit 10;
-- select foo.f1, loct1.f1 from foo left join loct1 on (foo.f1 = loct1.f1) order by foo.f2 offset 10 limit 10;
-- RESET enable_hashjoin;
-- RESET enable_nestloop;
-- Test that WHERE CURRENT OF is not supported
-- begin;
-- declare c cursor for select * from bar where f1 = 7;
-- fetch from c;
-- update bar set f2 = null where current of c;
-- rollback;
-- explain (verbose, costs off)
-- delete from foo where f1 < 5 returning *;
-- delete from foo where f1 < 5 returning *;
-- explain (verbose, costs off)
-- update bar set f2 = f2 + 100 returning *;
-- update bar set f2 = f2 + 100 returning *;
-- Test that UPDATE/DELETE with inherited target works with row-level triggers
-- CREATE TRIGGER trig_row_before
-- BEFORE UPDATE OR DELETE ON bar2
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- CREATE TRIGGER trig_row_after
-- AFTER UPDATE OR DELETE ON bar2
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- explain (verbose, costs off)
-- update bar set f2 = f2 + 100;
-- update bar set f2 = f2 + 100;
-- explain (verbose, costs off)
-- delete from bar where f2 < 400;
-- delete from bar where f2 < 400;
-- cleanup
-- drop table foo cascade;
-- drop table bar cascade;
-- drop table loct1;
-- drop table loct2;
-- Test pushing down UPDATE/DELETE joins to the remote server
-- create table parent (a int, b text);
-- create table loct1 (a int, b text);
-- create table loct2 (a int, b text);
-- create foreign table remt1 (a int, b text)
--   server loopback options (table_name 'loct1');
-- create foreign table remt2 (a int, b text)
--   server loopback options (table_name 'loct2');
-- alter foreign table remt1 inherit parent;
-- insert into remt1 values (1, 'foo');
-- insert into remt1 values (2, 'bar');
-- insert into remt2 values (1, 'foo');
-- insert into remt2 values (2, 'bar');
-- analyze remt1;
-- analyze remt2;
-- explain (verbose, costs off)
-- update parent set b = parent.b || remt2.b from remt2 where parent.a = remt2.a returning *;
-- update parent set b = parent.b || remt2.b from remt2 where parent.a = remt2.a returning *;
-- explain (verbose, costs off)
-- delete from parent using remt2 where parent.a = remt2.a returning parent;
-- delete from parent using remt2 where parent.a = remt2.a returning parent;
-- cleanup
-- drop foreign table remt1;
-- drop foreign table remt2;
-- drop table loct1;
-- drop table loct2;
-- drop table parent;
-- ===================================================================
-- test tuple routing for foreign-table partitions
-- ===================================================================
-- Test insert tuple routing
-- create table itrtest (a int, b text) partition by list (a);
-- create table loct1 (a int check (a in (1)), b text);
-- create foreign table remp1 (a int check (a in (1)), b text) server loopback options (table_name 'loct1');
-- create table loct2 (a int check (a in (2)), b text);
-- create foreign table remp2 (b text, a int check (a in (2))) server loopback options (table_name 'loct2');
-- alter table itrtest attach partition remp1 for values in (1);
-- alter table itrtest attach partition remp2 for values in (2);
-- insert into itrtest values (1, 'foo');
-- insert into itrtest values (1, 'bar') returning *;
-- insert into itrtest values (2, 'baz');
-- insert into itrtest values (2, 'qux') returning *;
-- insert into itrtest values (1, 'test1'), (2, 'test2') returning *;
-- select tableoid::regclass, * FROM itrtest;
-- select tableoid::regclass, * FROM remp1;
-- select tableoid::regclass, * FROM remp2;
-- delete from itrtest;
-- create unique index loct1_idx on loct1 (a);
-- DO NOTHING without an inference specification is supported
-- insert into itrtest values (1, 'foo') on conflict do nothing returning *;
-- insert into itrtest values (1, 'foo') on conflict do nothing returning *;
-- But other cases are not supported
-- insert into itrtest values (1, 'bar') on conflict (a) do nothing;
-- insert into itrtest values (1, 'bar') on conflict (a) do update set b = excluded.b;
-- select tableoid::regclass, * FROM itrtest;
-- delete from itrtest;
-- drop index loct1_idx;
-- Test that remote triggers work with insert tuple routing
-- create function br_insert_trigfunc() returns trigger as $$
-- begin
-- 	new.b := new.b || ' triggered !';
-- 	return new;
-- end
-- $$ language plpgsql;
-- create trigger loct1_br_insert_trigger before insert on loct1
-- 	for each row execute procedure br_insert_trigfunc();
-- create trigger loct2_br_insert_trigger before insert on loct2
-- 	for each row execute procedure br_insert_trigfunc();
-- The new values are concatenated with ' triggered !'
-- insert into itrtest values (1, 'foo') returning *;
-- insert into itrtest values (2, 'qux') returning *;
-- insert into itrtest values (1, 'test1'), (2, 'test2') returning *;
-- with result as (insert into itrtest values (1, 'test1'), (2, 'test2') returning *) select * from result;
-- drop trigger loct1_br_insert_trigger on loct1;
-- drop trigger loct2_br_insert_trigger on loct2;
-- drop table itrtest;
-- drop table loct1;
-- drop table loct2;
-- Test update tuple routing
-- create table utrtest (a int, b text) partition by list (a);
-- create table loct (a int check (a in (1)), b text);
-- create foreign table remp (a int check (a in (1)), b text) server loopback options (table_name 'loct');
-- create table locp (a int check (a in (2)), b text);
-- alter table utrtest attach partition remp for values in (1);
-- alter table utrtest attach partition locp for values in (2);
-- insert into utrtest values (1, 'foo');
-- insert into utrtest values (2, 'qux');
-- select tableoid::regclass, * FROM utrtest;
-- select tableoid::regclass, * FROM remp;
-- select tableoid::regclass, * FROM locp;
-- It's not allowed to move a row from a partition that is foreign to another
-- update utrtest set a = 2 where b = 'foo' returning *;
-- But the reverse is allowed
-- update utrtest set a = 1 where b = 'qux' returning *;
-- select tableoid::regclass, * FROM utrtest;
-- select tableoid::regclass, * FROM remp;
-- select tableoid::regclass, * FROM locp;
-- The executor should not let unexercised FDWs shut down
-- update utrtest set a = 1 where b = 'foo';
-- Test that remote triggers work with update tuple routing
-- create trigger loct_br_insert_trigger before insert on loct
-- 	for each row execute procedure br_insert_trigfunc();
-- delete from utrtest;
-- insert into utrtest values (2, 'qux');
-- Check case where the foreign partition is a subplan target rel
-- explain (verbose, costs off)
-- update utrtest set a = 1 where a = 1 or a = 2 returning *;
-- The new values are concatenated with ' triggered !'
-- update utrtest set a = 1 where a = 1 or a = 2 returning *;
-- delete from utrtest;
-- insert into utrtest values (2, 'qux');
-- Check case where the foreign partition isn't a subplan target rel
-- explain (verbose, costs off)
-- update utrtest set a = 1 where a = 2 returning *;
-- The new values are concatenated with ' triggered !'
-- update utrtest set a = 1 where a = 2 returning *;
-- drop trigger loct_br_insert_trigger on loct;
-- We can move rows to a foreign partition that has been updated already,
-- but can't move rows to a foreign partition that hasn't been updated yet
-- delete from utrtest;
-- insert into utrtest values (1, 'foo');
-- insert into utrtest values (2, 'qux');
-- Test the former case:
-- with a direct modification plan
-- explain (verbose, costs off)
-- update utrtest set a = 1 returning *;
-- update utrtest set a = 1 returning *;
-- delete from utrtest;
-- insert into utrtest values (1, 'foo');
-- insert into utrtest values (2, 'qux');
-- with a non-direct modification plan
-- explain (verbose, costs off)
-- update utrtest set a = 1 from (values (1), (2)) s(x) where a = s.x returning *;
-- update utrtest set a = 1 from (values (1), (2)) s(x) where a = s.x returning *;
-- Change the definition of utrtest so that the foreign partition get updated
-- after the local partition
-- delete from utrtest;
-- alter table utrtest detach partition remp;
-- drop foreign table remp;
-- alter table loct drop constraint loct_a_check;
-- alter table loct add check (a in (3));
-- create foreign table remp (a int check (a in (3)), b text) server loopback options (table_name 'loct');
-- alter table utrtest attach partition remp for values in (3);
-- insert into utrtest values (2, 'qux');
-- insert into utrtest values (3, 'xyzzy');
-- Test the latter case:
-- with a direct modification plan
-- explain (verbose, costs off)
-- update utrtest set a = 3 returning *;
-- update utrtest set a = 3 returning *; -- ERROR
-- with a non-direct modification plan
-- explain (verbose, costs off)
-- update utrtest set a = 3 from (values (2), (3)) s(x) where a = s.x returning *;
-- update utrtest set a = 3 from (values (2), (3)) s(x) where a = s.x returning *; -- ERROR
-- drop table utrtest;
-- drop table loct;
-- Test copy tuple routing
-- create table ctrtest (a int, b text) partition by list (a);
-- create table loct1 (a int check (a in (1)), b text);
-- create foreign table remp1 (a int check (a in (1)), b text) server loopback options (table_name 'loct1');
-- create table loct2 (a int check (a in (2)), b text);
-- create foreign table remp2 (b text, a int check (a in (2))) server loopback options (table_name 'loct2');
-- alter table ctrtest attach partition remp1 for values in (1);
-- alter table ctrtest attach partition remp2 for values in (2);
-- copy ctrtest from stdin;
-- 1	foo
-- 2	qux
-- \.
-- select tableoid::regclass, * FROM ctrtest;
-- select tableoid::regclass, * FROM remp1;
-- select tableoid::regclass, * FROM remp2;
-- Copying into foreign partitions directly should work as well
-- copy remp1 from stdin;
-- 1	bar
-- \.
-- select tableoid::regclass, * FROM remp1;
-- drop table ctrtest;
-- drop table loct1;
-- drop table loct2;
-- ===================================================================
-- test COPY FROM
-- ===================================================================
-- create table loc2 (f1 int, f2 text);
-- alter table loc2 set (autovacuum_enabled = 'false');
-- create foreign table rem2 (f1 int, f2 text) server loopback options(table_name 'loc2');
-- Test basic functionality
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- delete from rem2;
-- Test check constraints
-- alter table loc2 add constraint loc2_f1positive check (f1 >= 0);
-- alter foreign table rem2 add constraint rem2_f1positive check (f1 >= 0);
-- check constraint is enforced on the remote side, not locally
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- copy rem2 from stdin; -- ERROR
-- -1	xyzzy
-- \.
-- select * from rem2;
-- alter foreign table rem2 drop constraint rem2_f1positive;
-- alter table loc2 drop constraint loc2_f1positive;
-- delete from rem2;
-- Test local triggers
-- create trigger trig_stmt_before before insert on rem2
-- 	for each statement execute procedure trigger_func();
-- create trigger trig_stmt_after after insert on rem2
-- 	for each statement execute procedure trigger_func();
-- create trigger trig_row_before before insert on rem2
-- 	for each row execute procedure trigger_data(23,'skidoo');
-- create trigger trig_row_after after insert on rem2
-- 	for each row execute procedure trigger_data(23,'skidoo');
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_row_before on rem2;
-- drop trigger trig_row_after on rem2;
-- drop trigger trig_stmt_before on rem2;
-- drop trigger trig_stmt_after on rem2;
-- delete from rem2;
-- create trigger trig_row_before_insert before insert on rem2
-- 	for each row execute procedure trig_row_before_insupdate();
-- The new values are concatenated with ' triggered !'
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_row_before_insert on rem2;
-- delete from rem2;
-- create trigger trig_null before insert on rem2
-- 	for each row execute procedure trig_null();
-- Nothing happens
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_null on rem2;
-- delete from rem2;
-- Test remote triggers
-- create trigger trig_row_before_insert before insert on loc2
-- 	for each row execute procedure trig_row_before_insupdate();
-- The new values are concatenated with ' triggered !'
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_row_before_insert on loc2;
-- delete from rem2;
-- create trigger trig_null before insert on loc2
-- 	for each row execute procedure trig_null();
-- Nothing happens
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_null on loc2;
-- delete from rem2;
-- Test a combination of local and remote triggers
-- create trigger rem2_trig_row_before before insert on rem2
-- 	for each row execute procedure trigger_data(23,'skidoo');
-- create trigger rem2_trig_row_after after insert on rem2
-- 	for each row execute procedure trigger_data(23,'skidoo');
-- create trigger loc2_trig_row_before_insert before insert on loc2
-- 	for each row execute procedure trig_row_before_insupdate();
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger rem2_trig_row_before on rem2;
-- drop trigger rem2_trig_row_after on rem2;
-- drop trigger loc2_trig_row_before_insert on loc2;
-- delete from rem2;
-- test COPY FROM with foreign table created in the same transaction
-- create table loc3 (f1 int, f2 text);
-- begin;
-- create foreign table rem3 (f1 int, f2 text)
-- 	server loopback options(table_name 'loc3');
-- copy rem3 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- commit;
-- select * from rem3;
-- drop foreign table rem3;
-- drop table loc3;
-- ===================================================================
-- test for TRUNCATE
-- ===================================================================
-- CREATE TABLE tru_rtable0 (id int primary key);
-- CREATE FOREIGN TABLE tru_ftable (id int)
--        SERVER loopback OPTIONS (table_name 'tru_rtable0');
-- INSERT INTO tru_rtable0 (SELECT x FROM generate_series(1,10) x);
-- CREATE TABLE tru_ptable (id int) PARTITION BY HASH(id);
-- CREATE TABLE tru_ptable__p0 PARTITION OF tru_ptable
--                             FOR VALUES WITH (MODULUS 2, REMAINDER 0);
-- CREATE TABLE tru_rtable1 (id int primary key);
-- CREATE FOREIGN TABLE tru_ftable__p1 PARTITION OF tru_ptable
--                                     FOR VALUES WITH (MODULUS 2, REMAINDER 1)
--        SERVER loopback OPTIONS (table_name 'tru_rtable1');
-- INSERT INTO tru_ptable (SELECT x FROM generate_series(11,20) x);
-- CREATE TABLE tru_pk_table(id int primary key);
-- CREATE TABLE tru_fk_table(fkey int references tru_pk_table(id));
-- INSERT INTO tru_pk_table (SELECT x FROM generate_series(1,10) x);
-- INSERT INTO tru_fk_table (SELECT x % 10 + 1 FROM generate_series(5,25) x);
-- CREATE FOREIGN TABLE tru_pk_ftable (id int)
--        SERVER loopback OPTIONS (table_name 'tru_pk_table');
-- CREATE TABLE tru_rtable_parent (id int);
-- CREATE TABLE tru_rtable_child (id int);
-- CREATE FOREIGN TABLE tru_ftable_parent (id int)
--        SERVER loopback OPTIONS (table_name 'tru_rtable_parent');
-- CREATE FOREIGN TABLE tru_ftable_child () INHERITS (tru_ftable_parent)
--        SERVER loopback OPTIONS (table_name 'tru_rtable_child');
-- INSERT INTO tru_rtable_parent (SELECT x FROM generate_series(1,8) x);
-- INSERT INTO tru_rtable_child  (SELECT x FROM generate_series(10, 18) x);
-- normal truncate
-- SELECT sum(id) FROM tru_ftable;        -- 55
-- TRUNCATE tru_ftable;
-- SELECT count(*) FROM tru_rtable0;		-- 0
-- SELECT count(*) FROM tru_ftable;		-- 0
-- 'truncatable' option
-- ALTER SERVER loopback OPTIONS (ADD truncatable 'false');
-- TRUNCATE tru_ftable;			-- error
-- ALTER FOREIGN TABLE tru_ftable OPTIONS (ADD truncatable 'true');
-- TRUNCATE tru_ftable;			-- accepted
-- ALTER FOREIGN TABLE tru_ftable OPTIONS (SET truncatable 'false');
-- TRUNCATE tru_ftable;			-- error
-- ALTER SERVER loopback OPTIONS (DROP truncatable);
-- ALTER FOREIGN TABLE tru_ftable OPTIONS (SET truncatable 'false');
-- TRUNCATE tru_ftable;			-- error
-- ALTER FOREIGN TABLE tru_ftable OPTIONS (SET truncatable 'true');
-- TRUNCATE tru_ftable;			-- accepted
-- partitioned table with both local and foreign tables as partitions
-- SELECT sum(id) FROM tru_ptable;        -- 155
-- TRUNCATE tru_ptable;
-- SELECT count(*) FROM tru_ptable;		-- 0
-- SELECT count(*) FROM tru_ptable__p0;	-- 0
-- SELECT count(*) FROM tru_ftable__p1;	-- 0
-- SELECT count(*) FROM tru_rtable1;		-- 0
-- 'CASCADE' option
-- SELECT sum(id) FROM tru_pk_ftable;      -- 55
-- TRUNCATE tru_pk_ftable;	-- failed by FK reference
-- TRUNCATE tru_pk_ftable CASCADE;
-- SELECT count(*) FROM tru_pk_ftable;    -- 0
-- SELECT count(*) FROM tru_fk_table;		-- also truncated,0
-- truncate two tables at a command
-- INSERT INTO tru_ftable (SELECT x FROM generate_series(1,8) x);
-- INSERT INTO tru_pk_ftable (SELECT x FROM generate_series(3,10) x);
-- SELECT count(*) from tru_ftable; -- 8
-- SELECT count(*) from tru_pk_ftable; -- 8
-- TRUNCATE tru_ftable, tru_pk_ftable CASCADE;
-- SELECT count(*) from tru_ftable; -- 0
-- SELECT count(*) from tru_pk_ftable; -- 0
-- truncate with ONLY clause
-- Since ONLY is specified, the table tru_ftable_child that inherits
-- tru_ftable_parent locally is not truncated.
-- TRUNCATE ONLY tru_ftable_parent;
-- SELECT sum(id) FROM tru_ftable_parent;  -- 126
-- TRUNCATE tru_ftable_parent;
-- SELECT count(*) FROM tru_ftable_parent; -- 0
-- in case when remote table has inherited children
-- CREATE TABLE tru_rtable0_child () INHERITS (tru_rtable0);
-- INSERT INTO tru_rtable0 (SELECT x FROM generate_series(5,9) x);
-- INSERT INTO tru_rtable0_child (SELECT x FROM generate_series(10,14) x);
-- SELECT sum(id) FROM tru_ftable;   -- 95
-- Both parent and child tables in the foreign server are truncated
-- even though ONLY is specified because ONLY has no effect
-- when truncating a foreign table.
-- TRUNCATE ONLY tru_ftable;
-- SELECT count(*) FROM tru_ftable;   -- 0
-- INSERT INTO tru_rtable0 (SELECT x FROM generate_series(21,25) x);
-- INSERT INTO tru_rtable0_child (SELECT x FROM generate_series(26,30) x);
-- SELECT sum(id) FROM tru_ftable;		-- 255
-- TRUNCATE tru_ftable;			-- truncate both of parent and child
-- SELECT count(*) FROM tru_ftable;    -- 0
-- cleanup
-- DROP FOREIGN TABLE tru_ftable_parent, tru_ftable_child, tru_pk_ftable,tru_ftable__p1,tru_ftable;
-- DROP TABLE tru_rtable0, tru_rtable1, tru_ptable, tru_ptable__p0, tru_pk_table, tru_fk_table,
-- tru_rtable_parent,tru_rtable_child, tru_rtable0_child;
-- ===================================================================
-- test IMPORT FOREIGN SCHEMA
-- ===================================================================
\set var '\"':PATH_FILENAME'\/ported_postgres\"'
--Testcase 402:
CREATE SCHEMA import_dest1;
IMPORT FOREIGN SCHEMA :var FROM SERVER parquet_s3_srv INTO import_dest1 OPTIONS (sorted 'c1', schemaless 'true');
--Testcase 403:
\det+ import_dest1.*
                                                                   List of foreign tables
    Schema    |   Table    |     Server     |                                           FDW options                                           | Description 
--------------+------------+----------------+-------------------------------------------------------------------------------------------------+-------------
 import_dest1 | T0         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T0.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | T1         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T1.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | T2         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T2.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | T3         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T3.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | T4         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T4.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | base_tbl   | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/base_tbl.parquet', sorted 'c1', schemaless 'true')   | 
 import_dest1 | child_tbl  | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/child_tbl.parquet', sorted 'c1', schemaless 'true')  | 
 import_dest1 | ft1        | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/ft1.parquet', sorted 'c1', schemaless 'true')        | 
 import_dest1 | ft1_null   | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/ft1_null.parquet', sorted 'c1', schemaless 'true')   | 
 import_dest1 | gloc1      | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/gloc1.parquet', sorted 'c1', schemaless 'true')      | 
 import_dest1 | loc1       | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loc1.parquet', sorted 'c1', schemaless 'true')       | 
 import_dest1 | local_tbl  | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/local_tbl.parquet', sorted 'c1', schemaless 'true')  | 
 import_dest1 | loct       | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct.parquet', sorted 'c1', schemaless 'true')       | 
 import_dest1 | loct1      | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct1.parquet', sorted 'c1', schemaless 'true')      | 
 import_dest1 | loct2      | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct2.parquet', sorted 'c1', schemaless 'true')      | 
 import_dest1 | loct3      | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct3.parquet', sorted 'c1', schemaless 'true')      | 
 import_dest1 | loct3_1    | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct3_1.parquet', sorted 'c1', schemaless 'true')    | 
 import_dest1 | loct4      | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct4.parquet', sorted 'c1', schemaless 'true')      | 
 import_dest1 | loct4_1    | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct4_1.parquet', sorted 'c1', schemaless 'true')    | 
 import_dest1 | loct_empty | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct_empty.parquet', sorted 'c1', schemaless 'true') | 
(20 rows)

--Testcase 404:
\d import_dest1.*
                Foreign table "import_dest1.T0"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T0.parquet', sorted 'c1', schemaless 'true')

                Foreign table "import_dest1.T1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T1.parquet', sorted 'c1', schemaless 'true')

                Foreign table "import_dest1.T2"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T2.parquet', sorted 'c1', schemaless 'true')

                Foreign table "import_dest1.T3"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T3.parquet', sorted 'c1', schemaless 'true')

                Foreign table "import_dest1.T4"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T4.parquet', sorted 'c1', schemaless 'true')

             Foreign table "import_dest1.base_tbl"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/base_tbl.parquet', sorted 'c1', schemaless 'true')

            Foreign table "import_dest1.child_tbl"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/child_tbl.parquet', sorted 'c1', schemaless 'true')

               Foreign table "import_dest1.ft1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/ft1.parquet', sorted 'c1', schemaless 'true')

             Foreign table "import_dest1.ft1_null"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/ft1_null.parquet', sorted 'c1', schemaless 'true')

              Foreign table "import_dest1.gloc1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/gloc1.parquet', sorted 'c1', schemaless 'true')

               Foreign table "import_dest1.loc1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loc1.parquet', sorted 'c1', schemaless 'true')

            Foreign table "import_dest1.local_tbl"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/local_tbl.parquet', sorted 'c1', schemaless 'true')

               Foreign table "import_dest1.loct"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct.parquet', sorted 'c1', schemaless 'true')

              Foreign table "import_dest1.loct1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct1.parquet', sorted 'c1', schemaless 'true')

              Foreign table "import_dest1.loct2"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct2.parquet', sorted 'c1', schemaless 'true')

              Foreign table "import_dest1.loct3"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct3.parquet', sorted 'c1', schemaless 'true')

             Foreign table "import_dest1.loct3_1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct3_1.parquet', sorted 'c1', schemaless 'true')

              Foreign table "import_dest1.loct4"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct4.parquet', sorted 'c1', schemaless 'true')

             Foreign table "import_dest1.loct4_1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct4_1.parquet', sorted 'c1', schemaless 'true')

            Foreign table "import_dest1.loct_empty"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct_empty.parquet', sorted 'c1', schemaless 'true')

-- Options
-- CREATE SCHEMA import_dest2;
-- IMPORT FOREIGN SCHEMA import_source FROM SERVER loopback INTO import_dest2
--   OPTIONS (import_default 'true');
-- \det+ import_dest2.*
-- \d import_dest2.*
-- CREATE SCHEMA import_dest3;
-- IMPORT FOREIGN SCHEMA import_source FROM SERVER loopback INTO import_dest3
--   OPTIONS (import_collate 'false', import_generated 'false', import_not_null 'false');
-- \det+ import_dest3.*
-- \d import_dest3.*
-- Check LIMIT TO and EXCEPT
-- CREATE SCHEMA import_dest4;
-- IMPORT FOREIGN SCHEMA import_source LIMIT TO (t1, nonesuch, t4_part)
--   FROM SERVER loopback INTO import_dest4;
-- \det+ import_dest4.*
-- IMPORT FOREIGN SCHEMA import_source EXCEPT (t1, "x 4", nonesuch, t4_part)
--   FROM SERVER loopback INTO import_dest4;
-- \det+ import_dest4.*
-- Assorted error cases
-- IMPORT FOREIGN SCHEMA import_source FROM SERVER loopback INTO import_dest4;
-- IMPORT FOREIGN SCHEMA nonesuch FROM SERVER loopback INTO import_dest4;
-- IMPORT FOREIGN SCHEMA nonesuch FROM SERVER loopback INTO notthere;
-- IMPORT FOREIGN SCHEMA nonesuch FROM SERVER nowhere INTO notthere;
-- Check case of a type present only on the remote server.
-- We can fake this by dropping the type locally in our transaction.
-- CREATE TYPE "Colors" AS ENUM ('red', 'green', 'blue');
-- CREATE TABLE import_source.t5 (c1 int, c2 text collate "C", "Col" "Colors");
-- CREATE SCHEMA import_dest5;
-- BEGIN;
-- DROP TYPE "Colors" CASCADE;
-- IMPORT FOREIGN SCHEMA import_source LIMIT TO (t5)
--   FROM SERVER loopback INTO import_dest5;  -- ERROR
-- ROLLBACK;
-- BEGIN;
-- CREATE SERVER fetch101 FOREIGN DATA WRAPPER postgres_fdw OPTIONS( fetch_size '101' );
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'fetch101'
-- AND srvoptions @> array['fetch_size=101'];
-- ALTER SERVER fetch101 OPTIONS( SET fetch_size '202' );
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'fetch101'
-- AND srvoptions @> array['fetch_size=101'];
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'fetch101'
-- AND srvoptions @> array['fetch_size=202'];
-- CREATE FOREIGN TABLE table30000 ( x int ) SERVER fetch101 OPTIONS ( fetch_size '30000' );
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30000'::regclass
-- AND ftoptions @> array['fetch_size=30000'];
-- ALTER FOREIGN TABLE table30000 OPTIONS ( SET fetch_size '60000');
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30000'::regclass
-- AND ftoptions @> array['fetch_size=30000'];
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30000'::regclass
-- AND ftoptions @> array['fetch_size=60000'];
-- ROLLBACK;
-- ===================================================================
-- test partitionwise joins
-- ===================================================================
-- SET enable_partitionwise_join=on;
-- CREATE TABLE fprt1 (a int, b int, c varchar) PARTITION BY RANGE(a);
-- CREATE TABLE fprt1_p1 (LIKE fprt1);
-- CREATE TABLE fprt1_p2 (LIKE fprt1);
-- ALTER TABLE fprt1_p1 SET (autovacuum_enabled = 'false');
-- ALTER TABLE fprt1_p2 SET (autovacuum_enabled = 'false');
-- INSERT INTO fprt1_p1 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 249, 2) i;
-- INSERT INTO fprt1_p2 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(250, 499, 2) i;
-- CREATE FOREIGN TABLE ftprt1_p1 PARTITION OF fprt1 FOR VALUES FROM (0) TO (250)
-- 	SERVER loopback OPTIONS (table_name 'fprt1_p1', use_remote_estimate 'true');
-- CREATE FOREIGN TABLE ftprt1_p2 PARTITION OF fprt1 FOR VALUES FROM (250) TO (500)
-- 	SERVER loopback OPTIONS (TABLE_NAME 'fprt1_p2');
-- ANALYZE fprt1;
-- ANALYZE fprt1_p1;
-- ANALYZE fprt1_p2;
-- CREATE TABLE fprt2 (a int, b int, c varchar) PARTITION BY RANGE(b);
-- CREATE TABLE fprt2_p1 (LIKE fprt2);
-- CREATE TABLE fprt2_p2 (LIKE fprt2);
-- ALTER TABLE fprt2_p1 SET (autovacuum_enabled = 'false');
-- ALTER TABLE fprt2_p2 SET (autovacuum_enabled = 'false');
-- INSERT INTO fprt2_p1 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 249, 3) i;
-- INSERT INTO fprt2_p2 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(250, 499, 3) i;
-- CREATE FOREIGN TABLE ftprt2_p1 (b int, c varchar, a int)
-- 	SERVER loopback OPTIONS (table_name 'fprt2_p1', use_remote_estimate 'true');
-- ALTER TABLE fprt2 ATTACH PARTITION ftprt2_p1 FOR VALUES FROM (0) TO (250);
-- CREATE FOREIGN TABLE ftprt2_p2 PARTITION OF fprt2 FOR VALUES FROM (250) TO (500)
-- 	SERVER loopback OPTIONS (table_name 'fprt2_p2', use_remote_estimate 'true');
-- ANALYZE fprt2;
-- ANALYZE fprt2_p1;
-- ANALYZE fprt2_p2;
-- inner join three tables
-- EXPLAIN (COSTS OFF)
-- SELECT t1.a,t2.b,t3.c FROM fprt1 t1 INNER JOIN fprt2 t2 ON (t1.a = t2.b) INNER JOIN fprt1 t3 ON (t2.b = t3.a) WHERE t1.a % 25 =0 ORDER BY 1,2,3;
-- SELECT t1.a,t2.b,t3.c FROM fprt1 t1 INNER JOIN fprt2 t2 ON (t1.a = t2.b) INNER JOIN fprt1 t3 ON (t2.b = t3.a) WHERE t1.a % 25 =0 ORDER BY 1,2,3;
-- left outer join + nullable clause
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT t1.a,t2.b,t2.c FROM fprt1 t1 LEFT JOIN (SELECT * FROM fprt2 WHERE a < 10) t2 ON (t1.a = t2.b and t1.b = t2.a) WHERE t1.a < 10 ORDER BY 1,2,3;
-- SELECT t1.a,t2.b,t2.c FROM fprt1 t1 LEFT JOIN (SELECT * FROM fprt2 WHERE a < 10) t2 ON (t1.a = t2.b and t1.b = t2.a) WHERE t1.a < 10 ORDER BY 1,2,3;
-- with whole-row reference; partitionwise join does not apply
-- EXPLAIN (COSTS OFF)
-- SELECT t1.wr, t2.wr FROM (SELECT t1 wr, a FROM fprt1 t1 WHERE t1.a % 25 = 0) t1 FULL JOIN (SELECT t2 wr, b FROM fprt2 t2 WHERE t2.b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY 1,2;
-- SELECT t1.wr, t2.wr FROM (SELECT t1 wr, a FROM fprt1 t1 WHERE t1.a % 25 = 0) t1 FULL JOIN (SELECT t2 wr, b FROM fprt2 t2 WHERE t2.b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY 1,2;
-- join with lateral reference
-- EXPLAIN (COSTS OFF)
-- SELECT t1.a,t1.b FROM fprt1 t1, LATERAL (SELECT t2.a, t2.b FROM fprt2 t2 WHERE t1.a = t2.b AND t1.b = t2.a) q WHERE t1.a%25 = 0 ORDER BY 1,2;
-- SELECT t1.a,t1.b FROM fprt1 t1, LATERAL (SELECT t2.a, t2.b FROM fprt2 t2 WHERE t1.a = t2.b AND t1.b = t2.a) q WHERE t1.a%25 = 0 ORDER BY 1,2;
-- with PHVs, partitionwise join selected but no join pushdown
-- EXPLAIN (COSTS OFF)
-- SELECT t1.a, t1.phv, t2.b, t2.phv FROM (SELECT 't1_phv' phv, * FROM fprt1 WHERE a % 25 = 0) t1 FULL JOIN (SELECT 't2_phv' phv, * FROM fprt2 WHERE b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY t1.a, t2.b;
-- SELECT t1.a, t1.phv, t2.b, t2.phv FROM (SELECT 't1_phv' phv, * FROM fprt1 WHERE a % 25 = 0) t1 FULL JOIN (SELECT 't2_phv' phv, * FROM fprt2 WHERE b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY t1.a, t2.b;
-- test FOR UPDATE; partitionwise join does not apply
-- EXPLAIN (COSTS OFF)
-- SELECT t1.a, t2.b FROM fprt1 t1 INNER JOIN fprt2 t2 ON (t1.a = t2.b) WHERE t1.a % 25 = 0 ORDER BY 1,2 FOR UPDATE OF t1;
-- SELECT t1.a, t2.b FROM fprt1 t1 INNER JOIN fprt2 t2 ON (t1.a = t2.b) WHERE t1.a % 25 = 0 ORDER BY 1,2 FOR UPDATE OF t1;
-- RESET enable_partitionwise_join;
-- ===================================================================
-- test partitionwise aggregates
-- ===================================================================
-- CREATE TABLE pagg_tab (a int, b int, c text) PARTITION BY RANGE(a);
-- CREATE TABLE pagg_tab_p1 (LIKE pagg_tab);
-- CREATE TABLE pagg_tab_p2 (LIKE pagg_tab);
-- CREATE TABLE pagg_tab_p3 (LIKE pagg_tab);
-- INSERT INTO pagg_tab_p1 SELECT i % 30, i % 50, to_char(i/30, 'FM0000') FROM generate_series(1, 3000) i WHERE (i % 30) < 10;
-- INSERT INTO pagg_tab_p2 SELECT i % 30, i % 50, to_char(i/30, 'FM0000') FROM generate_series(1, 3000) i WHERE (i % 30) < 20 and (i % 30) >= 10;
-- INSERT INTO pagg_tab_p3 SELECT i % 30, i % 50, to_char(i/30, 'FM0000') FROM generate_series(1, 3000) i WHERE (i % 30) < 30 and (i % 30) >= 20;
-- Create foreign partitions
-- CREATE FOREIGN TABLE fpagg_tab_p1 PARTITION OF pagg_tab FOR VALUES FROM (0) TO (10) SERVER loopback OPTIONS (table_name 'pagg_tab_p1');
-- CREATE FOREIGN TABLE fpagg_tab_p2 PARTITION OF pagg_tab FOR VALUES FROM (10) TO (20) SERVER loopback OPTIONS (table_name 'pagg_tab_p2');
-- CREATE FOREIGN TABLE fpagg_tab_p3 PARTITION OF pagg_tab FOR VALUES FROM (20) TO (30) SERVER loopback OPTIONS (table_name 'pagg_tab_p3');
-- ANALYZE pagg_tab;
-- ANALYZE fpagg_tab_p1;
-- ANALYZE fpagg_tab_p2;
-- ANALYZE fpagg_tab_p3;
-- When GROUP BY clause matches with PARTITION KEY.
-- Plan with partitionwise aggregates is disabled
-- SET enable_partitionwise_aggregate TO false;
-- EXPLAIN (COSTS OFF)
-- SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- Plan with partitionwise aggregates is enabled
-- SET enable_partitionwise_aggregate TO true;
-- EXPLAIN (COSTS OFF)
-- SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- Check with whole-row reference
-- Should have all the columns in the target list for the given relation
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT a, count(t1) FROM pagg_tab t1 GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- SELECT a, count(t1) FROM pagg_tab t1 GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- When GROUP BY clause does not match with PARTITION KEY.
-- EXPLAIN (COSTS OFF)
-- SELECT b, avg(a), max(a), count(*) FROM pagg_tab GROUP BY b HAVING sum(a) < 700 ORDER BY 1;
-- ===================================================================
-- access rights and superuser
-- ===================================================================
-- Non-superuser cannot create a FDW without a password in the connstr
-- CREATE ROLE regress_nosuper NOSUPERUSER;
-- GRANT USAGE ON FOREIGN DATA WRAPPER postgres_fdw TO regress_nosuper;
-- SET ROLE regress_nosuper;
-- SHOW is_superuser;
-- This will be OK, we can create the FDW
-- DO $d$
--     BEGIN
--         EXECUTE $$CREATE SERVER loopback_nopw FOREIGN DATA WRAPPER postgres_fdw
--             OPTIONS (dbname '$$||current_database()||$$',
--                      port '$$||current_setting('port')||$$'
--             )$$;
--     END;
-- $d$;
-- But creation of user mappings for non-superusers should fail
-- CREATE USER MAPPING FOR public SERVER loopback_nopw;
-- CREATE USER MAPPING FOR CURRENT_USER SERVER loopback_nopw;
-- CREATE FOREIGN TABLE ft1_nopw (
-- 	c1 int NOT NULL,
-- 	c2 int NOT NULL,
-- 	c3 text,
-- 	c4 timestamptz,
-- 	c5 timestamp,
-- 	c6 varchar(10),
-- 	c7 char(10) default 'ft1',
-- 	c8 user_enum
-- ) SERVER loopback_nopw OPTIONS (schema_name 'public', table_name 'ft1');
-- SELECT 1 FROM ft1_nopw LIMIT 1;
-- If we add a password to the connstr it'll fail, because we don't allow passwords
-- in connstrs only in user mappings.
-- DO $d$
--     BEGIN
--         EXECUTE $$ALTER SERVER loopback_nopw OPTIONS (ADD password 'dummypw')$$;
--     END;
-- $d$;
-- If we add a password for our user mapping instead, we should get a different
-- error because the password wasn't actually *used* when we run with trust auth.
--
-- This won't work with installcheck, but neither will most of the FDW checks.
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (ADD password 'dummypw');
-- SELECT 1 FROM ft1_nopw LIMIT 1;
-- Unpriv user cannot make the mapping passwordless
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (ADD password_required 'false');
-- SELECT 1 FROM ft1_nopw LIMIT 1;
-- RESET ROLE;
-- But the superuser can
-- ALTER USER MAPPING FOR regress_nosuper SERVER loopback_nopw OPTIONS (ADD password_required 'false');
-- SET ROLE regress_nosuper;
-- Should finally work now
-- SELECT 1 FROM ft1_nopw LIMIT 1;
-- unpriv user also cannot set sslcert / sslkey on the user mapping
-- first set password_required so we see the right error messages
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (SET password_required 'true');
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (ADD sslcert 'foo.crt');
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (ADD sslkey 'foo.key');
-- We're done with the role named after a specific user and need to check the
-- changes to the public mapping.
-- DROP USER MAPPING FOR CURRENT_USER SERVER loopback_nopw;
-- This will fail again as it'll resolve the user mapping for public, which
-- lacks password_required=false
-- SELECT * FROM ft1_nopw LIMIT 1;
-- RESET ROLE;
-- The user mapping for public is passwordless and lacks the password_required=false
-- mapping option, but will work because the current user is a superuser.
-- SELECT * FROM ft1_nopw LIMIT 1;
-- cleanup
-- DROP USER MAPPING FOR public SERVER loopback_nopw;
-- DROP OWNED BY regress_nosuper;
-- DROP ROLE regress_nosuper;
-- Clean-up
-- RESET enable_partitionwise_aggregate;
-- Two-phase transactions are not supported.
-- BEGIN;
-- SELECT count(*) FROM ft1;
-- error here
-- PREPARE TRANSACTION 'fdw_tpc';
-- ROLLBACK;
-- ===================================================================
-- reestablish new connection
-- ===================================================================
-- Change application_name of remote connection to special one
-- so that we can easily terminate the connection later.
-- ALTER SERVER parquet_s3_srv OPTIONS (application_name 'fdw_retry_check');
-- If debug_discard_caches is active, it results in
-- dropping remote connections after every transaction, making it
-- impossible to test termination meaningfully.  So turn that off
-- for this test.
-- SET debug_discard_caches = 0;
-- Make sure we have a remote connection.
-- SELECT 1 FROM ft1 LIMIT 1;
-- Terminate the remote connection and wait for the termination to complete.
-- SELECT pg_terminate_backend(pid, 180000) FROM pg_stat_activity
-- 	WHERE application_name = 'fdw_retry_check';
-- This query should detect the broken connection when starting new remote
-- transaction, reestablish new connection, and then succeed.
-- BEGIN;
-- SELECT 1 FROM ft1 LIMIT 1;
-- If we detect the broken connection when starting a new remote
-- subtransaction, we should fail instead of establishing a new connection.
-- Terminate the remote connection and wait for the termination to complete.
-- SELECT pg_terminate_backend(pid, 180000) FROM pg_stat_activity
-- 	WHERE application_name = 'fdw_retry_check';
-- SAVEPOINT s;
-- The text of the error might vary across platforms, so only show SQLSTATE.
-- \set VERBOSITY sqlstate
-- SELECT 1 FROM ft1 LIMIT 1;    -- should fail
-- \set VERBOSITY default
-- COMMIT;
-- RESET debug_discard_caches;
-- =============================================================================
-- test connection invalidation cases and parquet_s3_fdw_get_connections function
-- with local parquet file (not on minio/s3 servers). It haven't server and connection.
-- =============================================================================
-- Let's ensure to close all the existing cached connections.
--Testcase 405:
SELECT 1 FROM parquet_s3_fdw_disconnect_all();
 ?column? 
----------
        1
(1 row)

-- No cached connections, so no records should be output.
--Testcase 406:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;
 server_name 
-------------
(0 rows)

-- This test case is for closing the connection in pgfdw_xact_callback
-- BEGIN;
-- Connection xact depth becomes 1 i.e. the connection is in midst of the xact.
--Testcase 407:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

--Testcase 408:
SELECT 1 FROM ft7 LIMIT 1;
 ?column? 
----------
        1
(1 row)

-- List all the existing cached connections. parquet_s3_srv and parquet_s3_srv_3 should be
-- output.
--Testcase 409:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;  -- return 0 rows if not use minio/s3 servers.
 server_name 
-------------
(0 rows)

-- Connections are not closed at the end of the alter and drop statements.
-- That's because the connections are in midst of this xact,
-- they are just marked as invalid in pgfdw_inval_callback.
--Testcase 703:
ALTER SERVER parquet_s3_srv OPTIONS (ADD use_remote_estimate 'off');
--Testcase 410:
DROP SERVER parquet_s3_srv_3 CASCADE;
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:3515: NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to user mapping for public on server parquet_s3_srv_3
drop cascades to foreign table ft7
-- List all the existing cached connections. parquet_s3_srv and parquet_s3_srv_3
-- should be output as invalid connections. Also the server name for
-- parquet_s3_srv_3 should be NULL because the server was dropped.
--Testcase 411:
SELECT * FROM parquet_s3_fdw_get_connections() ORDER BY 1;  -- return 0 rows if not use minio/s3 servers.
 server_name | valid 
-------------+-------
(0 rows)

-- The invalid connections get closed in pgfdw_xact_callback during commit.
-- COMMIT;
-- All cached connections were closed while committing above xact, so no
-- records should be output.
-- SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;
-- =======================================================================
-- test parquet_s3_fdw_disconnect and parquet_s3_fdw_disconnect_all functions
-- with local parquet file (not on minio/s3 servers). It haven't server and connection.
-- =======================================================================
-- BEGIN;
-- Let's ensure to close all the existing cached connections.
--Testcase 412:
SELECT 1 FROM parquet_s3_fdw_disconnect_all();
 ?column? 
----------
        1
(1 row)

-- Ensure to cache parquet_s3_srv connection.
--Testcase 413:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

-- Ensure to cache parquet_s3_srv_2 connection.
--Testcase 414:
SELECT 1 FROM ft6 LIMIT 1;
 ?column? 
----------
        1
(1 row)

-- List all the existing cached connections. parquet_s3_srv and parquet_s3_srv_2 should be
-- output.
--Testcase 415:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;  -- return 0 rows if not use minio/s3 servers.
 server_name 
-------------
(0 rows)

-- Issue a warning and return false as parquet_s3_srv connection is still in use and
-- can not be closed.
-- SELECT parquet_s3_fdw_disconnect('parquet_s3_srv');
-- List all the existing cached connections. parquet_s3_srv and parquet_s3_srv_2 should be
-- output.
--Testcase 416:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;  -- return 0 rows if not use minio/s3 servers.
 server_name 
-------------
(0 rows)

-- Return false as connections are still in use, warnings are issued.
-- But disable warnings temporarily because the order of them is not stable.
-- SET client_min_messages = 'ERROR';
-- SELECT parquet_s3_fdw_disconnect_all();
-- RESET client_min_messages;
-- COMMIT;
-- Ensure that parquet_s3_srv_2 connection is closed.
--Testcase 417:
SELECT 1 FROM parquet_s3_fdw_disconnect('parquet_s3_srv_2');
 ?column? 
----------
        1
(1 row)

--Testcase 418:
SELECT server_name FROM parquet_s3_fdw_get_connections() WHERE server_name = 'parquet_s3_srv_2';
 server_name 
-------------
(0 rows)

-- Return false as parquet_s3_srv_2 connection is closed already.
--Testcase 419:
SELECT parquet_s3_fdw_disconnect('parquet_s3_srv_2');
 parquet_s3_fdw_disconnect 
---------------------------
 f
(1 row)

-- Return an error as there is no foreign server with given name.
--Testcase 420:
SELECT parquet_s3_fdw_disconnect('unknownserver');
psql:sql/13.8/schemaless/parquet_s3_fdw_post.sql:3568: ERROR:  server "unknownserver" does not exist
-- Let's ensure to close all the existing cached connections.
--Testcase 421:
SELECT 1 FROM parquet_s3_fdw_disconnect_all();
 ?column? 
----------
        1
(1 row)

-- No cached connections, so no records should be output.
--Testcase 422:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;
 server_name 
-------------
(0 rows)

-- =============================================================================
-- test case for having multiple cached connections for a foreign server
-- with local parquet file (not on minio/s3 servers). It haven't server and connection.
-- =============================================================================
--Testcase 423:
CREATE ROLE regress_multi_conn_user1 SUPERUSER;
--Testcase 424:
CREATE ROLE regress_multi_conn_user2 SUPERUSER;
--Testcase 425:
CREATE USER MAPPING FOR regress_multi_conn_user1 SERVER parquet_s3_srv :USER_PASSWORD;
--Testcase 426:
CREATE USER MAPPING FOR regress_multi_conn_user2 SERVER parquet_s3_srv :USER_PASSWORD;
-- BEGIN;
-- Will cache parquet_s3_srv connection with user mapping for regress_multi_conn_user1
--Testcase 704:
SET ROLE regress_multi_conn_user1;
--Testcase 427:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

--Testcase 705:
RESET ROLE;
-- Will cache parquet_s3_srv connection with user mapping for regress_multi_conn_user2
--Testcase 706:
SET ROLE regress_multi_conn_user2;
--Testcase 428:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

--Testcase 707:
RESET ROLE;
-- Should output two connections for parquet_s3_srv server
--Testcase 429:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1; -- return 0 rows if not use minio/s3 servers.
 server_name 
-------------
(0 rows)

-- COMMIT;
-- Let's ensure to close all the existing cached connections.
--Testcase 430:
SELECT 1 FROM parquet_s3_fdw_disconnect_all();
 ?column? 
----------
        1
(1 row)

-- No cached connections, so no records should be output.
--Testcase 431:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1; 
 server_name 
-------------
(0 rows)

-- Clean up
--Testcase 432:
DROP USER MAPPING FOR regress_multi_conn_user1 SERVER parquet_s3_srv;
--Testcase 433:
DROP USER MAPPING FOR regress_multi_conn_user2 SERVER parquet_s3_srv;
--Testcase 434:
DROP ROLE regress_multi_conn_user1;
--Testcase 435:
DROP ROLE regress_multi_conn_user2;
-- ===================================================================
-- Test foreign server level option keep_connections
-- ===================================================================
-- By default, the connections associated with foreign server are cached i.e.
-- keep_connections option is on. Set it to off.
--Testcase 708:
ALTER SERVER parquet_s3_srv OPTIONS (keep_connections 'off');
-- connection to parquet_s3_srv server is closed at the end of xact
-- as keep_connections was set to off.
--Testcase 436:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

-- No cached connections, so no records should be output.
--Testcase 437:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;
 server_name 
-------------
(0 rows)

--Testcase 709:
ALTER SERVER parquet_s3_srv OPTIONS (SET keep_connections 'on');
-- ===================================================================
-- batch insert
-- ===================================================================
-- BEGIN;
-- CREATE SERVER batch10 FOREIGN DATA WRAPPER postgres_fdw OPTIONS( batch_size '10' );
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'batch10'
-- AND srvoptions @> array['batch_size=10'];
-- ALTER SERVER batch10 OPTIONS( SET batch_size '20' );
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'batch10'
-- AND srvoptions @> array['batch_size=10'];
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'batch10'
-- AND srvoptions @> array['batch_size=20'];
-- CREATE FOREIGN TABLE table30 ( x int ) SERVER batch10 OPTIONS ( batch_size '30' );
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30'::regclass
-- AND ftoptions @> array['batch_size=30'];
-- ALTER FOREIGN TABLE table30 OPTIONS ( SET batch_size '40');
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30'::regclass
-- AND ftoptions @> array['batch_size=30'];
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30'::regclass
-- AND ftoptions @> array['batch_size=40'];
-- ROLLBACK;
-- CREATE TABLE batch_table ( x int );
-- CREATE FOREIGN TABLE ftable ( x int ) SERVER loopback OPTIONS ( table_name 'batch_table', batch_size '10' );
-- EXPLAIN (VERBOSE, COSTS OFF) INSERT INTO ftable SELECT * FROM generate_series(1, 10) i;
-- INSERT INTO ftable SELECT * FROM generate_series(1, 10) i;
-- INSERT INTO ftable SELECT * FROM generate_series(11, 31) i;
-- INSERT INTO ftable VALUES (32);
-- INSERT INTO ftable VALUES (33), (34);
-- SELECT COUNT(*) FROM ftable;
-- TRUNCATE batch_table;
-- DROP FOREIGN TABLE ftable;
-- -- try if large batches exceed max number of bind parameters
-- CREATE FOREIGN TABLE ftable ( x int ) SERVER loopback OPTIONS ( table_name 'batch_table', batch_size '100000' );
-- INSERT INTO ftable SELECT * FROM generate_series(1, 70000) i;
-- SELECT COUNT(*) FROM ftable;
-- TRUNCATE batch_table;
-- DROP FOREIGN TABLE ftable;
-- Disable batch insert
-- CREATE FOREIGN TABLE ftable ( x int ) SERVER loopback OPTIONS ( table_name 'batch_table', batch_size '1' );
-- EXPLAIN (VERBOSE, COSTS OFF) INSERT INTO ftable VALUES (1), (2);
-- INSERT INTO ftable VALUES (1), (2);
-- SELECT COUNT(*) FROM ftable;
-- DROP FOREIGN TABLE ftable;
-- DROP TABLE batch_table;
-- Use partitioning
-- CREATE TABLE batch_table ( x int ) PARTITION BY HASH (x);
-- CREATE TABLE batch_table_p0 (LIKE batch_table);
-- CREATE FOREIGN TABLE batch_table_p0f
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 3, REMAINDER 0)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_table_p0', batch_size '10');
-- CREATE TABLE batch_table_p1 (LIKE batch_table);
-- CREATE FOREIGN TABLE batch_table_p1f
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 3, REMAINDER 1)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_table_p1', batch_size '1');
-- CREATE TABLE batch_table_p2
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 3, REMAINDER 2);
-- INSERT INTO batch_table SELECT * FROM generate_series(1, 66) i;
-- SELECT COUNT(*) FROM batch_table;
-- Check that enabling batched inserts doesn't interfere with cross-partition
-- updates
-- CREATE TABLE batch_cp_upd_test (a int) PARTITION BY LIST (a);
-- CREATE TABLE batch_cp_upd_test1 (LIKE batch_cp_upd_test);
-- CREATE FOREIGN TABLE batch_cp_upd_test1_f
-- 	PARTITION OF batch_cp_upd_test
-- 	FOR VALUES IN (1)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_cp_upd_test1', batch_size '10');
-- CREATE TABLE batch_cp_up_test1 PARTITION OF batch_cp_upd_test
-- 	FOR VALUES IN (2);
-- INSERT INTO batch_cp_upd_test VALUES (1), (2);
-- The following moves a row from the local partition to the foreign one
-- UPDATE batch_cp_upd_test t SET a = 1 FROM (VALUES (1), (2)) s(a) WHERE t.a = s.a;
-- SELECT tableoid::regclass, * FROM batch_cp_upd_test;
-- Clean up
-- DROP TABLE batch_table, batch_cp_upd_test, batch_table_p0, batch_table_p1 CASCADE;
-- -- Use partitioning
-- ALTER SERVER loopback OPTIONS (ADD batch_size '10');
-- CREATE TABLE batch_table ( x int, field1 text, field2 text) PARTITION BY HASH (x);
-- CREATE TABLE batch_table_p0 (LIKE batch_table);
-- ALTER TABLE batch_table_p0 ADD CONSTRAINT p0_pkey PRIMARY KEY (x);
-- CREATE FOREIGN TABLE batch_table_p0f
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 2, REMAINDER 0)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_table_p0');
-- CREATE TABLE batch_table_p1 (LIKE batch_table);
-- ALTER TABLE batch_table_p1 ADD CONSTRAINT p1_pkey PRIMARY KEY (x);
-- CREATE FOREIGN TABLE batch_table_p1f
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 2, REMAINDER 1)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_table_p1');
-- INSERT INTO batch_table SELECT i, 'test'||i, 'test'|| i FROM generate_series(1, 50) i;
-- SELECT COUNT(*) FROM batch_table;
-- SELECT * FROM batch_table ORDER BY x;
-- ALTER SERVER loopback OPTIONS (DROP batch_size);
-- ===================================================================
-- test asynchronous execution
-- ===================================================================
-- ALTER SERVER loopback OPTIONS (DROP extensions);
-- ALTER SERVER loopback OPTIONS (ADD async_capable 'true');
-- ALTER SERVER loopback2 OPTIONS (ADD async_capable 'true');
-- CREATE TABLE async_pt (a int, b int, c text) PARTITION BY RANGE (a);
-- CREATE TABLE base_tbl1 (a int, b int, c text);
-- CREATE TABLE base_tbl2 (a int, b int, c text);
-- CREATE FOREIGN TABLE async_p1 PARTITION OF async_pt FOR VALUES FROM (1000) TO (2000)
--   SERVER loopback OPTIONS (table_name 'base_tbl1');
-- CREATE FOREIGN TABLE async_p2 PARTITION OF async_pt FOR VALUES FROM (2000) TO (3000)
--   SERVER loopback2 OPTIONS (table_name 'base_tbl2');
-- INSERT INTO async_p1 SELECT 1000 + i, i, to_char(i, 'FM0000') FROM generate_series(0, 999, 5) i;
-- INSERT INTO async_p2 SELECT 2000 + i, i, to_char(i, 'FM0000') FROM generate_series(0, 999, 5) i;
-- ANALYZE async_pt;
-- simple queries
-- CREATE TABLE result_tbl (a int, b int, c text);
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b % 100 = 0;
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b % 100 = 0;
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- Check case where multiple partitions use the same connection
-- CREATE TABLE base_tbl3 (a int, b int, c text);
-- CREATE FOREIGN TABLE async_p3 PARTITION OF async_pt FOR VALUES FROM (3000) TO (4000)
--   SERVER loopback2 OPTIONS (table_name 'base_tbl3');
-- INSERT INTO async_p3 SELECT 3000 + i, i, to_char(i, 'FM0000') FROM generate_series(0, 999, 5) i;
-- ANALYZE async_pt;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- DROP FOREIGN TABLE async_p3;
-- DROP TABLE base_tbl3;
-- Check case where the partitioned table has local/remote partitions
-- CREATE TABLE async_p3 PARTITION OF async_pt FOR VALUES FROM (3000) TO (4000);
-- INSERT INTO async_p3 SELECT 3000 + i, i, to_char(i, 'FM0000') FROM generate_series(0, 999, 5) i;
-- ANALYZE async_pt;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- partitionwise joins
-- SET enable_partitionwise_join TO true;
-- CREATE TABLE join_tbl (a1 int, b1 int, v->>'c1' text, a2 int, b2 int, c2 text);
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO join_tbl SELECT * FROM async_pt t1, async_pt t2 WHERE t1.a = t2.a AND t1.b = t2.b AND t1.b % 100 = 0;
-- INSERT INTO join_tbl SELECT * FROM async_pt t1, async_pt t2 WHERE t1.a = t2.a AND t1.b = t2.b AND t1.b % 100 = 0;
-- SELECT * FROM join_tbl ORDER BY a1;
-- DELETE FROM join_tbl;
-- RESET enable_partitionwise_join;
-- Test rescan of an async Append node with do_exec_prune=false
-- SET enable_hashjoin TO false;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO join_tbl SELECT * FROM async_p1 t1, async_pt t2 WHERE t1.a = t2.a AND t1.b = t2.b AND t1.b % 100 = 0;
-- INSERT INTO join_tbl SELECT * FROM async_p1 t1, async_pt t2 WHERE t1.a = t2.a AND t1.b = t2.b AND t1.b % 100 = 0;
-- SELECT * FROM join_tbl ORDER BY a1;
-- DELETE FROM join_tbl;
-- RESET enable_hashjoin;
-- Test interaction of async execution with plan-time partition pruning
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM async_pt WHERE a < 3000;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM async_pt WHERE a < 2000;
-- Test interaction of async execution with run-time partition pruning
-- SET plan_cache_mode TO force_generic_plan;
-- PREPARE async_pt_query (int, int) AS
--   INSERT INTO result_tbl SELECT * FROM async_pt WHERE a < $1 AND b === $2;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- EXECUTE async_pt_query (3000, 505);
-- EXECUTE async_pt_query (3000, 505);
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- EXECUTE async_pt_query (2000, 505);
-- EXECUTE async_pt_query (2000, 505);
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- RESET plan_cache_mode;
-- CREATE TABLE local_tbl(a int, b int, c text);
-- INSERT INTO local_tbl VALUES (1505, 505, 'foo'), (2505, 505, 'bar');
-- ANALYZE local_tbl;
-- CREATE INDEX base_tbl1_idx ON base_tbl1 (a);
-- CREATE INDEX base_tbl2_idx ON base_tbl2 (a);
-- CREATE INDEX async_p3_idx ON async_p3 (a);
-- ANALYZE base_tbl1;
-- ANALYZE base_tbl2;
-- ANALYZE async_p3;
-- ALTER FOREIGN TABLE async_p1 OPTIONS (use_remote_estimate 'true');
-- ALTER FOREIGN TABLE async_p2 OPTIONS (use_remote_estimate 'true');
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM local_tbl, async_pt WHERE local_tbl.a = async_pt.a AND local_tbl.c = 'bar';
-- EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-- SELECT * FROM local_tbl, async_pt WHERE local_tbl.a = async_pt.a AND local_tbl.c = 'bar';
-- SELECT * FROM local_tbl, async_pt WHERE local_tbl.a = async_pt.a AND local_tbl.c = 'bar';
-- ALTER FOREIGN TABLE async_p1 OPTIONS (DROP use_remote_estimate);
-- ALTER FOREIGN TABLE async_p2 OPTIONS (DROP use_remote_estimate);
-- DROP TABLE local_tbl;
-- DROP INDEX base_tbl1_idx;
-- DROP INDEX base_tbl2_idx;
-- DROP INDEX async_p3_idx;
-- Test that pending requests are processed properly
-- SET enable_mergejoin TO false;
-- SET enable_hashjoin TO false;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM async_pt t1, async_p2 t2 WHERE t1.a = t2.a AND t1.b === 505;
-- SELECT * FROM async_pt t1, async_p2 t2 WHERE t1.a = t2.a AND t1.b === 505;
-- CREATE TABLE local_tbl (a int, b int, c text);
-- INSERT INTO local_tbl VALUES (1505, 505, 'foo');
-- ANALYZE local_tbl;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM local_tbl t1 LEFT JOIN (SELECT *, (SELECT count(*) FROM async_pt WHERE a < 3000) FROM async_pt WHERE a < 3000) t2 ON t1.a = t2.a;
-- EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-- SELECT * FROM local_tbl t1 LEFT JOIN (SELECT *, (SELECT count(*) FROM async_pt WHERE a < 3000) FROM async_pt WHERE a < 3000) t2 ON t1.a = t2.a;
-- SELECT * FROM local_tbl t1 LEFT JOIN (SELECT *, (SELECT count(*) FROM async_pt WHERE a < 3000) FROM async_pt WHERE a < 3000) t2 ON t1.a = t2.a;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM async_pt t1 WHERE t1.b === 505 LIMIT 1;
-- EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-- SELECT * FROM async_pt t1 WHERE t1.b === 505 LIMIT 1;
-- SELECT * FROM async_pt t1 WHERE t1.b === 505 LIMIT 1;
-- Check with foreign modify
-- CREATE TABLE base_tbl3 (a int, b int, c text);
-- CREATE FOREIGN TABLE remote_tbl (a int, b int, c text)
--   SERVER loopback OPTIONS (table_name 'base_tbl3');
-- INSERT INTO remote_tbl VALUES (2505, 505, 'bar');
-- CREATE TABLE base_tbl4 (a int, b int, c text);
-- CREATE FOREIGN TABLE insert_tbl (a int, b int, c text)
--   SERVER loopback OPTIONS (table_name 'base_tbl4');
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO insert_tbl (SELECT * FROM local_tbl UNION ALL SELECT * FROM remote_tbl);
-- INSERT INTO insert_tbl (SELECT * FROM local_tbl UNION ALL SELECT * FROM remote_tbl);
-- SELECT * FROM insert_tbl ORDER BY a;
-- Check with direct modify
-- EXPLAIN (VERBOSE, COSTS OFF)
-- WITH t AS (UPDATE remote_tbl SET c = c || c RETURNING *)
-- INSERT INTO join_tbl SELECT * FROM async_pt LEFT JOIN t ON (async_pt.a = t.a AND async_pt.b = t.b) WHERE async_pt.b === 505;
-- WITH t AS (UPDATE remote_tbl SET c = c || c RETURNING *)
-- INSERT INTO join_tbl SELECT * FROM async_pt LEFT JOIN t ON (async_pt.a = t.a AND async_pt.b = t.b) WHERE async_pt.b === 505;
-- SELECT * FROM join_tbl ORDER BY a1;
-- DELETE FROM join_tbl;
-- DROP TABLE local_tbl;
-- DROP FOREIGN TABLE remote_tbl;
-- DROP FOREIGN TABLE insert_tbl;
-- DROP TABLE base_tbl3;
-- DROP TABLE base_tbl4;
-- RESET enable_mergejoin;
-- RESET enable_hashjoin;
-- Test that UPDATE/DELETE with inherited target works with async_capable enabled
-- EXPLAIN (VERBOSE, COSTS OFF)
-- UPDATE async_pt SET c = c || c WHERE b = 0 RETURNING *;
-- UPDATE async_pt SET c = c || c WHERE b = 0 RETURNING *;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- DELETE FROM async_pt WHERE b = 0 RETURNING *;
-- DELETE FROM async_pt WHERE b = 0 RETURNING *;
-- Check EXPLAIN ANALYZE for a query that scans empty partitions asynchronously
-- DELETE FROM async_p1;
-- DELETE FROM async_p2;
-- DELETE FROM async_p3;
-- EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-- SELECT * FROM async_pt;
-- Clean up
-- DROP TABLE async_pt;
-- DROP TABLE base_tbl1;
-- DROP TABLE base_tbl2;
-- DROP TABLE result_tbl;
-- DROP TABLE join_tbl;
-- ALTER SERVER loopback OPTIONS (DROP async_capable);
-- ALTER SERVER loopback2 OPTIONS (DROP async_capable);
-- ===================================================================
-- test invalid server and foreign table options
-- ===================================================================
-- Invalid fdw_startup_cost option
-- CREATE SERVER inv_scst FOREIGN DATA WRAPPER postgres_fdw
-- 	OPTIONS(fdw_startup_cost '100$%$#$#');
-- -- Invalid fdw_tuple_cost option
-- CREATE SERVER inv_scst FOREIGN DATA WRAPPER postgres_fdw
-- 	OPTIONS(fdw_tuple_cost '100$%$#$#');
-- -- Invalid fetch_size option
-- CREATE FOREIGN TABLE inv_fsz (c1 int )
-- 	SERVER loopback OPTIONS (fetch_size '100$%$#$#');
-- -- Invalid batch_size option
-- CREATE FOREIGN TABLE inv_bsz (c1 int )
-- 	SERVER loopback OPTIONS (batch_size '100$%$#$#');
-- Clean-up
--Testcase 710:
SET client_min_messages TO WARNING;
--Testcase 438:
DROP TYPE user_enum;
--Testcase 439:
DROP SCHEMA "S 1" CASCADE;
--Testcase 440:
DROP SCHEMA import_dest1 CASCADE;
--Testcase 441:
DROP USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv;
--Testcase 442:
DROP USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv_2;
--Testcase 443:
DROP SERVER parquet_s3_srv CASCADE;
--Testcase 444:
DROP SERVER parquet_s3_srv_2 CASCADE;
--Testcase 445:
DROP EXTENSION parquet_s3_fdw CASCADE;
-- Recover data
\! cp -a data/ported_postgres /tmp/data_local
--Testcase 711:
DROP FUNCTION trigger_func CASCADE;
--Testcase 712:
DROP FUNCTION trig_null CASCADE;
--Testcase 713:
DROP FUNCTION trig_row_before_insupdate CASCADE;
