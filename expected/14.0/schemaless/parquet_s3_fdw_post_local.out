\set ECHO none
show server_version \gset
\ir sql/:server_version/schemaless/parquet_s3_fdw_post.sql
-- ===================================================================
-- create FDW objects
-- ===================================================================
--Testcase 1:
CREATE EXTENSION parquet_s3_fdw;
--Testcase 2:
CREATE SERVER parquet_s3_srv FOREIGN DATA WRAPPER parquet_s3_fdw
      :USE_MINIO;
--Testcase 3:
CREATE SERVER parquet_s3_srv_2 FOREIGN DATA WRAPPER parquet_s3_fdw
      :USE_MINIO;
--Testcase 4:
CREATE SERVER parquet_s3_srv_3 FOREIGN DATA WRAPPER parquet_s3_fdw
      :USE_MINIO;
--Testcase 5:
CREATE USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv :USER_PASSWORD;
--Testcase 6:
CREATE USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv_2 :USER_PASSWORD;
--Testcase 7:
CREATE USER MAPPING FOR public SERVER parquet_s3_srv_3 :USER_PASSWORD;
-- ===================================================================
-- create objects used through FDW loopback server
-- ===================================================================
--Testcase 8:
CREATE TYPE user_enum AS ENUM ('foo', 'bar', 'buz');
--Testcase 9:
CREATE SCHEMA "S 1";
\set var '\"':PATH_FILENAME'\/ported_postgres\"'
IMPORT FOREIGN SCHEMA :var FROM SERVER parquet_s3_srv INTO "S 1" OPTIONS (sorted 'c1', schemaless 'true');
-- -- Disable autovacuum for these tables to avoid unexpected effects of that
-- ALTER TABLE "S 1"."T1" SET (autovacuum_enabled = 'false');
-- ALTER TABLE "S 1"."T2" SET (autovacuum_enabled = 'false');
-- ALTER TABLE "S 1"."T3" SET (autovacuum_enabled = 'false');
-- ALTER TABLE "S 1"."T4" SET (autovacuum_enabled = 'false');
-- ANALYZE "S 1"."T1";
-- ANALYZE "S 1"."T2";
-- ANALYZE "S 1"."T3";
-- ANALYZE "S 1"."T4";
-- ===================================================================
-- create foreign tables
-- ===================================================================
\set var :PATH_FILENAME'/ported_postgres/ft1.parquet'
--Testcase 10:
CREATE FOREIGN TABLE ft1 (
	c0 int,
  v jsonb
) SERVER parquet_s3_srv
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
ALTER FOREIGN TABLE ft1 DROP COLUMN c0;
\set var :PATH_FILENAME'/ported_postgres/ft1.parquet'
--Testcase 11:
CREATE FOREIGN TABLE ft2 (
  v jsonb,
	cx int
) SERVER parquet_s3_srv
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
ALTER FOREIGN TABLE ft2 DROP COLUMN cx;
\set var :PATH_FILENAME'/ported_postgres/T3.parquet'
--Testcase 12:
CREATE FOREIGN TABLE ft4 (
  v jsonb
) SERVER parquet_s3_srv
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
\set var :PATH_FILENAME'/ported_postgres/T4.parquet'
--Testcase 13:
CREATE FOREIGN TABLE ft5 (
	v jsonb
) SERVER parquet_s3_srv
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
\set var :PATH_FILENAME'/ported_postgres/T4.parquet'
--Testcase 14:
CREATE FOREIGN TABLE ft6 (
	v jsonb
) SERVER parquet_s3_srv_2
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
\set var :PATH_FILENAME'/ported_postgres/T4.parquet'
--Testcase 15:
CREATE FOREIGN TABLE ft7 (
	v jsonb
) SERVER parquet_s3_srv_3
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
-- -- ===================================================================
-- -- tests for validator
-- -- ===================================================================
-- -- requiressl and some other parameters are omitted because
-- -- valid values for them depend on configure options
-- ALTER SERVER testserver1 OPTIONS (
-- 	use_remote_estimate 'false',
-- 	updatable 'true',
-- 	fdw_startup_cost '123.456',
-- 	fdw_tuple_cost '0.123',
-- 	service 'value',
-- 	connect_timeout 'value',
-- 	dbname 'value',
-- 	host 'value',
-- 	hostaddr 'value',
-- 	port 'value',
-- 	--client_encoding 'value',
-- 	application_name 'value',
-- 	--fallback_application_name 'value',
-- 	keepalives 'value',
-- 	keepalives_idle 'value',
-- 	keepalives_interval 'value',
-- 	tcp_user_timeout 'value',
-- 	-- requiressl 'value',
-- 	sslcompression 'value',
-- 	sslmode 'value',
-- 	sslcert 'value',
-- 	sslkey 'value',
-- 	sslrootcert 'value',
-- 	sslcrl 'value',
-- 	--requirepeer 'value',
-- 	krbsrvname 'value',
-- 	gsslib 'value'
-- 	--replication 'value'
-- );
-- -- Error, invalid list syntax
-- ALTER SERVER testserver1 OPTIONS (ADD extensions 'foo; bar');
-- -- OK but gets a warning
-- ALTER SERVER testserver1 OPTIONS (ADD extensions 'foo, bar');
-- ALTER SERVER testserver1 OPTIONS (DROP extensions);
-- ALTER USER MAPPING FOR public SERVER testserver1
-- 	OPTIONS (DROP user, DROP password);
-- -- Attempt to add a valid option that's not allowed in a user mapping
-- ALTER USER MAPPING FOR public SERVER testserver1
-- 	OPTIONS (ADD sslmode 'require');
-- -- But we can add valid ones fine
-- ALTER USER MAPPING FOR public SERVER testserver1
-- 	OPTIONS (ADD sslpassword 'dummy');
-- -- Ensure valid options we haven't used in a user mapping yet are
-- -- permitted to check validation.
-- ALTER USER MAPPING FOR public SERVER testserver1
-- 	OPTIONS (ADD sslkey 'value', ADD sslcert 'value');
-- ALTER FOREIGN TABLE ft1 OPTIONS (schema_name 'S 1', table_name 'T 1');
-- ALTER FOREIGN TABLE ft2 OPTIONS (schema_name 'S 1', table_name 'T 1');
-- ALTER FOREIGN TABLE ft1 ALTER COLUMN v->>'c1' OPTIONS (column_name 'C 1');
-- ALTER FOREIGN TABLE ft2 ALTER COLUMN v->>'c1' OPTIONS (column_name 'C 1');
-- \det+
-- Test that alteration of server options causes reconnection
-- Remote's errors might be non-English, so hide them to ensure stable results
\set VERBOSITY terse
--Testcase 16:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should work
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

ALTER SERVER parquet_s3_srv OPTIONS (SET use_minio 'false');
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:166: ERROR:  option "use_minio" not found
--Testcase 17:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should fail if only when we use minio/s3. With local file, option use_minio is useless.
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

DO $d$
    BEGIN
        EXECUTE $$ALTER SERVER parquet_s3_srv
            OPTIONS (SET use_minio 'true')$$;
    END;
$d$;
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:174: ERROR:  option "use_minio" not found
--Testcase 18:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should work again
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

-- Test that alteration of user mapping options causes reconnection
ALTER USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv
  OPTIONS (SET user 'no such user');
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:180: ERROR:  option "user" not found
--Testcase 19:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should fail if only when we use minio/s3. With local file, option user is useless.
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

ALTER USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv
  OPTIONS (SET user 'minioadmin');
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:184: ERROR:  option "user" not found
--Testcase 20:
SELECT v->>'c3' as c3, v->>'c5' as c5 FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 LIMIT 1;  -- should work again
  c3   |            c5            
-------+--------------------------
 00001 | Fri Jan 02 00:00:00 1970
(1 row)

\set VERBOSITY default
-- Now we should be able to run ANALYZE.
-- To exercise multiple code paths, we use local stats on ft1
-- and remote-estimate mode on ft2.
-- ANALYZE ft1;
-- ALTER FOREIGN TABLE ft2 OPTIONS (use_remote_estimate 'true');
-- ===================================================================
-- simple queries
-- ===================================================================
-- single table without alias
--Testcase 21:
EXPLAIN (COSTS OFF) SELECT * FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 OFFSET 100 LIMIT 10;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   ->  Sort
         Sort Key: ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on ft1
               Reader: Single File
               Row groups: 1
(6 rows)

--Testcase 22:
SELECT * FROM ft1 ORDER BY v->>'c3', (v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 101, "c2": 1, "c3": "00101", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 102, "c2": 2, "c3": "00102", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 103, "c2": 3, "c3": "00103", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 104, "c2": 4, "c3": "00104", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
 {"c1": 105, "c2": 5, "c3": "00105", "c5": "Tue Jan 06 00:00:00 1970", "c6": "5", "c7": "5", "c8": "foo"}
 {"c1": 106, "c2": 6, "c3": "00106", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 107, "c2": 7, "c3": "00107", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 108, "c2": 8, "c3": "00108", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 109, "c2": 9, "c3": "00109", "c5": "Sat Jan 10 00:00:00 1970", "c6": "9", "c7": "9", "c8": "foo"}
 {"c1": 110, "c2": 0, "c3": "00110", "c5": "Sun Jan 11 00:00:00 1970", "c6": "0", "c7": "0", "c8": "foo"}
(10 rows)

-- single table with alias - also test that tableoid sort is not pushed to remote side
--Testcase 23:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8, t1.tableoid OFFSET 100 LIMIT 10;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit
   Output: v, ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint), tableoid
   ->  Sort
         Output: v, ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint), tableoid
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint), t1.tableoid
         ->  Foreign Scan on public.ft1 t1
               Output: v, (v ->> 'c3'::text), ((v ->> 'c1'::text))::bigint, tableoid
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 24:
SELECT * FROM ft1 t1 ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8, t1.tableoid OFFSET 100 LIMIT 10;
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 101, "c2": 1, "c3": "00101", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 102, "c2": 2, "c3": "00102", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 103, "c2": 3, "c3": "00103", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 104, "c2": 4, "c3": "00104", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
 {"c1": 105, "c2": 5, "c3": "00105", "c5": "Tue Jan 06 00:00:00 1970", "c6": "5", "c7": "5", "c8": "foo"}
 {"c1": 106, "c2": 6, "c3": "00106", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 107, "c2": 7, "c3": "00107", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 108, "c2": 8, "c3": "00108", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 109, "c2": 9, "c3": "00109", "c5": "Sat Jan 10 00:00:00 1970", "c6": "9", "c7": "9", "c8": "foo"}
 {"c1": 110, "c2": 0, "c3": "00110", "c5": "Sun Jan 11 00:00:00 1970", "c6": "0", "c7": "0", "c8": "foo"}
(10 rows)

-- whole-row reference
--Testcase 25:
EXPLAIN (VERBOSE, COSTS OFF) SELECT t1 FROM ft1 t1 ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Limit
   Output: t1.*, ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: t1.*, ((v ->> 'c3'::text)), (((v ->> 'c1'::text))::bigint)
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.*, (v ->> 'c3'::text), ((v ->> 'c1'::text))::bigint
               Reader: Single File
               Row groups: 1
(9 rows)

-- parquet_s3_fdw only fill slot attributes if column was referred in targetlist or clauses. In other cases mark attribute as NULL.
--Testcase 26:
SELECT t1 FROM ft1 t1 ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                                  t1                                                                  
--------------------------------------------------------------------------------------------------------------------------------------
 ("{""c1"": 101, ""c2"": 1, ""c3"": ""00101"", ""c5"": ""Fri Jan 02 00:00:00 1970"", ""c6"": ""1"", ""c7"": ""1"", ""c8"": ""foo""}")
 ("{""c1"": 102, ""c2"": 2, ""c3"": ""00102"", ""c5"": ""Sat Jan 03 00:00:00 1970"", ""c6"": ""2"", ""c7"": ""2"", ""c8"": ""foo""}")
 ("{""c1"": 103, ""c2"": 3, ""c3"": ""00103"", ""c5"": ""Sun Jan 04 00:00:00 1970"", ""c6"": ""3"", ""c7"": ""3"", ""c8"": ""foo""}")
 ("{""c1"": 104, ""c2"": 4, ""c3"": ""00104"", ""c5"": ""Mon Jan 05 00:00:00 1970"", ""c6"": ""4"", ""c7"": ""4"", ""c8"": ""foo""}")
 ("{""c1"": 105, ""c2"": 5, ""c3"": ""00105"", ""c5"": ""Tue Jan 06 00:00:00 1970"", ""c6"": ""5"", ""c7"": ""5"", ""c8"": ""foo""}")
 ("{""c1"": 106, ""c2"": 6, ""c3"": ""00106"", ""c5"": ""Wed Jan 07 00:00:00 1970"", ""c6"": ""6"", ""c7"": ""6"", ""c8"": ""foo""}")
 ("{""c1"": 107, ""c2"": 7, ""c3"": ""00107"", ""c5"": ""Thu Jan 08 00:00:00 1970"", ""c6"": ""7"", ""c7"": ""7"", ""c8"": ""foo""}")
 ("{""c1"": 108, ""c2"": 8, ""c3"": ""00108"", ""c5"": ""Fri Jan 09 00:00:00 1970"", ""c6"": ""8"", ""c7"": ""8"", ""c8"": ""foo""}")
 ("{""c1"": 109, ""c2"": 9, ""c3"": ""00109"", ""c5"": ""Sat Jan 10 00:00:00 1970"", ""c6"": ""9"", ""c7"": ""9"", ""c8"": ""foo""}")
 ("{""c1"": 110, ""c2"": 0, ""c3"": ""00110"", ""c5"": ""Sun Jan 11 00:00:00 1970"", ""c6"": ""0"", ""c7"": ""0"", ""c8"": ""foo""}")
(10 rows)

-- empty result
--Testcase 27:
SELECT * FROM ft1 WHERE false;
 v 
---
(0 rows)

-- with WHERE clause
--Testcase 28:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = 101 AND (t1.v->>'c6')::int = '1' AND (t1.v->>'c7')::int >= '1';
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((((t1.v ->> 'c7'::text))::integer >= 1) AND (((t1.v ->> 'c1'::text))::bigint = 101) AND (((t1.v ->> 'c6'::text))::integer = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 29:
SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = 101 AND (t1.v->>'c6')::int = '1' AND (t1.v->>'c7')::int >= '1';
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 101, "c2": 1, "c3": "00101", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- with FOR UPDATE/SHARE
--Testcase 30:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = 101 FOR UPDATE;
                       QUERY PLAN                        
---------------------------------------------------------
 LockRows
   Output: v, t1.*
   ->  Foreign Scan on public.ft1 t1
         Output: v, t1.*
         Filter: (((t1.v ->> 'c1'::text))::bigint = 101)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 31:
SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = 101 FOR UPDATE;
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 101, "c2": 1, "c3": "00101", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

--Testcase 32:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = 102 FOR SHARE;
                       QUERY PLAN                        
---------------------------------------------------------
 LockRows
   Output: v, t1.*
   ->  Foreign Scan on public.ft1 t1
         Output: v, t1.*
         Filter: (((t1.v ->> 'c1'::text))::bigint = 102)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 33:
SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = 102 FOR SHARE;
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 102, "c2": 2, "c3": "00102", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
(1 row)

-- aggregate
--Testcase 34:
SELECT COUNT(*) FROM ft1 t1;
 count 
-------
  1000
(1 row)

-- subquery
--Testcase 35:
SELECT * FROM ft1 t1 WHERE t1.v->>'c3' IN (SELECT v->>'c3' FROM ft2 t2 WHERE (v->>'c1')::int8 <= 10) ORDER BY (v->>'c1')::int8;
                                                    v                                                    
---------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 2, "c2": 2, "c3": "00002", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 3, "c2": 3, "c3": "00003", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 4, "c2": 4, "c3": "00004", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
 {"c1": 5, "c2": 5, "c3": "00005", "c5": "Tue Jan 06 00:00:00 1970", "c6": "5", "c7": "5", "c8": "foo"}
 {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 7, "c2": 7, "c3": "00007", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 8, "c2": 8, "c3": "00008", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 9, "c2": 9, "c3": "00009", "c5": "Sat Jan 10 00:00:00 1970", "c6": "9", "c7": "9", "c8": "foo"}
 {"c1": 10, "c2": 0, "c3": "00010", "c5": "Sun Jan 11 00:00:00 1970", "c6": "0", "c7": "0", "c8": "foo"}
(10 rows)

-- subquery+MAX
--Testcase 36:
SELECT * FROM ft1 t1 WHERE t1.v->>'c3' = (SELECT MAX(v->>'c3') FROM ft2 t2) ORDER BY (v->>'c1')::int8;
                                                     v                                                     
-----------------------------------------------------------------------------------------------------------
 {"c1": 1000, "c2": 0, "c3": "01000", "c5": "Thu Jan 01 00:00:00 1970", "c6": "0", "c7": "0", "c8": "foo"}
(1 row)

-- used in CTE
--Testcase 37:
WITH t1 AS (SELECT * FROM ft1 WHERE (v->>'c1')::int8 <= 10) SELECT (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, t2.v->>'c3' as c3, t2.v->>'c5' as c5 FROM t1, ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 ORDER BY (t1.v->>'c1')::int8;
 c1 | c2 |  c3   |            c5            
----+----+-------+--------------------------
  1 |  1 | 00001 | Fri Jan 02 00:00:00 1970
  2 |  2 | 00002 | Sat Jan 03 00:00:00 1970
  3 |  3 | 00003 | Sun Jan 04 00:00:00 1970
  4 |  4 | 00004 | Mon Jan 05 00:00:00 1970
  5 |  5 | 00005 | Tue Jan 06 00:00:00 1970
  6 |  6 | 00006 | Wed Jan 07 00:00:00 1970
  7 |  7 | 00007 | Thu Jan 08 00:00:00 1970
  8 |  8 | 00008 | Fri Jan 09 00:00:00 1970
  9 |  9 | 00009 | Sat Jan 10 00:00:00 1970
 10 |  0 | 00010 | Sun Jan 11 00:00:00 1970
(10 rows)

-- fixed values
--Testcase 38:
SELECT 'fixed', NULL FROM ft1 t1 WHERE (v->>'c1')::int8 = 1;
 ?column? | ?column? 
----------+----------
 fixed    | 
(1 row)

-- Test forcing the remote server to produce sorted data for a merge join.
SET enable_hashjoin TO false;
SET enable_nestloop TO false;
-- inner join; expressions in the clauses appear in the equivalence class list
--Testcase 39:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft2 t1 JOIN "S 1"."T1" t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Merge Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft2 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on "S 1"."T1" t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(15 rows)

--Testcase 40:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft2 t1 JOIN "S 1"."T1" t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- outer join; expressions in the clauses do not appear in equivalence class
-- list but no output change as compared to the previous query
--Testcase 41:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft2 t1 LEFT JOIN "S 1"."T1" t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft2 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on "S 1"."T1" t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(15 rows)

--Testcase 42:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft2 t1 LEFT JOIN "S 1"."T1" t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- A join between local table and foreign join. ORDER BY clause is added to the
-- foreign join so that the local table can be joined using merge join strategy.
--Testcase 43:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 left join ft1 t2 join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint)
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t3.v
               ->  Merge Join
                     Output: t3.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t3.v
                           ->  Foreign Scan on public.ft2 t3
                                 Output: t3.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 44:
SELECT (t1.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 left join ft1 t2 join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  
-----
 101
 102
 103
 104
 105
 106
 107
 108
 109
 110
(10 rows)

-- Test similar to above, except that the full join prevents any equivalence
-- classes from being merged. This produces single relation equivalence classes
-- included in join restrictions.
--Testcase 45:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 left join ft1 t2 full join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t3.v, t2.v
               ->  Merge Left Join
                     Output: t3.v, t2.v
                     Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t3
                           Output: t3.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v
                           ->  Foreign Scan on public.ft1 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 46:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 left join ft1 t2 full join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  | c1  | c1  
-----+-----+-----
 101 | 101 | 101
 102 | 102 | 102
 103 | 103 | 103
 104 | 104 | 104
 105 | 105 | 105
 106 | 106 | 106
 107 | 107 | 107
 108 | 108 | 108
 109 | 109 | 109
 110 | 110 | 110
(10 rows)

-- Test similar to above with all full outer joins
--Testcase 47:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 full join ft1 t2 full join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   ->  Merge Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = (((t3.v ->> 'c1'::text))::bigint))
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Sort
               Output: t2.v, t3.v, (((t3.v ->> 'c1'::text))::bigint)
               Sort Key: (((t3.v ->> 'c1'::text))::bigint)
               ->  Merge Full Join
                     Output: t2.v, t3.v, ((t3.v ->> 'c1'::text))::bigint
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t3.v
                           ->  Foreign Scan on public.ft2 t3
                                 Output: t3.v
                                 Reader: Single File
                                 Row groups: 1
(25 rows)

--Testcase 48:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1 full join ft1 t2 full join ft2 t3 on ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) on ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) OFFSET 100 LIMIT 10;
 c1  | c1  | c1  
-----+-----+-----
 101 | 101 | 101
 102 | 102 | 102
 103 | 103 | 103
 104 | 104 | 104
 105 | 105 | 105
 106 | 106 | 106
 107 | 107 | 107
 108 | 108 | 108
 109 | 109 | 109
 110 | 110 | 110
(10 rows)

RESET enable_hashjoin;
RESET enable_nestloop;
-- Test executing assertion in estimate_path_cost_size() that makes sure that
-- retrieved_rows for foreign rel re-used to cost pre-sorted foreign paths is
-- a sensible value even when the rel has tuples=0
\set var :PATH_FILENAME'/ported_postgres/loct_empty.parquet'
--Testcase 49:
CREATE FOREIGN TABLE ft_empty (v jsonb)
  SERVER parquet_s3_srv OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
-- ANALYZE ft_empty;
--Testcase 50:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft_empty ORDER BY (v->>'c1')::int8;
                QUERY PLAN                 
-------------------------------------------
 Foreign Scan on public.ft_empty
   Output: v, ((v ->> 'c1'::text))::bigint
   Reader: Single File
   Row groups: 1
(4 rows)

-- ===================================================================
-- WHERE with remotely-executable conditions
-- ===================================================================
--Testcase 51:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = 1;         -- Var, OpExpr(b), Const
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 52:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = 100 AND (t1.v->>'c2')::int = 0; -- BoolExpr
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((((t1.v ->> 'c1'::text))::bigint = 100) AND (((t1.v ->> 'c2'::text))::integer = 0))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 53:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 IS NULL;        -- NullTest
                     QUERY PLAN                      
-----------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint IS NULL)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 54:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 IS NOT NULL;    -- NullTest
                       QUERY PLAN                        
---------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint IS NOT NULL)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 55:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE round(abs((v->>'c1')::int8), 0) = 1; -- FuncExpr
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (round((abs(((t1.v ->> 'c1'::text))::bigint))::numeric, 0) = '1'::numeric)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 56:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = -(v->>'c1')::int8;          -- OpExpr(l)
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = (- ((t1.v ->> 'c1'::text))::bigint))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 57:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE ((v->>'c1')::int8 IS NOT NULL) IS DISTINCT FROM ((v->>'c1')::int8 IS NOT NULL); -- DistinctExpr
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((((t1.v ->> 'c1'::text))::bigint IS NOT NULL) IS DISTINCT FROM (((t1.v ->> 'c1'::text))::bigint IS NOT NULL))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 58:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = ANY(ARRAY[(v->>'c2')::int, 1, (v->>'c1')::int8 + 0]); -- ScalarArrayOpExpr
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = ANY (ARRAY[(((t1.v ->> 'c2'::text))::integer)::bigint, '1'::bigint, (((t1.v ->> 'c1'::text))::bigint + 0)]))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 59:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (v->>'c1')::int8 = (ARRAY[(v->>'c1')::int8,(v->>'c2')::int,3])[1]; -- SubscriptingRef
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = (ARRAY[((t1.v ->> 'c1'::text))::bigint, (((t1.v ->> 'c2'::text))::integer)::bigint, '3'::bigint])[1])
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 60:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE v->>'c6' = E'foo''s\\bar';  -- check special chars
                       QUERY PLAN                       
--------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((t1.v ->> 'c6'::text) = 'foo''s\bar'::text)
   Reader: Trivial
(4 rows)

--Testcase 61:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE v->>'c8' = 'foo';  -- can't be sent to remote
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: ((t1.v ->> 'c8'::text) = 'foo'::text)
   Reader: Single File
   Row groups: 1
(5 rows)

-- parameterized remote path for foreign table
--Testcase 62:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT * FROM "S 1"."T1" a, ft2 b WHERE (a.v->>'c1')::int8 = 47 AND (b.v->>'c1')::int8 = (a.v->>'c2')::int8;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Hash Join
   Output: a.v, b.v
   Hash Cond: (((b.v ->> 'c1'::text))::bigint = ((a.v ->> 'c2'::text))::bigint)
   ->  Foreign Scan on public.ft2 b
         Output: b.v
         Reader: Single File
         Row groups: 1
   ->  Hash
         Output: a.v
         ->  Foreign Scan on "S 1"."T1" a
               Output: a.v
               Filter: (((a.v ->> 'c1'::text))::bigint = 47)
               Reader: Single File
               Row groups: 1
(14 rows)

--Testcase 63:
SELECT * FROM ft2 a, ft2 b WHERE (a.v->>'c1')::int8 = 47 AND (b.v->>'c1')::int8 = (a.v->>'c2')::int8;
                                                    v                                                    |                                                   v                                                    
---------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------
 {"c1": 47, "c2": 7, "c3": "00047", "c5": "Tue Feb 17 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"} | {"c1": 7, "c2": 7, "c3": "00007", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
(1 row)

-- check both safe and unsafe join conditions
--Testcase 64:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT * FROM ft2 a, ft2 b
  WHERE (a.v->>'c2')::int = 6 AND (b.v->>'c1')::int8 = (a.v->>'c1')::int8 AND a.v->>'c8' = 'foo' AND b.v->>'c7' = upper(a.v->>'c7');
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: a.v, b.v
   Join Filter: ((upper((a.v ->> 'c7'::text)) = (b.v ->> 'c7'::text)) AND (((a.v ->> 'c1'::text))::bigint = ((b.v ->> 'c1'::text))::bigint))
   ->  Foreign Scan on public.ft2 a
         Output: a.v
         Filter: (((a.v ->> 'c8'::text) = 'foo'::text) AND (((a.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
   ->  Foreign Scan on public.ft2 b
         Output: b.v
         Reader: Single File
         Row groups: 1
(12 rows)

--Testcase 65:s
SELECT * FROM ft2 a, ft2 b
WHERE (a.v->>'c2')::int = 6 AND (b.v->>'c1')::int8 = (a.v->>'c1')::int8 AND a.v->>'c8' = 'foo' AND b.v->>'c7' = upper(a.v->>'c7');
                                                    v                                                     |                                                    v                                                     
----------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------
 {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}   | {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 26, "c2": 6, "c3": "00026", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 26, "c2": 6, "c3": "00026", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 56, "c2": 6, "c3": "00056", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 56, "c2": 6, "c3": "00056", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 66, "c2": 6, "c3": "00066", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 66, "c2": 6, "c3": "00066", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 76, "c2": 6, "c3": "00076", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 76, "c2": 6, "c3": "00076", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 86, "c2": 6, "c3": "00086", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 86, "c2": 6, "c3": "00086", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 96, "c2": 6, "c3": "00096", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 96, "c2": 6, "c3": "00096", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 106, "c2": 6, "c3": "00106", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 106, "c2": 6, "c3": "00106", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 116, "c2": 6, "c3": "00116", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 116, "c2": 6, "c3": "00116", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 126, "c2": 6, "c3": "00126", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 126, "c2": 6, "c3": "00126", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 136, "c2": 6, "c3": "00136", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 136, "c2": 6, "c3": "00136", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 146, "c2": 6, "c3": "00146", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 146, "c2": 6, "c3": "00146", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 156, "c2": 6, "c3": "00156", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 156, "c2": 6, "c3": "00156", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 166, "c2": 6, "c3": "00166", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 166, "c2": 6, "c3": "00166", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 176, "c2": 6, "c3": "00176", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 176, "c2": 6, "c3": "00176", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 186, "c2": 6, "c3": "00186", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 186, "c2": 6, "c3": "00186", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 196, "c2": 6, "c3": "00196", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 196, "c2": 6, "c3": "00196", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 206, "c2": 6, "c3": "00206", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 206, "c2": 6, "c3": "00206", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 216, "c2": 6, "c3": "00216", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 216, "c2": 6, "c3": "00216", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 226, "c2": 6, "c3": "00226", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 226, "c2": 6, "c3": "00226", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 236, "c2": 6, "c3": "00236", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 236, "c2": 6, "c3": "00236", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 246, "c2": 6, "c3": "00246", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 246, "c2": 6, "c3": "00246", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 256, "c2": 6, "c3": "00256", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 256, "c2": 6, "c3": "00256", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 266, "c2": 6, "c3": "00266", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 266, "c2": 6, "c3": "00266", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 276, "c2": 6, "c3": "00276", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 276, "c2": 6, "c3": "00276", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 286, "c2": 6, "c3": "00286", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 286, "c2": 6, "c3": "00286", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 296, "c2": 6, "c3": "00296", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 296, "c2": 6, "c3": "00296", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 306, "c2": 6, "c3": "00306", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 306, "c2": 6, "c3": "00306", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 316, "c2": 6, "c3": "00316", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 316, "c2": 6, "c3": "00316", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 326, "c2": 6, "c3": "00326", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 326, "c2": 6, "c3": "00326", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 336, "c2": 6, "c3": "00336", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 336, "c2": 6, "c3": "00336", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 346, "c2": 6, "c3": "00346", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 346, "c2": 6, "c3": "00346", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 356, "c2": 6, "c3": "00356", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 356, "c2": 6, "c3": "00356", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 366, "c2": 6, "c3": "00366", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 366, "c2": 6, "c3": "00366", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 376, "c2": 6, "c3": "00376", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 376, "c2": 6, "c3": "00376", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 386, "c2": 6, "c3": "00386", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 386, "c2": 6, "c3": "00386", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 396, "c2": 6, "c3": "00396", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 396, "c2": 6, "c3": "00396", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 406, "c2": 6, "c3": "00406", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 406, "c2": 6, "c3": "00406", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 416, "c2": 6, "c3": "00416", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 416, "c2": 6, "c3": "00416", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 426, "c2": 6, "c3": "00426", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 426, "c2": 6, "c3": "00426", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 436, "c2": 6, "c3": "00436", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 436, "c2": 6, "c3": "00436", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 446, "c2": 6, "c3": "00446", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 446, "c2": 6, "c3": "00446", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 456, "c2": 6, "c3": "00456", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 456, "c2": 6, "c3": "00456", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 466, "c2": 6, "c3": "00466", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 466, "c2": 6, "c3": "00466", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 476, "c2": 6, "c3": "00476", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 476, "c2": 6, "c3": "00476", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 486, "c2": 6, "c3": "00486", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 486, "c2": 6, "c3": "00486", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 496, "c2": 6, "c3": "00496", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 496, "c2": 6, "c3": "00496", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 506, "c2": 6, "c3": "00506", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 506, "c2": 6, "c3": "00506", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 516, "c2": 6, "c3": "00516", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 516, "c2": 6, "c3": "00516", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 526, "c2": 6, "c3": "00526", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 526, "c2": 6, "c3": "00526", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 536, "c2": 6, "c3": "00536", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 536, "c2": 6, "c3": "00536", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 546, "c2": 6, "c3": "00546", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 546, "c2": 6, "c3": "00546", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 556, "c2": 6, "c3": "00556", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 556, "c2": 6, "c3": "00556", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 566, "c2": 6, "c3": "00566", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 566, "c2": 6, "c3": "00566", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 576, "c2": 6, "c3": "00576", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 576, "c2": 6, "c3": "00576", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 586, "c2": 6, "c3": "00586", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 586, "c2": 6, "c3": "00586", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 596, "c2": 6, "c3": "00596", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 596, "c2": 6, "c3": "00596", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 606, "c2": 6, "c3": "00606", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 606, "c2": 6, "c3": "00606", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 616, "c2": 6, "c3": "00616", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 616, "c2": 6, "c3": "00616", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 626, "c2": 6, "c3": "00626", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 626, "c2": 6, "c3": "00626", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 636, "c2": 6, "c3": "00636", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 636, "c2": 6, "c3": "00636", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 646, "c2": 6, "c3": "00646", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 646, "c2": 6, "c3": "00646", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 656, "c2": 6, "c3": "00656", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 656, "c2": 6, "c3": "00656", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 666, "c2": 6, "c3": "00666", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 666, "c2": 6, "c3": "00666", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 676, "c2": 6, "c3": "00676", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 676, "c2": 6, "c3": "00676", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 686, "c2": 6, "c3": "00686", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 686, "c2": 6, "c3": "00686", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 696, "c2": 6, "c3": "00696", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 696, "c2": 6, "c3": "00696", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 706, "c2": 6, "c3": "00706", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 706, "c2": 6, "c3": "00706", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 716, "c2": 6, "c3": "00716", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 716, "c2": 6, "c3": "00716", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 726, "c2": 6, "c3": "00726", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 726, "c2": 6, "c3": "00726", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 736, "c2": 6, "c3": "00736", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 736, "c2": 6, "c3": "00736", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 746, "c2": 6, "c3": "00746", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 746, "c2": 6, "c3": "00746", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 756, "c2": 6, "c3": "00756", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 756, "c2": 6, "c3": "00756", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 766, "c2": 6, "c3": "00766", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 766, "c2": 6, "c3": "00766", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 776, "c2": 6, "c3": "00776", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 776, "c2": 6, "c3": "00776", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 786, "c2": 6, "c3": "00786", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 786, "c2": 6, "c3": "00786", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 796, "c2": 6, "c3": "00796", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 796, "c2": 6, "c3": "00796", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 806, "c2": 6, "c3": "00806", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 806, "c2": 6, "c3": "00806", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 816, "c2": 6, "c3": "00816", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 816, "c2": 6, "c3": "00816", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 826, "c2": 6, "c3": "00826", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 826, "c2": 6, "c3": "00826", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 836, "c2": 6, "c3": "00836", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 836, "c2": 6, "c3": "00836", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 846, "c2": 6, "c3": "00846", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 846, "c2": 6, "c3": "00846", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 856, "c2": 6, "c3": "00856", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 856, "c2": 6, "c3": "00856", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 866, "c2": 6, "c3": "00866", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 866, "c2": 6, "c3": "00866", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 876, "c2": 6, "c3": "00876", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 876, "c2": 6, "c3": "00876", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 886, "c2": 6, "c3": "00886", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 886, "c2": 6, "c3": "00886", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 896, "c2": 6, "c3": "00896", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 896, "c2": 6, "c3": "00896", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 906, "c2": 6, "c3": "00906", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 906, "c2": 6, "c3": "00906", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 916, "c2": 6, "c3": "00916", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 916, "c2": 6, "c3": "00916", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 926, "c2": 6, "c3": "00926", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 926, "c2": 6, "c3": "00926", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 936, "c2": 6, "c3": "00936", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 936, "c2": 6, "c3": "00936", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 946, "c2": 6, "c3": "00946", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 946, "c2": 6, "c3": "00946", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 956, "c2": 6, "c3": "00956", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 956, "c2": 6, "c3": "00956", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 966, "c2": 6, "c3": "00966", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 966, "c2": 6, "c3": "00966", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 976, "c2": 6, "c3": "00976", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 976, "c2": 6, "c3": "00976", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 986, "c2": 6, "c3": "00986", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 986, "c2": 6, "c3": "00986", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 996, "c2": 6, "c3": "00996", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 996, "c2": 6, "c3": "00996", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
(100 rows)

-- bug before 9.3.5 due to sloppy handling of remote-estimate parameters
--Testcase 66:
SELECT * FROM ft1 WHERE (v->>'c1')::int8 = ANY (ARRAY(SELECT (v->>'c1')::int8 FROM ft2 WHERE (v->>'c1')::int8 < 5));
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 2, "c2": 2, "c3": "00002", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 3, "c2": 3, "c3": "00003", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 4, "c2": 4, "c3": "00004", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
(4 rows)

--Testcase 67:
SELECT * FROM ft2 WHERE (v->>'c1')::int8 = ANY (ARRAY(SELECT (v->>'c1')::int8 FROM ft1 WHERE (v->>'c1')::int8 < 5));
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 2, "c2": 2, "c3": "00002", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 3, "c2": 3, "c3": "00003", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 4, "c2": 4, "c3": "00004", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
(4 rows)

-- we should not push order by clause with volatile expressions or unsafe
-- collations
--Testcase 68:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT * FROM ft2 ORDER BY (ft2.v->>'c1')::int8, random();
                         QUERY PLAN                         
------------------------------------------------------------
 Incremental Sort
   Output: v, (((v ->> 'c1'::text))::bigint), (random())
   Sort Key: (((ft2.v ->> 'c1'::text))::bigint), (random())
   Presorted Key: (((ft2.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft2
         Output: v, ((v ->> 'c1'::text))::bigint, random()
         Reader: Single File
         Row groups: 1
(8 rows)

--Testcase 69:
EXPLAIN (VERBOSE, COSTS OFF)
	SELECT * FROM ft2 ORDER BY (ft2.v->>'c1')::int8, ft2.v->>'c3' collate "C";
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Incremental Sort
   Output: v, (((v ->> 'c1'::text))::bigint), ((v ->> 'c3'::text COLLATE "C"))
   Sort Key: (((ft2.v ->> 'c1'::text))::bigint), ((ft2.v ->> 'c3'::text COLLATE "C")) COLLATE "C"
   Presorted Key: (((ft2.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft2
         Output: v, ((v ->> 'c1'::text))::bigint, (v ->> 'c3'::text COLLATE "C")
         Reader: Single File
         Row groups: 1
(8 rows)

-- user-defined operator/function
--Testcase 70:
CREATE FUNCTION parquet_s3_fdw_abs(int) RETURNS int AS $$
BEGIN
RETURN abs($1);
END
$$ LANGUAGE plpgsql IMMUTABLE;
--Testcase 71:
CREATE OPERATOR === (
    LEFTARG = int,
    RIGHTARG = int,
    PROCEDURE = int4eq,
    COMMUTATOR = ===
);
-- built-in operators and functions can be shipped for remote execution
--Testcase 72:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = abs((t1.v->>'c2')::int);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::bigint = abs(((t1.v ->> 'c2'::text))::integer))
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 73:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = abs((t1.v->>'c2')::int);
 count 
-------
     9
(1 row)

--Testcase 74:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = (t1.v->>'c2')::int;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 75:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = (t1.v->>'c2')::int;
 count 
-------
     9
(1 row)

-- by default, user-defined ones cannot
--Testcase 76:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = parquet_s3_fdw_abs((t1.v->>'c2')::int);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::bigint = parquet_s3_fdw_abs(((t1.v ->> 'c2'::text))::integer))
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 77:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = parquet_s3_fdw_abs((t1.v->>'c2')::int);
 count 
-------
     9
(1 row)

--Testcase 78:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 79:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
 count 
-------
     9
(1 row)

-- ORDER BY can be shipped, though
--Testcase 80:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int order by (t1.v->>'c2')::int limit 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: v, (((v ->> 'c2'::text))::integer)
   ->  Sort
         Output: v, (((v ->> 'c2'::text))::integer)
         Sort Key: (((t1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1 t1
               Output: v, ((v ->> 'c2'::text))::integer
               Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 81:
SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int order by (t1.v->>'c2')::int limit 1;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- but let's put them in an extension ...
ALTER EXTENSION parquet_s3_fdw ADD FUNCTION parquet_s3_fdw_abs(int);
ALTER EXTENSION parquet_s3_fdw ADD OPERATOR === (int, int);
ALTER SERVER parquet_s3_srv OPTIONS (ADD extensions 'parquet_s3_fdw');
-- ... now they can be shipped
--Testcase 82:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = parquet_s3_fdw_abs((t1.v->>'c2')::int);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::bigint = parquet_s3_fdw_abs(((t1.v ->> 'c2'::text))::integer))
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 83:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = parquet_s3_fdw_abs((t1.v->>'c2')::int);
 count 
-------
     9
(1 row)

--Testcase 84:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 85:
SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
 count 
-------
     9
(1 row)

-- and both ORDER BY and LIMIT can be shipped
--Testcase 86:
EXPLAIN (VERBOSE, COSTS OFF)
  SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int order by (t1.v->>'c2')::int limit 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: v, (((v ->> 'c2'::text))::integer)
   ->  Sort
         Output: v, (((v ->> 'c2'::text))::integer)
         Sort Key: (((t1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1 t1
               Output: v, ((v ->> 'c2'::text))::integer
               Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 87:
SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int order by (t1.v->>'c2')::int limit 1;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- ===================================================================
-- JOIN queries
-- ===================================================================
-- Analyze ft4 and ft5 so that we have better statistics. These tables do not
-- have use_remote_estimate set.
-- ANALYZE ft4;
-- ANALYZE ft5;
-- join two tables
--Testcase 88:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text)
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft1 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(18 rows)

--Testcase 89:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- join three tables
--Testcase 90:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) JOIN ft4 t3 ON ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10; 
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text)), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text)), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text), (t1.v ->> 'c3'::text)
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: t1.v, t3.v
                     Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft4 t3
                           Output: t3.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t1.v
                           ->  Foreign Scan on public.ft1 t1
                                 Output: t1.v
                                 Reader: Single File
                                 Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(27 rows)

--Testcase 91:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) JOIN ft4 t3 ON ((t3.v->>'c1')::int8 = (t1.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 22 |  2 | AAA022
 24 |  4 | AAA024
 26 |  6 | AAA026
 28 |  8 | AAA028
 30 |  0 | AAA030
 32 |  2 | AAA032
 34 |  4 | AAA034
 36 |  6 | AAA036
 38 |  8 | AAA038
 40 |  0 | AAA040
(10 rows)

-- left outer join
--Testcase 92:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Presorted Key: (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 93:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c1 
----+----
 22 |   
 24 | 24
 26 |   
 28 |   
 30 | 30
 32 |   
 34 |   
 36 | 36
 38 |   
 40 |   
(10 rows)

-- left outer join three tables
--Testcase 94:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft2 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v, t3.v
               ->  Merge Left Join
                     Output: t2.v, t3.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t3.v
                           ->  Foreign Scan on public.ft4 t3
                                 Output: t3.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 95:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

-- left outer join + placement of clauses.
-- clauses within the nullable side are not pulled up, but top level clause on
-- non-nullable side is pushed into non-nullable side
--Testcase 96:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t1.v->>'c2')::int8 as c2, (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM ft4 t1 LEFT JOIN (SELECT * FROM ft5 WHERE (v->>'c1')::int8 < 10) t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE (t1.v->>'c1')::int8 < 10;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Output: ((t1.v ->> 'c1'::text))::bigint, ((t1.v ->> 'c2'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c2'::text))::bigint
   Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft4 t1
         Output: t1.v
         Filter: (((t1.v ->> 'c1'::text))::bigint < 10)
         Reader: Single File
         Row groups: 1
   ->  Hash
         Output: ft5.v
         ->  Foreign Scan on public.ft5
               Output: ft5.v
               Filter: (((ft5.v ->> 'c1'::text))::bigint < 10)
               Reader: Single File
               Row groups: 1
(15 rows)

--Testcase 97:
SELECT (t1.v->>'c1')::int8 as c1, (t1.v->>'c2')::int8 as c2, (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM ft4 t1 LEFT JOIN (SELECT * FROM ft5 WHERE (v->>'c1')::int8 < 10) t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE (t1.v->>'c1')::int8 < 10;
 c1 | c2 | c1 | c2 
----+----+----+----
  2 |  3 |    |   
  4 |  5 |    |   
  6 |  7 |  6 |  7
  8 |  9 |    |   
(4 rows)

-- clauses within the nullable side are not pulled up, but the top level clause
-- on nullable side is not pushed down into nullable side
--Testcase 98:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t1.v->>'c2')::int8 as c2, (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM ft4 t1 LEFT JOIN (SELECT * FROM ft5 WHERE (v->>'c1')::int8 < 10) t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)
			WHERE ((t2.v->>'c1')::int8 < 10 OR (t2.v->>'c1')::int8 IS NULL) AND (t1.v->>'c1')::int8 < 10;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Output: ((t1.v ->> 'c1'::text))::bigint, ((t1.v ->> 'c2'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c2'::text))::bigint
   Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
   Filter: ((((ft5.v ->> 'c1'::text))::bigint < 10) OR (((ft5.v ->> 'c1'::text))::bigint IS NULL))
   ->  Foreign Scan on public.ft4 t1
         Output: t1.v
         Filter: (((t1.v ->> 'c1'::text))::bigint < 10)
         Reader: Single File
         Row groups: 1
   ->  Hash
         Output: ft5.v
         ->  Foreign Scan on public.ft5
               Output: ft5.v
               Filter: (((ft5.v ->> 'c1'::text))::bigint < 10)
               Reader: Single File
               Row groups: 1
(16 rows)

--Testcase 99:
SELECT (t1.v->>'c1')::int8 as c1, (t1.v->>'c2')::int8 as c2, (t2.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM ft4 t1 LEFT JOIN (SELECT * FROM ft5 WHERE (v->>'c1')::int8 < 10) t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)
			WHERE ((t2.v->>'c1')::int8 < 10 OR (t2.v->>'c1')::int8 IS NULL) AND (t1.v->>'c1')::int8 < 10;
 c1 | c2 | c1 | c2 
----+----+----+----
  2 |  3 |    |   
  4 |  5 |    |   
  6 |  7 |  6 |  7
  8 |  9 |    |   
(4 rows)

-- right outer join
--Testcase 100:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft5 t1 RIGHT JOIN ft4 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t2.v->>'c1')::int8, (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t2.v ->> 'c1'::text))::bigint), (((t1.v ->> 'c1'::text))::bigint)
         Presorted Key: (((t2.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t1.v
                     ->  Foreign Scan on public.ft5 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 101:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft5 t1 RIGHT JOIN ft4 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t2.v->>'c1')::int8, (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c1 
----+----
    | 22
 24 | 24
    | 26
    | 28
 30 | 30
    | 32
    | 34
 36 | 36
    | 38
    | 40
(10 rows)

-- right outer join three tables
--Testcase 102:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4 t3
               Output: t3.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v, t1.v
               ->  Merge Left Join
                     Output: t2.v, t1.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t1.v
                           ->  Foreign Scan on public.ft2 t1
                                 Output: t1.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 103:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 22 |  2 | AAA022
 24 |  4 | AAA024
 26 |  6 | AAA026
 28 |  8 | AAA028
 30 |  0 | AAA030
 32 |  2 | AAA032
 34 |  4 | AAA034
 36 |  6 | AAA036
 38 |  8 | AAA038
 40 |  0 | AAA040
(10 rows)

-- full outer join
--Testcase 104:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 FULL JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 45 LIMIT 10;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         ->  Hash Full Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(18 rows)

--Testcase 105:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 FULL JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 45 LIMIT 10;
 c1  | c1 
-----+----
  92 |   
  94 |   
  96 | 96
  98 |   
 100 |   
     |  3
     |  9
     | 15
     | 21
     | 27
(10 rows)

-- full outer join with restrictions on the joining relations
-- a. the joining relations are both base relations
--Testcase 106:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.c1, t2.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t2 ON (t1.c1 = t2.c1) ORDER BY t1.c1, t2.c1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   ->  Hash Full Join
         Output: ((ft4.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint
         Hash Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4
               Output: ft4.v
               Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: ft5.v
               ->  Foreign Scan on public.ft5
                     Output: ft5.v
                     Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(18 rows)

--Testcase 107:
SELECT t1.c1, t2.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t2 ON (t1.c1 = t2.c1) ORDER BY t1.c1, t2.c1;
 c1 | c1 
----+----
 50 |   
 52 |   
 54 | 54
 56 |   
 58 |   
 60 | 60
    | 51
    | 57
(8 rows)

--Testcase 108:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT 1 FROM (SELECT (v->>'c1')::int8 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (v->>'c1')::int8 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t2 ON (TRUE) OFFSET 10 LIMIT 10;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Limit
   Output: 1
   ->  Merge Full Join
         Output: 1
         ->  Foreign Scan on public.ft5
               Output: ft5.v
               Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: ft4.v
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(16 rows)

--Testcase 109:
SELECT 1 FROM (SELECT (v->>'c1')::int8 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (v->>'c1')::int8 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t2 ON (TRUE) OFFSET 10 LIMIT 10;
 ?column? 
----------
        1
        1
        1
        1
        1
        1
        1
        1
        1
        1
(10 rows)

-- b. one of the joining relations is a base relation and the other is a join
-- relation
--Testcase 110:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft4 t2 LEFT JOIN ft5 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) WHERE ((t2.v->>'c1')::int8 between 50 and 60)) ss(a, b) ON (t1.c1 = ss.a) ORDER BY t1.c1, ss.a, ss.b;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   ->  Hash Full Join
         Output: ((ft4.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
         Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((ft4.v ->> 'c1'::text))::bigint)
         ->  Nested Loop Left Join
               Output: t2.v, t3.v
               Join Filter: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t2
                     Output: t2.v
                     Filter: ((((t2.v ->> 'c1'::text))::bigint >= 50) AND (((t2.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
               ->  Foreign Scan on public.ft5 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
         ->  Hash
               Output: ft4.v
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(25 rows)

--Testcase 111:
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft4 t2 LEFT JOIN ft5 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) WHERE ((t2.v->>'c1')::int8 between 50 and 60)) ss(a, b) ON (t1.c1 = ss.a) ORDER BY t1.c1, ss.a, ss.b;
 c1 | a  | b  
----+----+----
 50 | 50 |   
 52 | 52 |   
 54 | 54 | 54
 56 | 56 |   
 58 | 58 |   
 60 | 60 | 60
(6 rows)

-- c. test deparsing the remote query as nested subqueries
--Testcase 112:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT t2.c1, t3.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t2 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t3 ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (t1.c1 = ss.a) ORDER BY t1.c1, ss.a, ss.b;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft4_1.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft4_1.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   ->  Hash Full Join
         Output: ((ft4.v ->> 'c1'::text))::bigint, ((ft4_1.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint
         Hash Cond: (((ft4_1.v ->> 'c1'::text))::bigint = ((ft4.v ->> 'c1'::text))::bigint)
         ->  Hash Full Join
               Output: ft4_1.v, ft5.v
               Hash Cond: (((ft4_1.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
               Filter: ((((ft4_1.v ->> 'c1'::text))::bigint IS NULL) OR (((ft4_1.v ->> 'c1'::text))::bigint IS NOT NULL))
               ->  Foreign Scan on public.ft4 ft4_1
                     Output: ft4_1.v
                     Filter: ((((ft4_1.v ->> 'c1'::text))::bigint >= 50) AND (((ft4_1.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: ft5.v
                     ->  Foreign Scan on public.ft5
                           Output: ft5.v
                           Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: ft4.v
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(29 rows)

--Testcase 113:
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t1 FULL JOIN (SELECT t2.c1, t3.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t2 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t3 ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (t1.c1 = ss.a) ORDER BY t1.c1, ss.a, ss.b;
 c1 | a  | b  
----+----+----
 50 | 50 |   
 52 | 52 |   
 54 | 54 | 54
 56 | 56 |   
 58 | 58 |   
 60 | 60 | 60
    |    | 51
    |    | 57
(8 rows)

-- d. test deparsing rowmarked relations as subqueries
--Testcase 114:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM "S 1"."T3" WHERE (v->>'c1')::int8 = 50) t1 INNER JOIN (SELECT t2.c1, t3.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t2 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t3 ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (TRUE) ORDER BY t1.c1, ss.a, ss.b FOR UPDATE OF t1;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 LockRows
   Output: ((("T3".v ->> 'c1'::text))::bigint), (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint), "T3".*, ft4.*, ft5.*
   ->  Sort
         Output: ((("T3".v ->> 'c1'::text))::bigint), (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint), "T3".*, ft4.*, ft5.*
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         ->  Nested Loop
               Output: (("T3".v ->> 'c1'::text))::bigint, ((ft4.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint, "T3".*, ft4.*, ft5.*
               ->  Foreign Scan on "S 1"."T3"
                     Output: "T3".v, "T3".*
                     Filter: ((("T3".v ->> 'c1'::text))::bigint = 50)
                     Reader: Single File
                     Row groups: 1
               ->  Hash Full Join
                     Output: ft4.v, ft4.*, ft5.v, ft5.*
                     Hash Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
                     Filter: ((((ft4.v ->> 'c1'::text))::bigint IS NULL) OR (((ft4.v ->> 'c1'::text))::bigint IS NOT NULL))
                     ->  Foreign Scan on public.ft4
                           Output: ft4.v, ft4.*
                           Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: ft5.v, ft5.*
                           ->  Foreign Scan on public.ft5
                                 Output: ft5.v, ft5.*
                                 Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
                                 Reader: Single File
                                 Row groups: 1
(28 rows)

--Testcase 115:
SELECT t1.c1, ss.a, ss.b FROM (SELECT (v->>'c1')::int8 as c1 FROM "S 1"."T3" WHERE (v->>'c1')::int8 = 50) t1 INNER JOIN (SELECT t2.c1, t3.c1 FROM (SELECT (v->>'c1')::int8 as c1 FROM ft4 WHERE (v->>'c1')::int8 between 50 and 60) t2 FULL JOIN (SELECT (v->>'c1')::int8 as c1 FROM ft5 WHERE (v->>'c1')::int8 between 50 and 60) t3 ON (t2.c1 = t3.c1) WHERE t2.c1 IS NULL OR t2.c1 IS NOT NULL) ss(a, b) ON (TRUE) ORDER BY t1.c1, ss.a, ss.b FOR UPDATE OF t1;
 c1 | a  | b  
----+----+----
 50 | 50 |   
 50 | 52 |   
 50 | 54 | 54
 50 | 56 |   
 50 | 58 |   
 50 | 60 | 60
 50 |    | 51
 50 |    | 57
(8 rows)

-- full outer join + inner join
--Testcase 116:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft4 t1 INNER JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 + 1 and (t1.v->>'c1')::int8 between 50 and 60) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8, (t3.v->>'c1')::int8 LIMIT 10;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
         ->  Hash Full Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
               Hash Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t1.v, t2.v
                     ->  Nested Loop
                           Output: t1.v, t2.v
                           Join Filter: (((t1.v ->> 'c1'::text))::bigint = (((t2.v ->> 'c1'::text))::bigint + 1))
                           ->  Foreign Scan on public.ft4 t1
                                 Output: t1.v
                                 Filter: ((((t1.v ->> 'c1'::text))::bigint >= 50) AND (((t1.v ->> 'c1'::text))::bigint <= 60))
                                 Reader: Single File
                                 Row groups: 1
                           ->  Foreign Scan on public.ft5 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(26 rows)

--Testcase 117:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft4 t1 INNER JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 + 1 and (t1.v->>'c1')::int8 between 50 and 60) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8, (t3.v->>'c1')::int8 LIMIT 10;
 c1 | c1 | c1 
----+----+----
 52 | 51 |   
 58 | 57 |   
    |    |  2
    |    |  4
    |    |  6
    |    |  8
    |    | 10
    |    | 12
    |    | 14
    |    | 16
(10 rows)

-- full outer join three tables
--Testcase 118:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Hash Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Merge Full Join
               Output: t1.v, t2.v
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: t3.v
               ->  Foreign Scan on public.ft4 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 119:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

-- full outer join + right outer join
--Testcase 120:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4 t3
               Output: t3.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v, t1.v
               ->  Merge Left Join
                     Output: t2.v, t1.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t1.v
                           ->  Foreign Scan on public.ft2 t1
                                 Output: t1.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 121:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 22 |  2 | AAA022
 24 |  4 | AAA024
 26 |  6 | AAA026
 28 |  8 | AAA028
 30 |  0 | AAA030
 32 |  2 | AAA032
 34 |  4 | AAA034
 36 |  6 | AAA036
 38 |  8 | AAA038
 40 |  0 | AAA040
(10 rows)

-- right outer join + full outer join
--Testcase 122:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4 t3
               Output: t3.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v, t1.v
               ->  Merge Left Join
                     Output: t2.v, t1.v
                     Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t1.v
                           ->  Foreign Scan on public.ft2 t1
                                 Output: t1.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 123:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

-- full outer join + left outer join
--Testcase 124:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Hash Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Merge Full Join
               Output: t1.v, t2.v
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: t3.v
               ->  Foreign Scan on public.ft4 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 125:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

-- left outer join + full outer join
--Testcase 126:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Hash Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: t1.v, t2.v
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
         ->  Hash
               Output: t3.v
               ->  Foreign Scan on public.ft4 t3
                     Output: t3.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 127:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) FULL JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

SET enable_memoize TO off;
-- right outer join + left outer join
--Testcase 128:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: t2.v, t3.v
               Merge Cond: (((t2.v ->> 'c1'::text))::bigint = ((t3.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t3.v
                     ->  Foreign Scan on public.ft4 t3
                           Output: t3.v
                           Reader: Single File
                           Row groups: 1
         ->  Materialize
               Output: t1.v
               ->  Foreign Scan on public.ft2 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
(24 rows)

--Testcase 129:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 RIGHT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) LEFT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 11 |  1 | 
 12 |  2 | AAA012
 13 |  3 | 
 14 |  4 | AAA014
 15 |  5 | 
 16 |  6 | AAA016
 17 |  7 | 
 18 |  8 | AAA018
 19 |  9 | 
 20 |  0 | AAA020
(10 rows)

RESET enable_memoize;
-- left outer join + right outer join
--Testcase 130:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), ((t3.v ->> 'c3'::text))
   ->  Merge Left Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, (t3.v ->> 'c3'::text)
         Merge Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4 t3
               Output: t3.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t1.v, t2.v
               ->  Merge Join
                     Output: t1.v, t2.v
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(24 rows)

--Testcase 131:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2, (t3.v->>'c3') as c3 FROM ft2 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) RIGHT JOIN ft4 t3 ON ((t2.v->>'c1')::int8 = (t3.v->>'c1')::int8) OFFSET 10 LIMIT 10;
 c1 | c2 |   c3   
----+----+--------
 22 |  2 | AAA022
 24 |  4 | AAA024
 26 |  6 | AAA026
 28 |  8 | AAA028
 30 |  0 | AAA030
 32 |  2 | AAA032
 34 |  4 | AAA034
 36 |  6 | AAA036
 38 |  8 | AAA038
 40 |  0 | AAA040
(10 rows)

-- full outer join + WHERE clause, only matched rows
--Testcase 132:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 FULL JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 OR (t1.v->>'c1')::int8 IS NULL) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         ->  Hash Full Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               Filter: ((((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint) OR (((t1.v ->> 'c1'::text))::bigint IS NULL))
               ->  Foreign Scan on public.ft4 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 133:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft4 t1 FULL JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8 OR (t1.v->>'c1')::int8 IS NULL) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c1 
----+----
 66 | 66
 72 | 72
 78 | 78
 84 | 84
 90 | 90
 96 | 96
    |  3
    |  9
    | 15
    | 21
(10 rows)

-- full outer join + WHERE clause with shippable extensions set
--Testcase 134:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8, t2.v->>'c2', t1.v->>'c3' FROM ft1 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE parquet_s3_fdw_abs((t1.v->>'c1')::int) > 0 OFFSET 10 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), ((t2.v ->> 'c2'::text)), ((t1.v ->> 'c3'::text))
   ->  Merge Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, (t2.v ->> 'c2'::text), (t1.v ->> 'c3'::text)
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         Filter: (parquet_s3_fdw_abs(((t1.v ->> 'c1'::text))::integer) > 0)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(16 rows)

ALTER SERVER parquet_s3_srv OPTIONS (DROP extensions);
-- full outer join + WHERE clause with shippable extensions not set
--Testcase 135:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8, t2.v->>'c2', t1.v->>'c3' FROM ft1 t1 FULL JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE parquet_s3_fdw_abs((t1.v->>'c1')::int) > 0 OFFSET 10 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), ((t2.v ->> 'c2'::text)), ((t1.v ->> 'c3'::text))
   ->  Merge Full Join
         Output: ((t1.v ->> 'c1'::text))::bigint, (t2.v ->> 'c2'::text), (t1.v ->> 'c3'::text)
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         Filter: (parquet_s3_fdw_abs(((t1.v ->> 'c1'::text))::integer) > 0)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(16 rows)

ALTER SERVER parquet_s3_srv OPTIONS (ADD extensions 'parquet_s3_fdw');
-- join two tables with FOR UPDATE clause
-- tests whole-row reference for row marks
--Testcase 136:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR UPDATE OF t1;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
   ->  LockRows
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
         ->  Sort
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
               Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), t1.*, t2.*
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, t1.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v, t2.*
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v, t2.*
                                 Reader: Single File
                                 Row groups: 1
(20 rows)

--Testcase 137:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR UPDATE OF t1;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

--Testcase 138:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR UPDATE;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
   ->  LockRows
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
         ->  Sort
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
               Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), t1.*, t2.*
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, t1.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v, t2.*
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v, t2.*
                                 Reader: Single File
                                 Row groups: 1
(20 rows)

--Testcase 139:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR UPDATE;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- join two tables with FOR SHARE clause
--Testcase 140:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR SHARE OF t1;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
   ->  LockRows
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
         ->  Sort
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
               Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), t1.*, t2.*
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, t1.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v, t2.*
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v, t2.*
                                 Reader: Single File
                                 Row groups: 1
(20 rows)

--Testcase 141:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR SHARE OF t1;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

--Testcase 142:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR SHARE;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
   ->  LockRows
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
         ->  Sort
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text)), t1.*, t2.*
               Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), t1.*, t2.*
                     Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, t1.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: t2.v, t2.*
                           ->  Foreign Scan on public.ft2 t2
                                 Output: t2.v, t2.*
                                 Reader: Single File
                                 Row groups: 1
(20 rows)

--Testcase 143:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10 FOR SHARE;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- join in CTE
--Testcase 144:
EXPLAIN (VERBOSE, COSTS OFF)
WITH t (c1_1, c1_3, c2_1) AS MATERIALIZED (SELECT (t1.v->>'c1')::int8, t1.v->>'c3', (t2.v->>'c1')::int8 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)) SELECT c1_1, c2_1 FROM t ORDER BY c1_3, c1_1 OFFSET 100 LIMIT 10;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Limit
   Output: t.c1_1, t.c2_1, t.c1_3
   CTE t
     ->  Merge Join
           Output: ((t1.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text), ((t2.v ->> 'c1'::text))::bigint
           Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
           ->  Foreign Scan on public.ft1 t1
                 Output: t1.v
                 Reader: Single File
                 Row groups: 1
           ->  Materialize
                 Output: t2.v
                 ->  Foreign Scan on public.ft2 t2
                       Output: t2.v
                       Reader: Single File
                       Row groups: 1
   ->  Sort
         Output: t.c1_1, t.c2_1, t.c1_3
         Sort Key: t.c1_3, t.c1_1
         ->  CTE Scan on t
               Output: t.c1_1, t.c2_1, t.c1_3
(21 rows)

--Testcase 145:
WITH t (c1_1, c1_3, c2_1) AS MATERIALIZED (SELECT (t1.v->>'c1')::int8, t1.v->>'c3', (t2.v->>'c1')::int8 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)) SELECT c1_1, c2_1 FROM t ORDER BY c1_3, c1_1 OFFSET 100 LIMIT 10;
 c1_1 | c2_1 
------+------
  101 |  101
  102 |  102
  103 |  103
  104 |  104
  105 |  105
  106 |  106
  107 |  107
  108 |  108
  109 |  109
  110 |  110
(10 rows)

-- ctid with whole-row reference
--Testcase 146:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1.ctid, t1, t2, (t1.v->>'c1')::int8 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Limit
   Output: t1.ctid, t1.*, t2.*, (((t1.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: t1.ctid, t1.*, t2.*, (((t1.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Join
               Output: t1.ctid, t1.*, t2.*, ((t1.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text)
               Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft1 t1
                     Output: t1.ctid, t1.*, t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.*, t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.*, t2.v
                           Reader: Single File
                           Row groups: 1
(18 rows)

-- SEMI JOIN, not pushed down
--Testcase 147:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 AS c1 FROM ft1 t1 WHERE EXISTS (SELECT 1 FROM ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint)
   ->  Merge Semi Join
         Output: ((t1.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Foreign Scan on public.ft2 t2
               Output: t2.v
               Reader: Single File
               Row groups: 1
(13 rows)

--Testcase 148:
SELECT (t1.v->>'c1')::int8 AS c1 FROM ft1 t1 WHERE EXISTS (SELECT 1 FROM ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  
-----
 101
 102
 103
 104
 105
 106
 107
 108
 109
 110
(10 rows)

-- ANTI JOIN, not pushed down
--Testcase 149:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 AS c1 FROM ft1 t1 WHERE NOT EXISTS (SELECT 1 FROM ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c2')::int8) ORDER BY (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint)
   ->  Merge Anti Join
         Output: ((t1.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = (((t2.v ->> 'c2'::text))::bigint))
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Sort
               Output: t2.v, (((t2.v ->> 'c2'::text))::bigint)
               Sort Key: (((t2.v ->> 'c2'::text))::bigint)
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v, ((t2.v ->> 'c2'::text))::bigint
                     Reader: Single File
                     Row groups: 1
(16 rows)

--Testcase 150:
SELECT (t1.v->>'c1')::int8 AS c1 FROM ft1 t1 WHERE NOT EXISTS (SELECT 1 FROM ft2 t2 WHERE (t1.v->>'c1')::int8 = (t2.v->>'c2')::int8) ORDER BY (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  
-----
 110
 111
 112
 113
 114
 115
 116
 117
 118
 119
(10 rows)

-- CROSS JOIN can be pushed down
--Testcase 151:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 CROSS JOIN ft2 t2 ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Presorted Key: (((t1.v ->> 'c1'::text))::bigint)
         ->  Nested Loop
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               ->  Foreign Scan on public.ft1 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(18 rows)

--Testcase 152:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 CROSS JOIN ft2 t2 ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1 | c1  
----+-----
  1 | 101
  1 | 102
  1 | 103
  1 | 104
  1 | 105
  1 | 106
  1 | 107
  1 | 108
  1 | 109
  1 | 110
(10 rows)

-- different server, not pushed down. No result expected.
--Testcase 153:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft5 t1 JOIN ft6 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Merge Join
         Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft5 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft6 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(15 rows)

--Testcase 154:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft5 t1 JOIN ft6 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1 | c1 
----+----
(0 rows)

-- unsafe join conditions (c8 has a UDT), not pushed down. Practically a CROSS
-- JOIN since c8 in both tables has same value.
--Testcase 155:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON (t1.v->>'c8' = t2.v->>'c8') ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((t1.v ->> 'c8'::text)) = ((t2.v ->> 'c8'::text)))
               ->  Sort
                     Output: t1.v, ((t1.v ->> 'c8'::text))
                     Sort Key: ((t1.v ->> 'c8'::text))
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, (t1.v ->> 'c8'::text)
                           Reader: Single File
                           Row groups: 1
               ->  Sort
                     Output: t2.v, ((t2.v ->> 'c8'::text))
                     Sort Key: ((t2.v ->> 'c8'::text))
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v, (t2.v ->> 'c8'::text)
                           Reader: Single File
                           Row groups: 1
(22 rows)

--Testcase 156:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON (t1.v->>'c8' = t2.v->>'c8') ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1 | c1  
----+-----
  1 | 101
  1 | 102
  1 | 103
  1 | 104
  1 | 105
  1 | 106
  1 | 107
  1 | 108
  1 | 109
  1 | 110
(10 rows)

-- unsafe conditions on one side (c8 has a UDT), not pushed down.
--Testcase 157:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE t1.v->>'c8' = 'foo' ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Hash Right Join
               Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint, (t1.v ->> 'c3'::text)
               Hash Cond: (((t2.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t1.v
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v
                           Filter: ((t1.v ->> 'c8'::text) = 'foo'::text)
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 158:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE t1.v->>'c8' = 'foo' ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- join where unsafe to pushdown condition in WHERE clause has a column not
-- in the SELECT clause. In this test unsafe clause needs to have column
-- references from both joining sides so that the clause is not pushed down
-- into one of the joining sides.
--Testcase 159:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE t1.v->>'c8' = t2.v->>'c8' ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c3'::text))
         Sort Key: ((t1.v ->> 'c3'::text)), (((t1.v ->> 'c1'::text))::bigint)
         ->  Merge Join
               Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint), (t1.v ->> 'c3'::text)
               Merge Cond: (((((t1.v ->> 'c1'::text))::bigint) = (((t2.v ->> 'c1'::text))::bigint)) AND (((t1.v ->> 'c8'::text)) = ((t2.v ->> 'c8'::text))))
               ->  Sort
                     Output: t1.v, (((t1.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c8'::text))
                     Sort Key: (((t1.v ->> 'c1'::text))::bigint), ((t1.v ->> 'c8'::text))
                     ->  Foreign Scan on public.ft1 t1
                           Output: t1.v, ((t1.v ->> 'c1'::text))::bigint, (t1.v ->> 'c8'::text)
                           Reader: Single File
                           Row groups: 1
               ->  Sort
                     Output: t2.v, (((t2.v ->> 'c1'::text))::bigint), ((t2.v ->> 'c8'::text))
                     Sort Key: (((t2.v ->> 'c1'::text))::bigint), ((t2.v ->> 'c8'::text))
                     ->  Foreign Scan on public.ft2 t2
                           Output: t2.v, ((t2.v ->> 'c1'::text))::bigint, (t2.v ->> 'c8'::text)
                           Reader: Single File
                           Row groups: 1
(22 rows)

--Testcase 160:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) WHERE t1.v->>'c8' = t2.v->>'c8' ORDER BY t1.v->>'c3', (t1.v->>'c1')::int8 OFFSET 100 LIMIT 10;
 c1  | c1  
-----+-----
 101 | 101
 102 | 102
 103 | 103
 104 | 104
 105 | 105
 106 | 106
 107 | 107
 108 | 108
 109 | 109
 110 | 110
(10 rows)

-- Aggregate after UNION, for testing setrefs
--Testcase 161:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT t1c1, avg(t1c1 + t2c1) FROM (SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) UNION SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)) AS t (t1c1, t2c1) GROUP BY t1c1 ORDER BY t1c1 OFFSET 100 LIMIT 10;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint), (avg(((((t1.v ->> 'c1'::text))::bigint) + (((t2.v ->> 'c1'::text))::bigint))))
   ->  Sort
         Output: (((t1.v ->> 'c1'::text))::bigint), (avg(((((t1.v ->> 'c1'::text))::bigint) + (((t2.v ->> 'c1'::text))::bigint))))
         Sort Key: (((t1.v ->> 'c1'::text))::bigint)
         ->  HashAggregate
               Output: (((t1.v ->> 'c1'::text))::bigint), avg(((((t1.v ->> 'c1'::text))::bigint) + (((t2.v ->> 'c1'::text))::bigint)))
               Group Key: (((t1.v ->> 'c1'::text))::bigint)
               ->  HashAggregate
                     Output: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
                     Group Key: (((t1.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
                     ->  Append
                           ->  Merge Join
                                 Output: ((t1.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
                                 Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                                 ->  Foreign Scan on public.ft1 t1
                                       Output: t1.v
                                       Reader: Single File
                                       Row groups: 1
                                 ->  Materialize
                                       Output: t2.v
                                       ->  Foreign Scan on public.ft2 t2
                                             Output: t2.v
                                             Reader: Single File
                                             Row groups: 1
                           ->  Merge Join
                                 Output: ((t1_1.v ->> 'c1'::text))::bigint, ((t2_1.v ->> 'c1'::text))::bigint
                                 Merge Cond: (((t1_1.v ->> 'c1'::text))::bigint = ((t2_1.v ->> 'c1'::text))::bigint)
                                 ->  Foreign Scan on public.ft1 t1_1
                                       Output: t1_1.v
                                       Reader: Single File
                                       Row groups: 1
                                 ->  Materialize
                                       Output: t2_1.v
                                       ->  Foreign Scan on public.ft2 t2_1
                                             Output: t2_1.v
                                             Reader: Single File
                                             Row groups: 1
(38 rows)

--Testcase 162:
SELECT t1c1, avg(t1c1 + t2c1) FROM (SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) UNION SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c1')::int8 as c1 FROM ft1 t1 JOIN ft2 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8)) AS t (t1c1, t2c1) GROUP BY t1c1 ORDER BY t1c1 OFFSET 100 LIMIT 10;
 t1c1 |         avg          
------+----------------------
  101 | 202.0000000000000000
  102 | 204.0000000000000000
  103 | 206.0000000000000000
  104 | 208.0000000000000000
  105 | 210.0000000000000000
  106 | 212.0000000000000000
  107 | 214.0000000000000000
  108 | 216.0000000000000000
  109 | 218.0000000000000000
  110 | 220.0000000000000000
(10 rows)

-- join with lateral reference
--Testcase 163:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1, LATERAL (SELECT DISTINCT (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft1 t2, ft2 t3 WHERE (t2.v->>'c1')::int8 = (t3.v->>'c1')::int8 AND (t2.v->>'c2')::int = (t1.v->>'c2')::int) q ORDER BY (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((t1.v ->> 'c1'::text))::bigint)
   ->  Nested Loop
         Output: ((t1.v ->> 'c1'::text))::bigint
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  HashAggregate
               Output: (((t2.v ->> 'c1'::text))::bigint), (((t3.v ->> 'c1'::text))::bigint)
               Group Key: ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
               ->  Hash Join
                     Output: ((t2.v ->> 'c1'::text))::bigint, ((t3.v ->> 'c1'::text))::bigint
                     Hash Cond: (((t3.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     ->  Foreign Scan on public.ft2 t3
                           Output: t3.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: t2.v
                           ->  Foreign Scan on public.ft1 t2
                                 Output: t2.v
                                 Filter: (((t2.v ->> 'c2'::text))::integer = ((t1.v ->> 'c2'::text))::integer)
                                 Reader: Single File
                                 Row groups: 1
(25 rows)

--Testcase 164:
SELECT (t1.v->>'c1')::int8 as c1 FROM "S 1"."T1" t1, LATERAL (SELECT DISTINCT (t2.v->>'c1')::int8 as c1, (t3.v->>'c1')::int8 as c1 FROM ft1 t2, ft2 t3 WHERE (t2.v->>'c1')::int8 = (t3.v->>'c1')::int8 AND (t2.v->>'c2')::int = (t1.v->>'c2')::int) q ORDER BY (t1.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 
----
  1
  1
  1
  1
  1
  1
  1
  1
  1
  1
(10 rows)

-- non-Var items in targetlist of the nullable rel of a join preventing
-- push-down in some cases
-- unable to push {ft1, ft2}
--Testcase 165:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT q.a, (ft2.v->>'c1')::int8 as c1 FROM (SELECT 13 FROM ft1 WHERE (v->>'c1')::int8 = 13) q(a) RIGHT JOIN ft2 ON (q.a = (ft2.v->>'c1')::int8) WHERE (ft2.v->>'c1')::int8 BETWEEN 10 AND 15;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: (13), ((ft2.v ->> 'c1'::text))::bigint
   Join Filter: (13 = ((ft2.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft2
         Output: ft2.v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint >= 10) AND (((ft2.v ->> 'c1'::text))::bigint <= 15))
         Reader: Single File
         Row groups: 1
   ->  Materialize
         Output: (13)
         ->  Foreign Scan on public.ft1
               Output: 13
               Filter: (((ft1.v ->> 'c1'::text))::bigint = 13)
               Reader: Single File
               Row groups: 1
(15 rows)

--Testcase 166:
SELECT q.a, (ft2.v->>'c1')::int8 as c1 FROM (SELECT 13 FROM ft1 WHERE (v->>'c1')::int8 = 13) q(a) RIGHT JOIN ft2 ON (q.a = (ft2.v->>'c1')::int8) WHERE (ft2.v->>'c1')::int8 BETWEEN 10 AND 15;
 a  | c1 
----+----
    | 10
    | 11
    | 12
 13 | 13
    | 14
    | 15
(6 rows)

-- ok to push {ft1, ft2} but not {ft1, ft2, ft4}
--Testcase 167:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (ft4.v->>'c1')::int8 as c1, q.* FROM ft4 LEFT JOIN (SELECT 13, (ft1.v->>'c1')::int8, (ft2.v->>'c1')::int8 FROM ft1 RIGHT JOIN ft2 ON ((ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8) WHERE (ft1.v->>'c1')::int8 = 12) q(a, b, c) ON ((ft4.v->>'c1')::int8 = q.b) WHERE (ft4.v->>'c1')::int8 BETWEEN 10 AND 15;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: ((ft4.v ->> 'c1'::text))::bigint, (13), ((ft1.v ->> 'c1'::text))::bigint, ((ft2.v ->> 'c1'::text))::bigint
   Join Filter: (((ft4.v ->> 'c1'::text))::bigint = ((ft1.v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft4
         Output: ft4.v
         Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 10) AND (((ft4.v ->> 'c1'::text))::bigint <= 15))
         Reader: Single File
         Row groups: 1
   ->  Nested Loop
         Output: ft1.v, ft2.v, 13
         ->  Foreign Scan on public.ft1
               Output: ft1.v
               Filter: (((ft1.v ->> 'c1'::text))::bigint = 12)
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: ft2.v
               ->  Foreign Scan on public.ft2
                     Output: ft2.v
                     Filter: (((ft2.v ->> 'c1'::text))::bigint = 12)
                     Reader: Single File
                     Row groups: 1
(22 rows)

--Testcase 168:
SELECT (ft4.v->>'c1')::int8 as c1, q.* FROM ft4 LEFT JOIN (SELECT 13, (ft1.v->>'c1')::int8, (ft2.v->>'c1')::int8 FROM ft1 RIGHT JOIN ft2 ON ((ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8) WHERE (ft1.v->>'c1')::int8 = 12) q(a, b, c) ON ((ft4.v->>'c1')::int8 = q.b) WHERE (ft4.v->>'c1')::int8 BETWEEN 10 AND 15;
 c1 | a  | b  | c  
----+----+----+----
 10 |    |    |   
 12 | 13 | 12 | 12
 14 |    |    |   
(3 rows)

-- join with nullable side with some columns with null values
--parquet_s3_fdw does not support UPDATE
-- UPDATE ft5 SET c3 = null where v->>'c1' % 9 = 0;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT ft5, ft5.c1, ft5.c2, ft5.c3, ft4.c1, ft4.c2 FROM ft5 left join ft4 on ft5.c1 = ft4.c1 WHERE ft4.c1 BETWEEN 10 and 30 ORDER BY ft5.c1, ft4.c1;
-- SELECT ft5, ft5.c1, ft5.c2, ft5.c3, ft4.c1, ft4.c2 FROM ft5 left join ft4 on ft5.c1 = ft4.c1 WHERE ft4.c1 BETWEEN 10 and 30 ORDER BY ft5.c1, ft4.c1;
-- multi-way join involving multiple merge joins
-- (this case used to have EPQ-related planning problems)
\set var :PATH_FILENAME'/ported_postgres/local_tbl.parquet'
--Testcase 169:
CREATE FOREIGN TABLE local_tbl (v jsonb)
SERVER parquet_s3_srv
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
-- ANALYZE local_tbl;
SET enable_nestloop TO false;
SET enable_hashjoin TO false;
--Testcase 170:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM ft1, ft2, ft4, ft5, local_tbl WHERE (ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8 AND (ft1.v->>'c2')::int = (ft4.v->>'c1')::int8
    AND (ft1.v->>'c2')::int = (ft5.v->>'c1')::int8 AND (ft1.v->>'c2')::int = (local_tbl.v->>'c1')::int8 AND (ft1.v->>'c1')::int8 < 100 AND (ft2.v->>'c1')::int8 < 100 ORDER BY (ft1.v->>'c1')::int8 FOR UPDATE;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 LockRows
   Output: ft1.v, ft2.v, ft4.v, ft5.v, local_tbl.v, (((ft1.v ->> 'c1'::text))::bigint), ft1.*, ft2.*, ft4.*, ft5.*, local_tbl.*
   ->  Merge Join
         Output: ft1.v, ft2.v, ft4.v, ft5.v, local_tbl.v, (((ft1.v ->> 'c1'::text))::bigint), ft1.*, ft2.*, ft4.*, ft5.*, local_tbl.*
         Merge Cond: ((((ft1.v ->> 'c1'::text))::bigint) = ((ft2.v ->> 'c1'::text))::bigint)
         ->  Sort
               Output: ft1.v, ft1.*, ft4.v, ft4.*, ft5.v, ft5.*, local_tbl.v, local_tbl.*, (((ft1.v ->> 'c1'::text))::bigint)
               Sort Key: (((ft1.v ->> 'c1'::text))::bigint)
               ->  Merge Join
                     Output: ft1.v, ft1.*, ft4.v, ft4.*, ft5.v, ft5.*, local_tbl.v, local_tbl.*, ((ft1.v ->> 'c1'::text))::bigint
                     Merge Cond: (((local_tbl.v ->> 'c1'::text))::bigint = ((ft1.v ->> 'c2'::text))::integer)
                     ->  Foreign Scan on public.local_tbl
                           Output: local_tbl.v, local_tbl.*
                           Reader: Single File
                           Row groups: 1
                     ->  Materialize
                           Output: ft1.v, ft1.*, ft4.v, ft4.*, ft5.v, ft5.*
                           ->  Merge Join
                                 Output: ft1.v, ft1.*, ft4.v, ft4.*, ft5.v, ft5.*
                                 Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = (((ft1.v ->> 'c2'::text))::integer))
                                 ->  Merge Join
                                       Output: ft4.v, ft4.*, ft5.v, ft5.*
                                       Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
                                       ->  Foreign Scan on public.ft4
                                             Output: ft4.v, ft4.*
                                             Reader: Single File
                                             Row groups: 1
                                       ->  Materialize
                                             Output: ft5.v, ft5.*
                                             ->  Foreign Scan on public.ft5
                                                   Output: ft5.v, ft5.*
                                                   Reader: Single File
                                                   Row groups: 1
                                 ->  Sort
                                       Output: ft1.v, ft1.*, (((ft1.v ->> 'c2'::text))::integer)
                                       Sort Key: (((ft1.v ->> 'c2'::text))::integer)
                                       ->  Foreign Scan on public.ft1
                                             Output: ft1.v, ft1.*, ((ft1.v ->> 'c2'::text))::integer
                                             Filter: (((ft1.v ->> 'c1'::text))::bigint < 100)
                                             Reader: Single File
                                             Row groups: 1
         ->  Materialize
               Output: ft2.v, ft2.*
               ->  Foreign Scan on public.ft2
                     Output: ft2.v, ft2.*
                     Filter: (((ft2.v ->> 'c1'::text))::bigint < 100)
                     Reader: Single File
                     Row groups: 1
(48 rows)

--Testcase 171:
SELECT * FROM ft1, ft2, ft4, ft5, local_tbl WHERE (ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8 AND (ft1.v->>'c2')::int = (ft4.v->>'c1')::int8
    AND (ft1.v->>'c2')::int = (ft5.v->>'c1')::int8 AND (ft1.v->>'c2')::int = (local_tbl.v->>'c1')::int8 AND (ft1.v->>'c1')::int8 < 100 AND (ft2.v->>'c1')::int8 < 100 ORDER BY (ft1.v->>'c1')::int8 FOR UPDATE;
                                                    v                                                    |                                                    v                                                    |                 v                  |                 v                  |                v                 
---------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------+------------------------------------+------------------------------------+----------------------------------
 {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}  | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 26, "c2": 6, "c3": "00026", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 26, "c2": 6, "c3": "00026", "c5": "Tue Jan 27 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 56, "c2": 6, "c3": "00056", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 56, "c2": 6, "c3": "00056", "c5": "Thu Feb 26 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 66, "c2": 6, "c3": "00066", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 66, "c2": 6, "c3": "00066", "c5": "Sun Mar 08 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 76, "c2": 6, "c3": "00076", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 76, "c2": 6, "c3": "00076", "c5": "Wed Mar 18 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 86, "c2": 6, "c3": "00086", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 86, "c2": 6, "c3": "00086", "c5": "Sat Mar 28 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
 {"c1": 96, "c2": 6, "c3": "00096", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 96, "c2": 6, "c3": "00096", "c5": "Tue Apr 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 7, "c3": "AAA006"} | {"c1": 6, "c2": 6, "c3": "0006"}
(10 rows)

RESET enable_nestloop;
RESET enable_hashjoin;
--Testcase 172:
DROP FOREIGN TABLE local_tbl;
-- check join pushdown in situations where multiple userids are involved
--Testcase 173:
CREATE ROLE regress_view_owner SUPERUSER;
--Testcase 174:
CREATE USER MAPPING FOR regress_view_owner SERVER parquet_s3_srv;
GRANT SELECT ON ft4 TO regress_view_owner;
GRANT SELECT ON ft5 TO regress_view_owner;
--Testcase 175:
CREATE VIEW v4 AS SELECT * FROM ft4;
--Testcase 176:
CREATE VIEW v5 AS SELECT * FROM ft5;
ALTER VIEW v5 OWNER TO regress_view_owner;
--Testcase 177:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN v5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can't be pushed down, different view owners
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c2'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c2'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         Presorted Key: (((ft4.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((ft4.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c2'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint
               Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: ft5.v
                     ->  Foreign Scan on public.ft5
                           Output: ft5.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 178:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN v5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can't be pushed down, different view owners
 c1 | c2 
----+----
 22 |   
 24 | 25
 26 |   
 28 |   
 30 | 31
 32 |   
 34 |   
 36 | 37
 38 |   
 40 |   
(10 rows)

ALTER VIEW v4 OWNER TO regress_view_owner;
--Testcase 179:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN v5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can be pushed down
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c2'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c2'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((ft5.v ->> 'c1'::text))::bigint)
         Presorted Key: (((ft4.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((ft4.v ->> 'c1'::text))::bigint, ((ft5.v ->> 'c2'::text))::bigint, ((ft5.v ->> 'c1'::text))::bigint
               Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: ft5.v
                     ->  Foreign Scan on public.ft5
                           Output: ft5.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 180:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN v5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can be pushed down
 c1 | c2 
----+----
 22 |   
 24 | 25
 26 |   
 28 |   
 30 | 31
 32 |   
 34 |   
 36 | 37
 38 |   
 40 |   
(10 rows)

--Testcase 181:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can't be pushed down, view owner not current user
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Presorted Key: (((ft4.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((ft4.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 182:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;
 c1 | c2 
----+----
 22 |   
 24 | 25
 26 |   
 28 |   
 30 | 31
 32 |   
 34 |   
 36 | 37
 38 |   
 40 |   
(10 rows)

ALTER VIEW v4 OWNER TO CURRENT_USER;
--Testcase 183:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can be pushed down
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
   ->  Incremental Sort
         Output: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c2'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Sort Key: (((ft4.v ->> 'c1'::text))::bigint), (((t2.v ->> 'c1'::text))::bigint)
         Presorted Key: (((ft4.v ->> 'c1'::text))::bigint)
         ->  Merge Left Join
               Output: ((ft4.v ->> 'c1'::text))::bigint, ((t2.v ->> 'c2'::text))::bigint, ((t2.v ->> 'c1'::text))::bigint
               Merge Cond: (((ft4.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4
                     Output: ft4.v
                     Reader: Single File
                     Row groups: 1
               ->  Materialize
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(19 rows)

--Testcase 184:
SELECT (t1.v->>'c1')::int8 as c1, (t2.v->>'c2')::int8 as c2 FROM v4 t1 LEFT JOIN ft5 t2 ON ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) ORDER BY (t1.v->>'c1')::int8, (t2.v->>'c1')::int8 OFFSET 10 LIMIT 10;  -- can be pushed down
 c1 | c2 
----+----
 22 |   
 24 | 25
 26 |   
 28 |   
 30 | 31
 32 |   
 34 |   
 36 | 37
 38 |   
 40 |   
(10 rows)

ALTER VIEW v4 OWNER TO regress_view_owner;
-- cleanup
--Testcase 185:
DROP OWNED BY regress_view_owner;
--Testcase 186:
DROP ROLE regress_view_owner;
-- ===================================================================
-- Aggregate and grouping queries
-- ===================================================================
-- Simple aggregates
--Testcase 187:
explain (verbose, costs off)
select count(v->>'c6'), sum((v->>'c1')::int8), avg((v->>'c1')::int8), min((v->>'c2')::int), max((v->>'c1')::int8), stddev((v->>'c2')::int), sum((v->>'c1')::int8) * (random() <= 1)::int as sum2 from ft1 where (v->>'c2')::int < 5 group by (v->>'c2')::int order by 1, 2;
                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Result
   Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), ((sum(((v ->> 'c1'::text))::bigint)) * (((random() <= '1'::double precision))::integer)::numeric), (((v ->> 'c2'::text))::integer)
   ->  Sort
         Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), (((v ->> 'c2'::text))::integer)
         Sort Key: (count((ft1.v ->> 'c6'::text))), (sum(((ft1.v ->> 'c1'::text))::bigint))
         ->  HashAggregate
               Output: count((v ->> 'c6'::text)), sum(((v ->> 'c1'::text))::bigint), avg(((v ->> 'c1'::text))::bigint), min((((v ->> 'c2'::text))::integer)), max(((v ->> 'c1'::text))::bigint), stddev((((v ->> 'c2'::text))::integer)), (((v ->> 'c2'::text))::integer)
               Group Key: ((ft1.v ->> 'c2'::text))::integer
               ->  Foreign Scan on public.ft1
                     Output: ((v ->> 'c2'::text))::integer, v
                     Filter: (((ft1.v ->> 'c2'::text))::integer < 5)
                     Reader: Single File
                     Row groups: 1
(13 rows)

--Testcase 188:
select count(v->>'c6'), sum((v->>'c1')::int8), avg((v->>'c1')::int8), min((v->>'c2')::int), max((v->>'c1')::int8), stddev((v->>'c2')::int), sum((v->>'c1')::int8) * (random() <= 1)::int as sum2 from ft1 where (v->>'c2')::int < 5 group by (v->>'c2')::int order by 1, 2;
 count |  sum  |         avg          | min | max  | stddev | sum2  
-------+-------+----------------------+-----+------+--------+-------
   100 | 49600 | 496.0000000000000000 |   1 |  991 |      0 | 49600
   100 | 49700 | 497.0000000000000000 |   2 |  992 |      0 | 49700
   100 | 49800 | 498.0000000000000000 |   3 |  993 |      0 | 49800
   100 | 49900 | 499.0000000000000000 |   4 |  994 |      0 | 49900
   100 | 50500 | 505.0000000000000000 |   0 | 1000 |      0 | 50500
(5 rows)

--Testcase 189:
explain (verbose, costs off)
select count(v->>'c6'), sum((v->>'c1')::int8), avg((v->>'c1')::int8), min((v->>'c2')::int), max((v->>'c1')::int8), stddev((v->>'c2')::int), sum((v->>'c1')::int8) * (random() <= 1)::int as sum2 from ft1 where (v->>'c2')::int < 5 group by (v->>'c2')::int order by 1, 2 limit 1;
                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), (((sum(((v ->> 'c1'::text))::bigint)) * (((random() <= '1'::double precision))::integer)::numeric)), (((v ->> 'c2'::text))::integer)
   ->  Result
         Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), ((sum(((v ->> 'c1'::text))::bigint)) * (((random() <= '1'::double precision))::integer)::numeric), (((v ->> 'c2'::text))::integer)
         ->  Sort
               Output: (count((v ->> 'c6'::text))), (sum(((v ->> 'c1'::text))::bigint)), (avg(((v ->> 'c1'::text))::bigint)), (min((((v ->> 'c2'::text))::integer))), (max(((v ->> 'c1'::text))::bigint)), (stddev((((v ->> 'c2'::text))::integer))), (((v ->> 'c2'::text))::integer)
               Sort Key: (count((ft1.v ->> 'c6'::text))), (sum(((ft1.v ->> 'c1'::text))::bigint))
               ->  HashAggregate
                     Output: count((v ->> 'c6'::text)), sum(((v ->> 'c1'::text))::bigint), avg(((v ->> 'c1'::text))::bigint), min((((v ->> 'c2'::text))::integer)), max(((v ->> 'c1'::text))::bigint), stddev((((v ->> 'c2'::text))::integer)), (((v ->> 'c2'::text))::integer)
                     Group Key: ((ft1.v ->> 'c2'::text))::integer
                     ->  Foreign Scan on public.ft1
                           Output: ((v ->> 'c2'::text))::integer, v
                           Filter: (((ft1.v ->> 'c2'::text))::integer < 5)
                           Reader: Single File
                           Row groups: 1
(15 rows)

--Testcase 190:
select count(v->>'c6'), sum((v->>'c1')::int8), avg((v->>'c1')::int8), min((v->>'c2')::int), max((v->>'c1')::int8), stddev((v->>'c2')::int), sum((v->>'c1')::int8) * (random() <= 1)::int as sum2 from ft1 where (v->>'c2')::int < 5 group by (v->>'c2')::int order by 1, 2 limit 1;
 count |  sum  |         avg          | min | max | stddev | sum2  
-------+-------+----------------------+-----+-----+--------+-------
   100 | 49600 | 496.0000000000000000 |   1 | 991 |      0 | 49600
(1 row)

-- Aggregate is not pushed down as aggregation contains random()
--Testcase 191:
explain (verbose, costs off)
select sum((v->>'c1')::int8 * (random() <= 1)::int) as sum, avg((v->>'c1')::int8) from ft1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum((((v ->> 'c1'::text))::bigint * ((random() <= '1'::double precision))::integer)), avg(((v ->> 'c1'::text))::bigint)
   ->  Foreign Scan on public.ft1
         Output: v
         Reader: Single File
         Row groups: 1
(6 rows)

-- Aggregate over join query
--Testcase 192:
explain (verbose, costs off)
select count(*), sum((t1.v->>'c1')::int8), avg((t2.v->>'c1')::int8) from ft1 t1 inner join ft1 t2 on ((t1.v->>'c2')::int = (t2.v->>'c2')::int) where (t1.v->>'c2')::int = 6;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(*), sum(((t1.v ->> 'c1'::text))::bigint), avg(((t2.v ->> 'c1'::text))::bigint)
   ->  Nested Loop
         Output: t1.v, t2.v
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Filter: (((t1.v ->> 'c2'::text))::integer = 6)
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft1 t2
                     Output: t2.v
                     Filter: (((t2.v ->> 'c2'::text))::integer = 6)
                     Reader: Single File
                     Row groups: 1
(16 rows)

--Testcase 193:
select count(*), sum((t1.v->>'c1')::int8), avg((t2.v->>'c1')::int8) from ft1 t1 inner join ft1 t2 on ((t1.v->>'c2')::int = (t2.v->>'c2')::int) where (t1.v->>'c2')::int = 6;
 count |   sum   |         avg          
-------+---------+----------------------
 10000 | 5010000 | 501.0000000000000000
(1 row)

-- Not pushed down due to local conditions present in underneath input rel
--Testcase 194:
explain (verbose, costs off)
select sum((t1.v->>'c1')::int8), count((t2.v->>'c1')::int8) from ft1 t1 inner join ft2 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (((t1.v->>'c1')::int8 * (t2.v->>'c1')::int8)/((t1.v->>'c1')::int8 * (t2.v->>'c1')::int8)) * random() <= 1;
                                                                                                          QUERY PLAN                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum(((t1.v ->> 'c1'::text))::bigint), count(((t2.v ->> 'c1'::text))::bigint)
   ->  Merge Join
         Output: t1.v, t2.v
         Merge Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
         Join Filter: (((((((t1.v ->> 'c1'::text))::bigint * ((t2.v ->> 'c1'::text))::bigint) / (((t1.v ->> 'c1'::text))::bigint * ((t2.v ->> 'c1'::text))::bigint)))::double precision * random()) <= '1'::double precision)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(16 rows)

-- GROUP BY clause having expressions
--Testcase 195:
explain (verbose, costs off)
select (v->>'c2')::int/2, sum((v->>'c2')::int) * ((v->>'c2')::int/2) from ft1 group by (v->>'c2')::int/2 order by (v->>'c2')::int/2;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: ((((v ->> 'c2'::text))::integer / 2)), ((sum(((v ->> 'c2'::text))::integer) * ((((v ->> 'c2'::text))::integer / 2))))
   Sort Key: ((((ft1.v ->> 'c2'::text))::integer / 2))
   ->  HashAggregate
         Output: ((((v ->> 'c2'::text))::integer / 2)), (sum(((v ->> 'c2'::text))::integer) * ((((v ->> 'c2'::text))::integer / 2)))
         Group Key: (((ft1.v ->> 'c2'::text))::integer / 2)
         ->  Foreign Scan on public.ft1
               Output: (((v ->> 'c2'::text))::integer / 2), v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 196:
select (v->>'c2')::int/2, sum((v->>'c2')::int) * ((v->>'c2')::int/2) from ft1 group by (v->>'c2')::int/2 order by (v->>'c2')::int/2;
 ?column? | ?column? 
----------+----------
        0 |        0
        1 |      500
        2 |     1800
        3 |     3900
        4 |     6800
(5 rows)

-- Aggregates in subquery are pushed down.
--Testcase 197:
explain (verbose, costs off)
select count(x.a), sum(x.a) from (select (v->>'c2')::int a, sum((v->>'c1')::int8) b from ft1 group by (v->>'c2')::int, sqrt((v->>'c1')::int8) order by 1, 2) x;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count((((ft1.v ->> 'c2'::text))::integer)), sum((((ft1.v ->> 'c2'::text))::integer))
   ->  Sort
         Output: (((ft1.v ->> 'c2'::text))::integer), (sum(((ft1.v ->> 'c1'::text))::bigint)), (sqrt((((ft1.v ->> 'c1'::text))::bigint)::double precision))
         Sort Key: (((ft1.v ->> 'c2'::text))::integer), (sum(((ft1.v ->> 'c1'::text))::bigint))
         ->  HashAggregate
               Output: (((ft1.v ->> 'c2'::text))::integer), sum(((ft1.v ->> 'c1'::text))::bigint), (sqrt((((ft1.v ->> 'c1'::text))::bigint)::double precision))
               Group Key: ((ft1.v ->> 'c2'::text))::integer, sqrt((((ft1.v ->> 'c1'::text))::bigint)::double precision)
               ->  Foreign Scan on public.ft1
                     Output: ((ft1.v ->> 'c2'::text))::integer, sqrt((((ft1.v ->> 'c1'::text))::bigint)::double precision), ft1.v
                     Reader: Single File
                     Row groups: 1
(12 rows)

--Testcase 198:
select count(x.a), sum(x.a) from (select (v->>'c2')::int a, sum((v->>'c1')::int8) b from ft1 group by (v->>'c2')::int, sqrt((v->>'c1')::int8) order by 1, 2) x;
 count | sum  
-------+------
  1000 | 4500
(1 row)

-- Aggregate is still pushed down by taking unshippable expression out
--Testcase 199:
explain (verbose, costs off)
select (v->>'c2')::int * (random() <= 1)::int as sum1, sum((v->>'c1')::int8) * (v->>'c2')::int as sum2 from ft1 group by (v->>'c2')::int order by 1, 2;
                                                                                                      QUERY PLAN                                                                                                       
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((((v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer)), ((sum(((v ->> 'c1'::text))::bigint) * ((((v ->> 'c2'::text))::integer))::numeric)), (((v ->> 'c2'::text))::integer)
   Sort Key: (((((ft1.v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer)), ((sum(((ft1.v ->> 'c1'::text))::bigint) * ((((ft1.v ->> 'c2'::text))::integer))::numeric))
   ->  HashAggregate
         Output: ((((v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer), (sum(((v ->> 'c1'::text))::bigint) * ((((v ->> 'c2'::text))::integer))::numeric), (((v ->> 'c2'::text))::integer)
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 200:
select (v->>'c2')::int * (random() <= 1)::int as sum1, sum((v->>'c1')::int8) * (v->>'c2')::int as sum2 from ft1 group by (v->>'c2')::int order by 1, 2;
 sum1 |  sum2  
------+--------
    0 |      0
    1 |  49600
    2 |  99400
    3 | 149400
    4 | 199600
    5 | 250000
    6 | 300600
    7 | 351400
    8 | 402400
    9 | 453600
(10 rows)

-- Aggregate with unshippable GROUP BY clause are not pushed
--Testcase 201:
explain (verbose, costs off)
select (v->>'c2')::int * (random() <= 1)::int as c2 from ft2 group by (v->>'c2')::int * (random() <= 1)::int order by 1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort
   Output: ((((v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer))
   Sort Key: ((((ft2.v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer))
   ->  HashAggregate
         Output: ((((v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer))
         Group Key: (((ft2.v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer)
         ->  Foreign Scan on public.ft2
               Output: (((v ->> 'c2'::text))::integer * ((random() <= '1'::double precision))::integer)
               Reader: Single File
               Row groups: 1
(10 rows)

-- GROUP BY clause in various forms, cardinal, alias and constant expression
--Testcase 202:
explain (verbose, costs off)
select count((v->>'c2')::int) w, (v->>'c2')::int x, 5 y, 7.0 z from ft1 group by 2, y, 9.0::int order by 2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort
   Output: (count((((v ->> 'c2'::text))::integer))), (((v ->> 'c2'::text))::integer), 5, 7.0, 9
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  HashAggregate
         Output: count((((v ->> 'c2'::text))::integer)), (((v ->> 'c2'::text))::integer), (5), 7.0, (9)
         Group Key: ((ft1.v ->> 'c2'::text))::integer, 5, 9
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, 5, 9, v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 203:
select count((v->>'c2')::int) w, (v->>'c2')::int x, 5 y, 7.0 z from ft1 group by 2, y, 9.0::int order by 2;
  w  | x | y |  z  
-----+---+---+-----
 100 | 0 | 5 | 7.0
 100 | 1 | 5 | 7.0
 100 | 2 | 5 | 7.0
 100 | 3 | 5 | 7.0
 100 | 4 | 5 | 7.0
 100 | 5 | 5 | 7.0
 100 | 6 | 5 | 7.0
 100 | 7 | 5 | 7.0
 100 | 8 | 5 | 7.0
 100 | 9 | 5 | 7.0
(10 rows)

-- GROUP BY clause referring to same column multiple times
-- Also, ORDER BY contains an aggregate function
--Testcase 204:
explain (verbose, costs off)
select (v->>'c2')::int as c2, (v->>'c2')::int as c2 from ft1 where (v->>'c2')::int > 6 group by 1, 2 order by sum((v->>'c1')::int8);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (sum(((ft1.v ->> 'c1'::text))::bigint))
   ->  HashAggregate
         Output: (((v ->> 'c2'::text))::integer), (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint)
         Group Key: ((ft1.v ->> 'c2'::text))::integer, ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer > 6)
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 205:
select (v->>'c2')::int as c2, (v->>'c2')::int as c2 from ft1 where (v->>'c2')::int > 6 group by 1, 2 order by sum((v->>'c1')::int8);
 c2 | c2 
----+----
  7 |  7
  8 |  8
  9 |  9
(3 rows)

-- Testing HAVING clause shippability
--Testcase 206:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft2 group by (v->>'c2')::int having avg((v->>'c1')::int8) < 500 and sum((v->>'c1')::int8) < 49800 order by (v->>'c2')::int;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (((ft2.v ->> 'c2'::text))::integer)
   ->  HashAggregate
         Output: (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint)
         Group Key: ((ft2.v ->> 'c2'::text))::integer
         Filter: ((avg(((ft2.v ->> 'c1'::text))::bigint) < '500'::numeric) AND (sum(((ft2.v ->> 'c1'::text))::bigint) < '49800'::numeric))
         ->  Foreign Scan on public.ft2
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 207:
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft2 group by (v->>'c2')::int having avg((v->>'c1')::int8) < 500 and sum((v->>'c1')::int8) < 49800 order by (v->>'c2')::int;
 c2 |  sum  
----+-------
  1 | 49600
  2 | 49700
(2 rows)

-- Unshippable HAVING clause will be evaluated locally, and other qual in HAVING clause is pushed down
--Testcase 208:
explain (verbose, costs off)
select count(*) from (select  v->>'c5', count((v->>'c1')::int8) from ft1 group by  v->>'c5', sqrt((v->>'c2')::int) having (avg((v->>'c1')::int8) / avg((v->>'c1')::int8)) * random() <= 1 and avg((v->>'c1')::int8) < 500) x;
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  HashAggregate
         Output: ((ft1.v ->> 'c5'::text)), NULL::bigint, (sqrt((((ft1.v ->> 'c2'::text))::integer)::double precision))
         Group Key: (ft1.v ->> 'c5'::text), sqrt((((ft1.v ->> 'c2'::text))::integer)::double precision)
         Filter: ((avg(((ft1.v ->> 'c1'::text))::bigint) < '500'::numeric) AND ((((avg(((ft1.v ->> 'c1'::text))::bigint) / avg(((ft1.v ->> 'c1'::text))::bigint)))::double precision * random()) <= '1'::double precision))
         ->  Foreign Scan on public.ft1
               Output: (ft1.v ->> 'c5'::text), sqrt((((ft1.v ->> 'c2'::text))::integer)::double precision), ft1.v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 209:
select count(*) from (select  v->>'c5', count((v->>'c1')::int8) from ft1 group by  v->>'c5', sqrt((v->>'c2')::int) having (avg((v->>'c1')::int8) / avg((v->>'c1')::int8)) * random() <= 1 and avg((v->>'c1')::int8) < 500) x;
 count 
-------
    49
(1 row)

-- Aggregate in HAVING clause is not pushable, and thus aggregation is not pushed down
--Testcase 210:
explain (verbose, costs off)
select sum((v->>'c1')::int8) from ft1 group by (v->>'c2')::int having avg((v->>'c1')::int8 * (random() <= 1)::int) > 100 order by 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (sum(((v ->> 'c1'::text))::bigint)), (((v ->> 'c2'::text))::integer)
   Sort Key: (sum(((ft1.v ->> 'c1'::text))::bigint))
   ->  HashAggregate
         Output: sum(((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer)
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         Filter: (avg((((ft1.v ->> 'c1'::text))::bigint * ((random() <= '1'::double precision))::integer)) > '100'::numeric)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(11 rows)

-- Remote aggregate in combination with a local Param (for the output
-- of an initplan) can be trouble, per bug #15781
--Testcase 211:
explain (verbose, costs off)
select exists(select 1 from pg_enum), sum((v->>'c1')::int8) from ft1;
                     QUERY PLAN                      
-----------------------------------------------------
 Aggregate
   Output: $0, sum(((ft1.v ->> 'c1'::text))::bigint)
   InitPlan 1 (returns $0)
     ->  Seq Scan on pg_catalog.pg_enum
   ->  Foreign Scan on public.ft1
         Output: ft1.v
         Reader: Single File
         Row groups: 1
(8 rows)

--Testcase 212:
select exists(select 1 from pg_enum), sum((v->>'c1')::int8) from ft1;
 exists |  sum   
--------+--------
 t      | 500500
(1 row)

--Testcase 213:
explain (verbose, costs off)
select exists(select 1 from pg_enum), sum((v->>'c1')::int8) from ft1 group by 1;
                      QUERY PLAN                       
-------------------------------------------------------
 GroupAggregate
   Output: ($0), sum(((ft1.v ->> 'c1'::text))::bigint)
   Group Key: $0
   InitPlan 1 (returns $0)
     ->  Seq Scan on pg_catalog.pg_enum
   ->  Foreign Scan on public.ft1
         Output: $0, ft1.v
         Reader: Single File
         Row groups: 1
(9 rows)

--Testcase 214:
select exists(select 1 from pg_enum), sum((v->>'c1')::int8) from ft1 group by 1;
 exists |  sum   
--------+--------
 t      | 500500
(1 row)

-- Testing ORDER BY, DISTINCT, FILTER, Ordered-sets and VARIADIC within aggregates
-- ORDER BY within aggregate, same column used to order
--Testcase 215:
explain (verbose, costs off)
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int8) from ft1 where (v->>'c1')::int8 < 100 group by (v->>'c2')::int order by 1;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::bigint)), (((v ->> 'c2'::text))::integer)
   Sort Key: (array_agg(((ft1.v ->> 'c1'::text))::bigint ORDER BY ((ft1.v ->> 'c1'::text))::bigint))
   ->  GroupAggregate
         Output: array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer)
         Group Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Sort
               Output: (((v ->> 'c2'::text))::integer), v
               Sort Key: (((ft1.v ->> 'c2'::text))::integer)
               ->  Foreign Scan on public.ft1
                     Output: ((v ->> 'c2'::text))::integer, v
                     Filter: (((ft1.v ->> 'c1'::text))::bigint < 100)
                     Reader: Single File
                     Row groups: 1
(14 rows)

--Testcase 216:
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int8) from ft1 where (v->>'c1')::int8 < 100 group by (v->>'c2')::int order by 1;
           array_agg            
--------------------------------
 {1,11,21,31,41,51,61,71,81,91}
 {2,12,22,32,42,52,62,72,82,92}
 {3,13,23,33,43,53,63,73,83,93}
 {4,14,24,34,44,54,64,74,84,94}
 {5,15,25,35,45,55,65,75,85,95}
 {6,16,26,36,46,56,66,76,86,96}
 {7,17,27,37,47,57,67,77,87,97}
 {8,18,28,38,48,58,68,78,88,98}
 {9,19,29,39,49,59,69,79,89,99}
 {10,20,30,40,50,60,70,80,90}
(10 rows)

-- ORDER BY within aggregate, different column used to order also using DESC
--Testcase 217:
explain (verbose, costs off)
select array_agg((v->>'c5')::timestamp order by (v->>'c1')::int8 desc) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 50;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: array_agg(((v ->> 'c5'::text))::timestamp without time zone ORDER BY ((v ->> 'c1'::text))::bigint DESC)
   ->  Foreign Scan on public.ft2
         Output: v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint < 50) AND (((ft2.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 218:
select array_agg((v->>'c5')::timestamp order by (v->>'c1')::int8 desc) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 50;
                                                                array_agg                                                                 
------------------------------------------------------------------------------------------------------------------------------------------
 {"Mon Feb 16 00:00:00 1970","Fri Feb 06 00:00:00 1970","Tue Jan 27 00:00:00 1970","Sat Jan 17 00:00:00 1970","Wed Jan 07 00:00:00 1970"}
(1 row)

-- DISTINCT within aggregate
--Testcase 219:
explain (verbose, costs off)
select array_agg(distinct ((t1.v->>'c1')::int8)%5) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint))), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
   Sort Key: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint)))
   ->  GroupAggregate
         Output: array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint)), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         Group Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         ->  Sort
               Output: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint)), t1.v
               Sort Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
               ->  Hash Full Join
                     Output: (((t2.v ->> 'c1'::text))::bigint % '3'::bigint), t1.v
                     Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     Filter: ((((t1.v ->> 'c1'::text))::bigint < 20) OR ((((t1.v ->> 'c1'::text))::bigint IS NULL) AND (((t2.v ->> 'c1'::text))::bigint < 5)))
                     ->  Foreign Scan on public.ft4 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: t2.v
                           ->  Foreign Scan on public.ft5 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(23 rows)

--Testcase 220:
select array_agg(distinct ((t1.v->>'c1')::int8)%5) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
  array_agg   
--------------
 {0,1,2,3,4}
 {1,2,3,NULL}
(2 rows)

-- DISTINCT combined with ORDER BY within aggregate
--Testcase 221:
explain (verbose, costs off)
select array_agg(distinct ((t1.v->>'c1')::int8)%5 order by ((t1.v->>'c1')::int8)%5) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint))), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
   Sort Key: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint)))
   ->  GroupAggregate
         Output: array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint)), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         Group Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         ->  Sort
               Output: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint)), t1.v
               Sort Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
               ->  Hash Full Join
                     Output: (((t2.v ->> 'c1'::text))::bigint % '3'::bigint), t1.v
                     Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     Filter: ((((t1.v ->> 'c1'::text))::bigint < 20) OR ((((t1.v ->> 'c1'::text))::bigint IS NULL) AND (((t2.v ->> 'c1'::text))::bigint < 5)))
                     ->  Foreign Scan on public.ft4 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: t2.v
                           ->  Foreign Scan on public.ft5 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(23 rows)

--Testcase 222:
select array_agg(distinct ((t1.v->>'c1')::int8)%5 order by ((t1.v->>'c1')::int8)%5) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
  array_agg   
--------------
 {0,1,2,3,4}
 {1,2,3,NULL}
(2 rows)

--Testcase 223:
explain (verbose, costs off)
select array_agg(distinct ((t1.v->>'c1')::int8)%5 order by ((t1.v->>'c1')::int8)%5 desc nulls last) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) DESC NULLS LAST)), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
   Sort Key: (array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) DESC NULLS LAST))
   ->  GroupAggregate
         Output: array_agg(DISTINCT (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) ORDER BY (((t1.v ->> 'c1'::text))::bigint % '5'::bigint) DESC NULLS LAST), ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         Group Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
         ->  Sort
               Output: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint)), t1.v
               Sort Key: ((((t2.v ->> 'c1'::text))::bigint % '3'::bigint))
               ->  Hash Full Join
                     Output: (((t2.v ->> 'c1'::text))::bigint % '3'::bigint), t1.v
                     Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
                     Filter: ((((t1.v ->> 'c1'::text))::bigint < 20) OR ((((t1.v ->> 'c1'::text))::bigint IS NULL) AND (((t2.v ->> 'c1'::text))::bigint < 5)))
                     ->  Foreign Scan on public.ft4 t1
                           Output: t1.v
                           Reader: Single File
                           Row groups: 1
                     ->  Hash
                           Output: t2.v
                           ->  Foreign Scan on public.ft5 t2
                                 Output: t2.v
                                 Reader: Single File
                                 Row groups: 1
(23 rows)

--Testcase 224:
select array_agg(distinct ((t1.v->>'c1')::int8)%5 order by ((t1.v->>'c1')::int8)%5 desc nulls last) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) where (t1.v->>'c1')::int8 < 20 or ((t1.v->>'c1')::int8 is null and (t2.v->>'c1')::int8 < 5) group by ((t2.v->>'c1')::int8)%3 order by 1;
  array_agg   
--------------
 {3,2,1,NULL}
 {4,3,2,1,0}
(2 rows)

-- FILTER within aggregate
--Testcase 225:
explain (verbose, costs off)
select sum((v->>'c1')::int8) filter (where (v->>'c1')::int8 < 100 and (v->>'c2')::int > 5) from ft1 group by (v->>'c2')::int order by 1 nulls last;
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (sum(((v ->> 'c1'::text))::bigint) FILTER (WHERE ((((v ->> 'c1'::text))::bigint < 100) AND ((((v ->> 'c2'::text))::integer) > 5)))), (((v ->> 'c2'::text))::integer)
   Sort Key: (sum(((ft1.v ->> 'c1'::text))::bigint) FILTER (WHERE ((((ft1.v ->> 'c1'::text))::bigint < 100) AND ((((ft1.v ->> 'c2'::text))::integer) > 5))))
   ->  HashAggregate
         Output: sum(((v ->> 'c1'::text))::bigint) FILTER (WHERE ((((v ->> 'c1'::text))::bigint < 100) AND ((((v ->> 'c2'::text))::integer) > 5))), (((v ->> 'c2'::text))::integer)
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 226:
select sum((v->>'c1')::int8) filter (where (v->>'c1')::int8 < 100 and (v->>'c2')::int > 5) from ft1 group by (v->>'c2')::int order by 1 nulls last;
 sum 
-----
 510
 520
 530
 540
    
    
    
    
    
    
(10 rows)

-- DISTINCT, ORDER BY and FILTER within aggregate
--Testcase 227:
explain (verbose, costs off)
select sum((v->>'c1')::int8 % 3), sum(distinct (v->>'c1')::int8 %3 order by (v->>'c1')::int8 % 3) filter (where (v->>'c1')::int8 % 3 < 2), (v->>'c2')::int as c2 from ft1 where (v->>'c2')::int = 6 group by (v->>'c2')::int;
                                                                                                                                    QUERY PLAN                                                                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: sum((((v ->> 'c1'::text))::bigint % '3'::bigint)), sum(DISTINCT (((v ->> 'c1'::text))::bigint % '3'::bigint) ORDER BY (((v ->> 'c1'::text))::bigint % '3'::bigint)) FILTER (WHERE ((((v ->> 'c1'::text))::bigint % '3'::bigint) < 2)), (((v ->> 'c2'::text))::integer)
   Group Key: ((ft1.v ->> 'c2'::text))::integer
   ->  Foreign Scan on public.ft1
         Output: ((v ->> 'c2'::text))::integer, v
         Filter: (((ft1.v ->> 'c2'::text))::integer = 6)
         Reader: Single File
         Row groups: 1
(8 rows)

--Testcase 228:
select sum((v->>'c1')::int8 % 3), sum(distinct (v->>'c1')::int8 %3 order by (v->>'c1')::int8 % 3) filter (where (v->>'c1')::int8 % 3 < 2), (v->>'c2')::int as c2 from ft1 where (v->>'c2')::int = 6 group by (v->>'c2')::int;
 sum | sum | c2 
-----+-----+----
  99 |   1 |  6
(1 row)

-- Outer query is aggregation query
--Testcase 229:
explain (verbose, costs off)
select distinct (select count(*) filter (where (t2.v->>'c2')::int = 6 and (t2.v->>'c1')::int8 < 10) from ft1 t1 where (t1.v->>'c1')::int8 = 6) from ft2 t2 where (t2.v->>'c2')::int % 6 = 0 order by 1;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Unique
   Output: ((SubPlan 1))
   ->  Sort
         Output: ((SubPlan 1))
         Sort Key: ((SubPlan 1))
         ->  Aggregate
               Output: (SubPlan 1)
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Filter: ((((t2.v ->> 'c2'::text))::integer % 6) = 0)
                     Reader: Single File
                     Row groups: 1
               SubPlan 1
                 ->  Foreign Scan on public.ft1 t1
                       Output: count(*) FILTER (WHERE ((((t2.v ->> 'c2'::text))::integer = 6) AND (((t2.v ->> 'c1'::text))::bigint < 10)))
                       Filter: (((t1.v ->> 'c1'::text))::bigint = 6)
                       Reader: Single File
                       Row groups: 1
(18 rows)

--Testcase 230:
select distinct (select count(*) filter (where (t2.v->>'c2')::int = 6 and (t2.v->>'c1')::int8 < 10) from ft1 t1 where (t1.v->>'c1')::int8 = 6) from ft2 t2 where (t2.v->>'c2')::int % 6 = 0 order by 1;
 count 
-------
     1
(1 row)

-- Inner query is aggregation query
--Testcase 231:
explain (verbose, costs off)
select distinct (select count((t1.v->>'c1')::int8) filter (where (t2.v->>'c2')::int = 6 and (t2.v->>'c1')::int8 < 10) from ft1 t1 where (t1.v->>'c1')::int8 = 6) from ft2 t2 where (t2.v->>'c2')::int % 6 = 0 order by 1;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Unique
   Output: ((SubPlan 1))
   ->  Sort
         Output: ((SubPlan 1))
         Sort Key: ((SubPlan 1))
         ->  Foreign Scan on public.ft2 t2
               Output: (SubPlan 1)
               Filter: ((((t2.v ->> 'c2'::text))::integer % 6) = 0)
               Reader: Single File
               Row groups: 1
               SubPlan 1
                 ->  Aggregate
                       Output: count(((t1.v ->> 'c1'::text))::bigint) FILTER (WHERE ((((t2.v ->> 'c2'::text))::integer = 6) AND (((t2.v ->> 'c1'::text))::bigint < 10)))
                       ->  Foreign Scan on public.ft1 t1
                             Output: t1.v
                             Filter: (((t1.v ->> 'c1'::text))::bigint = 6)
                             Reader: Single File
                             Row groups: 1
(18 rows)

--Testcase 232:
select distinct (select count((t1.v->>'c1')::int8) filter (where (t2.v->>'c2')::int = 6 and (t2.v->>'c1')::int8 < 10) from ft1 t1 where (t1.v->>'c1')::int8 = 6) from ft2 t2 where (t2.v->>'c2')::int % 6 = 0 order by 1;
 count 
-------
     0
     1
(2 rows)

-- Aggregate not pushed down as FILTER condition is not pushable
--Testcase 233:
explain (verbose, costs off)
select sum((v->>'c1')::int8) filter (where ((v->>'c1')::int8 / (v->>'c1')::int8) * random() <= 1) from ft1 group by (v->>'c2')::int order by 1;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (sum(((v ->> 'c1'::text))::bigint) FILTER (WHERE ((((((v ->> 'c1'::text))::bigint / ((v ->> 'c1'::text))::bigint))::double precision * random()) <= '1'::double precision))), (((v ->> 'c2'::text))::integer)
   Sort Key: (sum(((ft1.v ->> 'c1'::text))::bigint) FILTER (WHERE ((((((ft1.v ->> 'c1'::text))::bigint / ((ft1.v ->> 'c1'::text))::bigint))::double precision * random()) <= '1'::double precision)))
   ->  HashAggregate
         Output: sum(((v ->> 'c1'::text))::bigint) FILTER (WHERE ((((((v ->> 'c1'::text))::bigint / ((v ->> 'c1'::text))::bigint))::double precision * random()) <= '1'::double precision)), (((v ->> 'c2'::text))::integer)
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

--Testcase 234:
explain (verbose, costs off)
select sum((v->>'c2')::int) filter (where (v->>'c2')::int in (select (v->>'c2')::int from ft1 where (v->>'c2')::int < 5)) from ft1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Aggregate
   Output: sum(((ft1.v ->> 'c2'::text))::integer) FILTER (WHERE (hashed SubPlan 1))
   ->  Foreign Scan on public.ft1
         Output: ft1.v
         Reader: Single File
         Row groups: 1
   SubPlan 1
     ->  Foreign Scan on public.ft1 ft1_1
           Output: ((ft1_1.v ->> 'c2'::text))::integer
           Filter: (((ft1_1.v ->> 'c2'::text))::integer < 5)
           Reader: Single File
           Row groups: 1
(12 rows)

-- Ordered-sets within aggregate
--Testcase 235:
explain (verbose, costs off)
select (v->>'c2')::int as c2, rank('10'::varchar) within group (order by v->>'c6'), percentile_cont((v->>'c2')::int/10::numeric) within group (order by (v->>'c1')::int8) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int having percentile_cont((v->>'c2')::int/10::numeric) within group (order by (v->>'c1')::int8) < 500 order by (v->>'c2')::int;
                                                                                                                                      QUERY PLAN                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c2'::text))::integer), rank('10'::text) WITHIN GROUP (ORDER BY (v ->> 'c6'::text)), percentile_cont(((((((v ->> 'c2'::text))::integer))::numeric / '10'::numeric))::double precision) WITHIN GROUP (ORDER BY ((((v ->> 'c1'::text))::bigint)::double precision))
   Group Key: (((ft1.v ->> 'c2'::text))::integer)
   Filter: (percentile_cont(((((((ft1.v ->> 'c2'::text))::integer))::numeric / '10'::numeric))::double precision) WITHIN GROUP (ORDER BY ((((ft1.v ->> 'c1'::text))::bigint)::double precision)) < '500'::double precision)
   ->  Sort
         Output: (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 10)
               Reader: Single File
               Row groups: 1
(12 rows)

--Testcase 236:
select (v->>'c2')::int as c2, rank('10'::varchar) within group (order by v->>'c6'), percentile_cont((v->>'c2')::int/10::numeric) within group (order by (v->>'c1')::int8) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int having percentile_cont((v->>'c2')::int/10::numeric) within group (order by (v->>'c1')::int8) < 500 order by (v->>'c2')::int;
 c2 | rank | percentile_cont 
----+------+-----------------
  0 |  101 |              10
  1 |  101 |             100
  2 |    1 |             200
  3 |    1 |             300
  4 |    1 |             400
(5 rows)

-- Using multiple arguments within aggregates
--Testcase 237:
explain (verbose, costs off)
select (v->>'c1')::int8 as c1, rank((v->>'c1')::int8, (v->>'c2')::int) within group (order by (v->>'c1')::int8, (v->>'c2')::int) from ft1 group by (v->>'c1')::int8, (v->>'c2')::int, v having (v->>'c1')::int8 = 6 order by 1;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c1'::text))::bigint), rank((((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer)) WITHIN GROUP (ORDER BY (((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer)), (((v ->> 'c2'::text))::integer), v
   Group Key: (((ft1.v ->> 'c1'::text))::bigint), (((ft1.v ->> 'c2'::text))::integer), ft1.v
   ->  Sort
         Output: (((v ->> 'c1'::text))::bigint), (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer), ft1.v
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c1'::text))::bigint, ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c1'::text))::bigint = 6)
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 238:
select (v->>'c1')::int8 as c1, rank((v->>'c1')::int8, (v->>'c2')::int) within group (order by (v->>'c1')::int8, (v->>'c2')::int) from ft1 group by (v->>'c1')::int8, (v->>'c2')::int, v having (v->>'c1')::int8 = 6 order by 1;
 c1 | rank 
----+------
  6 |    1
(1 row)

-- User defined function for user defined aggregate, VARIADIC
--Testcase 239:
create function least_accum(anyelement, variadic anyarray)
returns anyelement language sql as
  'select least($1, min($2[i])) from generate_subscripts($2,1) g(i)';
--Testcase 240:
create aggregate least_agg(variadic items anyarray) (
  stype = anyelement, sfunc = least_accum
);
-- Disable hash aggregation for plan stability.
set enable_hashagg to false;
-- Not pushed down due to user defined aggregate
--Testcase 241:
explain (verbose, costs off)
select (v->>'c2')::int as c2, least_agg((v->>'c1')::int8) from ft1 group by (v->>'c2')::int order by (v->>'c2')::int;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c2'::text))::integer), least_agg(VARIADIC ARRAY[((v ->> 'c1'::text))::bigint])
   Group Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  Sort
         Output: (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

-- Add function and aggregate into extension
alter extension parquet_s3_fdw add function least_accum(anyelement, variadic anyarray);
alter extension parquet_s3_fdw add aggregate least_agg(variadic items anyarray);
alter server parquet_s3_srv options (set extensions 'parquet_s3_fdw');
-- Now aggregate will be pushed.  Aggregate will display VARIADIC argument.
--Testcase 242:
explain (verbose, costs off)
select (v->>'c2')::int as c2, least_agg((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 100 group by (v->>'c2')::int order by (v->>'c2')::int;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c2'::text))::integer), least_agg(VARIADIC ARRAY[((v ->> 'c1'::text))::bigint])
   Group Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  Sort
         Output: (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 100)
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 243:
select (v->>'c2')::int as c2, least_agg((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 100 group by (v->>'c2')::int order by (v->>'c2')::int;
 c2 | least_agg 
----+-----------
  0 |        10
  1 |         1
  2 |         2
  3 |         3
  4 |         4
  5 |         5
  6 |         6
  7 |         7
  8 |         8
  9 |         9
(10 rows)

-- Remove function and aggregate from extension
alter extension parquet_s3_fdw drop function least_accum(anyelement, variadic anyarray);
alter extension parquet_s3_fdw drop aggregate least_agg(variadic items anyarray);
alter server parquet_s3_srv options (set extensions 'parquet_s3_fdw');
-- Not pushed down as we have dropped objects from extension.
--Testcase 244:
explain (verbose, costs off)
select (v->>'c2')::int as c2, least_agg((v->>'c1')::int8) from ft1 group by (v->>'c2')::int order by (v->>'c2')::int;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: (((v ->> 'c2'::text))::integer), least_agg(VARIADIC ARRAY[((v ->> 'c1'::text))::bigint])
   Group Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  Sort
         Output: (((v ->> 'c2'::text))::integer), v
         Sort Key: (((ft1.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Reader: Single File
               Row groups: 1
(10 rows)

-- Cleanup
reset enable_hashagg;
--Testcase 245:
drop aggregate least_agg(variadic items anyarray);
--Testcase 246:
drop function least_accum(anyelement, variadic anyarray);
-- Testing USING OPERATOR() in ORDER BY within aggregate.
-- For this, we need user defined operators along with operator family and
-- operator class.  Create those and then add them in extension.  Note that
-- user defined objects are considered unshippable unless they are part of
-- the extension.
--Testcase 247:
create operator public.<^ (
 leftarg = int4,
 rightarg = int4,
 procedure = int4eq
);
--Testcase 248:
create operator public.=^ (
 leftarg = int4,
 rightarg = int4,
 procedure = int4lt
);
--Testcase 249:
create operator public.>^ (
 leftarg = int4,
 rightarg = int4,
 procedure = int4gt
);
--Testcase 250:
create operator family my_op_family using btree;
--Testcase 251:
create function my_op_cmp(a int, b int) returns int as
  $$begin return btint4cmp(a, b); end $$ language plpgsql;
--Testcase 252:
create operator class my_op_class for type int using btree family my_op_family as
 operator 1 public.<^,
 operator 3 public.=^,
 operator 5 public.>^,
 function 1 my_op_cmp(int, int);
-- This will not be pushed as user defined sort operator is not part of the
-- extension yet.
--Testcase 253:
explain (verbose, costs off)
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int using operator(public.<^)) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 100 group by (v->>'c2')::int;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::integer USING <^ NULLS LAST), (((v ->> 'c2'::text))::integer)
   Group Key: ((ft2.v ->> 'c2'::text))::integer
   ->  Foreign Scan on public.ft2
         Output: ((v ->> 'c2'::text))::integer, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint < 100) AND (((ft2.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
(8 rows)

-- Update local stats on ft2
-- ANALYZE ft2;
-- Add into extension
alter extension parquet_s3_fdw add operator class my_op_class using btree;
alter extension parquet_s3_fdw add function my_op_cmp(a int, b int);
alter extension parquet_s3_fdw add operator family my_op_family using btree;
alter extension parquet_s3_fdw add operator public.<^(int, int);
alter extension parquet_s3_fdw add operator public.=^(int, int);
alter extension parquet_s3_fdw add operator public.>^(int, int);
alter server parquet_s3_srv options (set extensions 'parquet_s3_fdw');
-- Now this will be pushed as sort operator is part of the extension.
--Testcase 254:
explain (verbose, costs off)
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int using operator(public.<^)) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 100 group by (v->>'c2')::int;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::integer USING <^ NULLS LAST), (((v ->> 'c2'::text))::integer)
   Group Key: ((ft2.v ->> 'c2'::text))::integer
   ->  Foreign Scan on public.ft2
         Output: ((v ->> 'c2'::text))::integer, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint < 100) AND (((ft2.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
(8 rows)

--Testcase 255:
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int using operator(public.<^)) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 100 group by (v->>'c2')::int;
           array_agg            
--------------------------------
 {6,16,26,36,46,56,66,76,86,96}
(1 row)

-- Remove from extension
alter extension parquet_s3_fdw drop operator class my_op_class using btree;
alter extension parquet_s3_fdw drop function my_op_cmp(a int, b int);
alter extension parquet_s3_fdw drop operator family my_op_family using btree;
alter extension parquet_s3_fdw drop operator public.<^(int, int);
alter extension parquet_s3_fdw drop operator public.=^(int, int);
alter extension parquet_s3_fdw drop operator public.>^(int, int);
alter server parquet_s3_srv options (set extensions 'parquet_s3_fdw');
-- This will not be pushed as sort operator is now removed from the extension.
--Testcase 256:
explain (verbose, costs off)
select array_agg((v->>'c1')::int8 order by (v->>'c1')::int using operator(public.<^)) from ft2 where (v->>'c2')::int = 6 and (v->>'c1')::int8 < 100 group by (v->>'c2')::int;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: array_agg(((v ->> 'c1'::text))::bigint ORDER BY ((v ->> 'c1'::text))::integer USING <^ NULLS LAST), (((v ->> 'c2'::text))::integer)
   Group Key: ((ft2.v ->> 'c2'::text))::integer
   ->  Foreign Scan on public.ft2
         Output: ((v ->> 'c2'::text))::integer, v
         Filter: ((((ft2.v ->> 'c1'::text))::bigint < 100) AND (((ft2.v ->> 'c2'::text))::integer = 6))
         Reader: Single File
         Row groups: 1
(8 rows)

-- Cleanup
--Testcase 257:
drop operator class my_op_class using btree;
--Testcase 258:
drop function my_op_cmp(a int, b int);
--Testcase 259:
drop operator family my_op_family using btree;
--Testcase 260:
drop operator public.>^(int, int);
--Testcase 261:
drop operator public.=^(int, int);
--Testcase 262:
drop operator public.<^(int, int);
-- Input relation to aggregate push down hook is not safe to pushdown and thus
-- the aggregate cannot be pushed down to foreign server.
--Testcase 263:
explain (verbose, costs off)
select count(t1.v->>'c3') from ft2 t1 left join ft2 t2 on ((t1.v->>'c1')::int8 = random() * (t2.v->>'c2')::int);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count((t1.v ->> 'c3'::text))
   ->  Nested Loop Left Join
         Output: t1.v
         Join Filter: ((((t1.v ->> 'c1'::text))::bigint)::double precision = (random() * (((t2.v ->> 'c2'::text))::integer)::double precision))
         ->  Foreign Scan on public.ft2 t1
               Output: t1.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Reader: Single File
                     Row groups: 1
(15 rows)

-- Subquery in FROM clause having aggregate
--Testcase 264:
explain (verbose, costs off)
select count(*), x.b from ft1, (select (v->>'c2')::int a, sum((v->>'c1')::int8) b from ft1 group by (v->>'c2')::int) x where (ft1.v->>'c2')::int = x.a group by x.b order by 1, 2;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (count(*)), x.b
   Sort Key: (count(*)), x.b
   ->  HashAggregate
         Output: count(*), x.b
         Group Key: x.b
         ->  Hash Join
               Output: x.b
               Inner Unique: true
               Hash Cond: (((ft1.v ->> 'c2'::text))::integer = x.a)
               ->  Foreign Scan on public.ft1
                     Output: ft1.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: x.b, x.a
                     ->  Subquery Scan on x
                           Output: x.b, x.a
                           ->  HashAggregate
                                 Output: (((ft1_1.v ->> 'c2'::text))::integer), sum(((ft1_1.v ->> 'c1'::text))::bigint)
                                 Group Key: ((ft1_1.v ->> 'c2'::text))::integer
                                 ->  Foreign Scan on public.ft1 ft1_1
                                       Output: ((ft1_1.v ->> 'c2'::text))::integer, ft1_1.v
                                       Reader: Single File
                                       Row groups: 1
(25 rows)

--Testcase 265:
select count(*), x.b from ft1, (select (v->>'c2')::int a, sum((v->>'c1')::int8) b from ft1 group by (v->>'c2')::int) x where (ft1.v->>'c2')::int = x.a group by x.b order by 1, 2;
 count |   b   
-------+-------
   100 | 49600
   100 | 49700
   100 | 49800
   100 | 49900
   100 | 50000
   100 | 50100
   100 | 50200
   100 | 50300
   100 | 50400
   100 | 50500
(10 rows)

-- FULL join with IS NULL check in HAVING
--Testcase 266:
explain (verbose, costs off)
select avg((t1.v->>'c1')::int8), sum((t2.v->>'c1')::int8) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) group by (t2.v->>'c1')::int8 having (avg((t1.v->>'c1')::int8) is null and sum((t2.v->>'c1')::int8) < 10) or sum((t2.v->>'c1')::int8) is null order by 1 nulls last, 2;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (avg(((t1.v ->> 'c1'::text))::bigint)), (sum((((t2.v ->> 'c1'::text))::bigint))), (((t2.v ->> 'c1'::text))::bigint)
   Sort Key: (avg(((t1.v ->> 'c1'::text))::bigint)), (sum((((t2.v ->> 'c1'::text))::bigint)))
   ->  HashAggregate
         Output: avg(((t1.v ->> 'c1'::text))::bigint), sum((((t2.v ->> 'c1'::text))::bigint)), (((t2.v ->> 'c1'::text))::bigint)
         Group Key: ((t2.v ->> 'c1'::text))::bigint
         Filter: (((avg(((t1.v ->> 'c1'::text))::bigint) IS NULL) AND (sum((((t2.v ->> 'c1'::text))::bigint)) < '10'::numeric)) OR (sum((((t2.v ->> 'c1'::text))::bigint)) IS NULL))
         ->  Hash Full Join
               Output: ((t2.v ->> 'c1'::text))::bigint, t1.v, t2.v
               Hash Cond: (((t1.v ->> 'c1'::text))::bigint = ((t2.v ->> 'c1'::text))::bigint)
               ->  Foreign Scan on public.ft4 t1
                     Output: t1.v
                     Reader: Single File
                     Row groups: 1
               ->  Hash
                     Output: t2.v
                     ->  Foreign Scan on public.ft5 t2
                           Output: t2.v
                           Reader: Single File
                           Row groups: 1
(20 rows)

--Testcase 267:
select avg((t1.v->>'c1')::int8), sum((t2.v->>'c1')::int8) from ft4 t1 full join ft5 t2 on ((t1.v->>'c1')::int8 = (t2.v->>'c1')::int8) group by (t2.v->>'c1')::int8 having (avg((t1.v->>'c1')::int8) is null and sum((t2.v->>'c1')::int8) < 10) or sum((t2.v->>'c1')::int8) is null order by 1 nulls last, 2;
         avg         | sum 
---------------------+-----
 51.0000000000000000 |    
                     |   3
                     |   9
(3 rows)

-- Aggregate over FULL join needing to deparse the joining relations as
-- subqueries.
--Testcase 268:
explain (verbose, costs off)
select count(*), sum(t1.c1), avg(t2.c1) from (select (v->>'c1')::int8 as c1 from ft4 where (v->>'c1')::int8 between 50 and 60) t1 full join (select (v->>'c1')::int8 as c1 from ft5 where (v->>'c1')::int8 between 50 and 60) t2 on (t1.c1 = t2.c1);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(*), sum(((ft4.v ->> 'c1'::text))::bigint), avg(((ft5.v ->> 'c1'::text))::bigint)
   ->  Hash Full Join
         Output: ft4.v, ft5.v
         Hash Cond: (((ft4.v ->> 'c1'::text))::bigint = ((ft5.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft4
               Output: ft4.v
               Filter: ((((ft4.v ->> 'c1'::text))::bigint >= 50) AND (((ft4.v ->> 'c1'::text))::bigint <= 60))
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: ft5.v
               ->  Foreign Scan on public.ft5
                     Output: ft5.v
                     Filter: ((((ft5.v ->> 'c1'::text))::bigint >= 50) AND (((ft5.v ->> 'c1'::text))::bigint <= 60))
                     Reader: Single File
                     Row groups: 1
(17 rows)

--Testcase 269:
select count(*), sum(t1.c1), avg(t2.c1) from (select (v->>'c1')::int8 as c1 from ft4 where (v->>'c1')::int8 between 50 and 60) t1 full join (select (v->>'c1')::int8 as c1 from ft5 where (v->>'c1')::int8 between 50 and 60) t2 on (t1.c1 = t2.c1);
 count | sum |         avg         
-------+-----+---------------------
     8 | 330 | 55.5000000000000000
(1 row)

-- ORDER BY expression is part of the target list but not pushed down to
-- foreign server.
--Testcase 270:
explain (verbose, costs off)
select sum((v->>'c2')::int) * (random() <= 1)::int as sum from ft1 order by 1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort
   Output: ((sum(((v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer))
   Sort Key: ((sum(((ft1.v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer))
   ->  Aggregate
         Output: (sum(((v ->> 'c2'::text))::integer) * ((random() <= '1'::double precision))::integer)
         ->  Foreign Scan on public.ft1
               Output: v
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 271:
select sum((v->>'c2')::int) * (random() <= 1)::int as sum from ft1 order by 1;
 sum  
------
 4500
(1 row)

-- LATERAL join, with parameterization
set enable_hashagg to false;
--Testcase 272:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum from "S 1"."T1" t1, lateral (select sum((t2.v->>'c1')::int8 + (t1.v->>'c1')::int8) sum from ft2 t2 group by (t2.v->>'c1')::int8) qry where (t1.v->>'c2')::int * 2 = qry.sum and (t1.v->>'c2')::int < 3 and (t1.v->>'c1')::int8 < 100 order by 1;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((t1.v ->> 'c2'::text))::integer), qry.sum
   Sort Key: (((t1.v ->> 'c2'::text))::integer)
   ->  Nested Loop
         Output: ((t1.v ->> 'c2'::text))::integer, qry.sum
         ->  Foreign Scan on "S 1"."T1" t1
               Output: t1.v
               Filter: ((((t1.v ->> 'c2'::text))::integer < 3) AND (((t1.v ->> 'c1'::text))::bigint < 100))
               Reader: Single File
               Row groups: 1
         ->  Subquery Scan on qry
               Output: qry.sum, (((t2.v ->> 'c1'::text))::bigint)
               Filter: (((((t1.v ->> 'c2'::text))::integer * 2))::numeric = qry.sum)
               ->  GroupAggregate
                     Output: sum(((((t2.v ->> 'c1'::text))::bigint) + ((t1.v ->> 'c1'::text))::bigint)), (((t2.v ->> 'c1'::text))::bigint)
                     Group Key: ((t2.v ->> 'c1'::text))::bigint
                     ->  Foreign Scan on public.ft2 t2
                           Output: ((t2.v ->> 'c1'::text))::bigint, t2.v
                           Reader: Single File
                           Row groups: 1
(20 rows)

--Testcase 273:
select (v->>'c2')::int as c2, sum from "S 1"."T1" t1, lateral (select sum((t2.v->>'c1')::int8 + (t1.v->>'c1')::int8) sum from ft2 t2 group by (t2.v->>'c1')::int8) qry where (t1.v->>'c2')::int * 2 = qry.sum and (t1.v->>'c2')::int < 3 and (t1.v->>'c1')::int8 < 100 order by 1;
 c2 | sum 
----+-----
  1 |   2
  2 |   4
(2 rows)

reset enable_hashagg;
-- bug #15613: bad plan for foreign table scan with lateral reference
--Testcase 274:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT (ref_0.v->>'c2')::int8 AS c2, subq_1.*
FROM
    "S 1"."T1" AS ref_0,
    LATERAL (
        SELECT (ref_0.v->>'c1')::int8 c1, subq_0.*
        FROM (SELECT (ref_0.v->>'c2')::int as c2, (ref_1.v->>'c3') as c3
              FROM ft1 AS ref_1) AS subq_0
             RIGHT JOIN ft2 AS ref_3 ON (subq_0.c3 = (ref_3.v->>'c3'))
    ) AS subq_1
WHERE (ref_0.v->>'c1')::int8 < 10 AND subq_1.c3 = '00001'
ORDER BY (ref_0.v->>'c1')::int8;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: ((ref_0.v ->> 'c2'::text))::bigint, ((ref_0.v ->> 'c1'::text))::bigint, (((ref_0.v ->> 'c2'::text))::integer), (ref_1.v ->> 'c3'::text), ((ref_0.v ->> 'c1'::text))::bigint
   ->  Nested Loop
         Output: ref_0.v, ref_1.v, (((ref_0.v ->> 'c2'::text))::integer)
         ->  Foreign Scan on "S 1"."T1" ref_0
               Output: ref_0.v
               Filter: (((ref_0.v ->> 'c1'::text))::bigint < 10)
               Reader: Single File
               Row groups: 1
         ->  Foreign Scan on public.ft1 ref_1
               Output: ref_1.v, ((ref_0.v ->> 'c2'::text))::integer
               Filter: ((ref_1.v ->> 'c3'::text) = '00001'::text)
               Reader: Single File
               Row groups: 1
   ->  Materialize
         Output: ref_3.v
         ->  Foreign Scan on public.ft2 ref_3
               Output: ref_3.v
               Filter: ((ref_3.v ->> 'c3'::text) = '00001'::text)
               Reader: Single File
               Row groups: 1
(21 rows)

--Testcase 275:
SELECT (ref_0.v->>'c2')::int8 AS c2, subq_1.*
FROM
    "S 1"."T1" AS ref_0,
    LATERAL (
        SELECT (ref_0.v->>'c1')::int8 c1, subq_0.*
        FROM (SELECT (ref_0.v->>'c2')::int as c2, (ref_1.v->>'c3') as c3
              FROM ft1 AS ref_1) AS subq_0
             RIGHT JOIN ft2 AS ref_3 ON (subq_0.c3 = (ref_3.v->>'c3'))
    ) AS subq_1
WHERE (ref_0.v->>'c1')::int8 < 10 AND subq_1.c3 = '00001'
ORDER BY (ref_0.v->>'c1')::int8;
 c2 | c1 | c2 |  c3   
----+----+----+-------
  1 |  1 |  1 | 00001
  2 |  2 |  2 | 00001
  3 |  3 |  3 | 00001
  4 |  4 |  4 | 00001
  5 |  5 |  5 | 00001
  6 |  6 |  6 | 00001
  7 |  7 |  7 | 00001
  8 |  8 |  8 | 00001
  9 |  9 |  9 | 00001
(9 rows)

-- Check with placeHolderVars
--Testcase 276:
explain (verbose, costs off)
select sum(q.a), count(q.b) from ft4 left join (select 13, avg((ft1.v->>'c1')::int8), sum((ft2.v->>'c1')::int8) from ft1 right join ft2 on ((ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8)) q(a, b, c) on ((ft4.v->>'c1')::int8 <= q.b);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: sum(q.a), count(q.b)
   ->  Nested Loop Left Join
         Output: q.a, q.b
         Inner Unique: true
         Join Filter: ((((ft4.v ->> 'c1'::text))::bigint)::numeric <= q.b)
         ->  Foreign Scan on public.ft4
               Output: ft4.v
               Reader: Single File
               Row groups: 1
         ->  Materialize
               Output: q.a, q.b
               ->  Subquery Scan on q
                     Output: q.a, q.b
                     ->  Aggregate
                           Output: 13, avg(((ft1.v ->> 'c1'::text))::bigint), NULL::numeric
                           ->  Merge Left Join
                                 Output: ft1.v
                                 Merge Cond: (((ft2.v ->> 'c1'::text))::bigint = ((ft1.v ->> 'c1'::text))::bigint)
                                 ->  Foreign Scan on public.ft2
                                       Output: ft2.v
                                       Reader: Single File
                                       Row groups: 1
                                 ->  Materialize
                                       Output: ft1.v
                                       ->  Foreign Scan on public.ft1
                                             Output: ft1.v
                                             Reader: Single File
                                             Row groups: 1
(29 rows)

--Testcase 277:
select sum(q.a), count(q.b) from ft4 left join (select 13, avg((ft1.v->>'c1')::int8), sum((ft2.v->>'c1')::int8) from ft1 right join ft2 on ((ft1.v->>'c1')::int8 = (ft2.v->>'c1')::int8)) q(a, b, c) on ((ft4.v->>'c1')::int8 <= q.b);
 sum | count 
-----+-------
 650 |    50
(1 row)

-- Not supported cases
-- Grouping sets
--Testcase 278:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by rollup((v->>'c2')::int) order by 1 nulls last;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  MixedAggregate
         Output: (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint)
         Hash Key: ((ft1.v ->> 'c2'::text))::integer
         Group Key: ()
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 3)
               Reader: Single File
               Row groups: 1
(12 rows)

--Testcase 279:
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by rollup((v->>'c2')::int) order by 1 nulls last;
 c2 |  sum   
----+--------
  0 |  50500
  1 |  49600
  2 |  49700
    | 149800
(4 rows)

--Testcase 280:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by cube((v->>'c2')::int) order by 1 nulls last;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  MixedAggregate
         Output: (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint)
         Hash Key: ((ft1.v ->> 'c2'::text))::integer
         Group Key: ()
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 3)
               Reader: Single File
               Row groups: 1
(12 rows)

--Testcase 281:
select (v->>'c2')::int as c2, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by cube((v->>'c2')::int) order by 1 nulls last;
 c2 |  sum   
----+--------
  0 |  50500
  1 |  49600
  2 |  49700
    | 149800
(4 rows)

--Testcase 282:
explain (verbose, costs off)
select (v->>'c2')::int as c2, (v->>'c6') as c6, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by grouping sets((v->>'c2')::int, (v->>'c6')) order by 1 nulls last, 2 nulls last;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), ((v ->> 'c6'::text)), (sum(((v ->> 'c1'::text))::bigint))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer), ((ft1.v ->> 'c6'::text))
   ->  HashAggregate
         Output: (((v ->> 'c2'::text))::integer), ((v ->> 'c6'::text)), sum(((v ->> 'c1'::text))::bigint)
         Hash Key: ((ft1.v ->> 'c2'::text))::integer
         Hash Key: (ft1.v ->> 'c6'::text)
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, (v ->> 'c6'::text), v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 3)
               Reader: Single File
               Row groups: 1
(12 rows)

--Testcase 283:
select (v->>'c2')::int as c2, (v->>'c6') as c6, sum((v->>'c1')::int8) from ft1 where (v->>'c2')::int < 3 group by grouping sets((v->>'c2')::int, (v->>'c6')) order by 1 nulls last, 2 nulls last;
 c2 | c6 |  sum  
----+----+-------
  0 |    | 50500
  1 |    | 49600
  2 |    | 49700
    | 0  | 50500
    | 1  | 49600
    | 2  | 49700
(6 rows)

--Testcase 284:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c1')::int8), grouping((v->>'c2')::int) from ft1 where (v->>'c2')::int < 3 group by (v->>'c2')::int order by 1 nulls last;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum(((v ->> 'c1'::text))::bigint)), (GROUPING((((v ->> 'c2'::text))::integer)))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  HashAggregate
         Output: (((v ->> 'c2'::text))::integer), sum(((v ->> 'c1'::text))::bigint), GROUPING((((v ->> 'c2'::text))::integer))
         Group Key: ((ft1.v ->> 'c2'::text))::integer
         ->  Foreign Scan on public.ft1
               Output: ((v ->> 'c2'::text))::integer, v
               Filter: (((ft1.v ->> 'c2'::text))::integer < 3)
               Reader: Single File
               Row groups: 1
(11 rows)

--Testcase 285:
select (v->>'c2')::int as c2, sum((v->>'c1')::int8), grouping((v->>'c2')::int) from ft1 where (v->>'c2')::int < 3 group by (v->>'c2')::int order by 1 nulls last;
 c2 |  sum  | grouping 
----+-------+----------
  0 | 50500 |        0
  1 | 49600 |        0
  2 | 49700 |        0
(3 rows)

-- DISTINCT itself is not pushed down, whereas underneath aggregate is pushed
--Testcase 286:
explain (verbose, costs off)
select distinct sum((v->>'c1')::int4)/1000 s from ft2 where (v->>'c2')::int < 6 group by (v->>'c2')::int order by 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Unique
   Output: ((sum(((v ->> 'c1'::text))::integer) / 1000)), (((v ->> 'c2'::text))::integer)
   ->  Sort
         Output: ((sum(((v ->> 'c1'::text))::integer) / 1000)), (((v ->> 'c2'::text))::integer)
         Sort Key: ((sum(((ft2.v ->> 'c1'::text))::integer) / 1000))
         ->  HashAggregate
               Output: (sum(((v ->> 'c1'::text))::integer) / 1000), (((v ->> 'c2'::text))::integer)
               Group Key: ((ft2.v ->> 'c2'::text))::integer
               ->  Foreign Scan on public.ft2
                     Output: ((v ->> 'c2'::text))::integer, v
                     Filter: (((ft2.v ->> 'c2'::text))::integer < 6)
                     Reader: Single File
                     Row groups: 1
(13 rows)

--Testcase 287:
select distinct sum((v->>'c1')::int4)/1000 s from ft2 where (v->>'c2')::int < 6 group by (v->>'c2')::int order by 1;
 s  
----
 49
 50
(2 rows)

-- WindowAgg
--Testcase 288:
explain (verbose, costs off)
select (v->>'c2')::int as c2, sum((v->>'c2')::int), count((v->>'c2')::int) over (partition by (v->>'c2')::int%2) from ft2 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (sum((((v ->> 'c2'::text))::integer))), (count((((v ->> 'c2'::text))::integer)) OVER (?)), (((((v ->> 'c2'::text))::integer) % 2))
   Sort Key: (((ft2.v ->> 'c2'::text))::integer)
   ->  WindowAgg
         Output: (((v ->> 'c2'::text))::integer), (sum((((v ->> 'c2'::text))::integer))), count((((v ->> 'c2'::text))::integer)) OVER (?), (((((v ->> 'c2'::text))::integer) % 2))
         ->  Sort
               Output: (((v ->> 'c2'::text))::integer), (((((v ->> 'c2'::text))::integer) % 2)), (sum((((v ->> 'c2'::text))::integer))), v
               Sort Key: (((((ft2.v ->> 'c2'::text))::integer) % 2))
               ->  HashAggregate
                     Output: (((v ->> 'c2'::text))::integer), ((((v ->> 'c2'::text))::integer) % 2), sum((((v ->> 'c2'::text))::integer)), v
                     Group Key: ((ft2.v ->> 'c2'::text))::integer
                     ->  Foreign Scan on public.ft2
                           Output: ((v ->> 'c2'::text))::integer, v
                           Filter: (((ft2.v ->> 'c2'::text))::integer < 10)
                           Reader: Single File
                           Row groups: 1
(16 rows)

--Testcase 289:
select (v->>'c2')::int as c2, sum((v->>'c2')::int), count((v->>'c2')::int) over (partition by (v->>'c2')::int%2) from ft2 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
 c2 | sum | count 
----+-----+-------
  0 |   0 |     5
  1 | 100 |     5
  2 | 200 |     5
  3 | 300 |     5
  4 | 400 |     5
  5 | 500 |     5
  6 | 600 |     5
  7 | 700 |     5
  8 | 800 |     5
  9 | 900 |     5
(10 rows)

--Testcase 290:
explain (verbose, costs off)
select (v->>'c2')::int as c2, array_agg((v->>'c2')::int) over (partition by (v->>'c2')::int%2 order by (v->>'c2')::int desc) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (array_agg((((v ->> 'c2'::text))::integer)) OVER (?)), (((((v ->> 'c2'::text))::integer) % 2))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  WindowAgg
         Output: (((v ->> 'c2'::text))::integer), array_agg((((v ->> 'c2'::text))::integer)) OVER (?), (((((v ->> 'c2'::text))::integer) % 2))
         ->  Sort
               Output: (((v ->> 'c2'::text))::integer), (((((v ->> 'c2'::text))::integer) % 2)), v
               Sort Key: (((((ft1.v ->> 'c2'::text))::integer) % 2)), (((ft1.v ->> 'c2'::text))::integer) DESC
               ->  HashAggregate
                     Output: (((v ->> 'c2'::text))::integer), ((((v ->> 'c2'::text))::integer) % 2), v
                     Group Key: ((ft1.v ->> 'c2'::text))::integer
                     ->  Foreign Scan on public.ft1
                           Output: ((v ->> 'c2'::text))::integer, v
                           Filter: (((ft1.v ->> 'c2'::text))::integer < 10)
                           Reader: Single File
                           Row groups: 1
(16 rows)

--Testcase 291:
select (v->>'c2')::int as c2, array_agg((v->>'c2')::int) over (partition by (v->>'c2')::int%2 order by (v->>'c2')::int desc) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
 c2 |  array_agg  
----+-------------
  0 | {8,6,4,2,0}
  1 | {9,7,5,3,1}
  2 | {8,6,4,2}
  3 | {9,7,5,3}
  4 | {8,6,4}
  5 | {9,7,5}
  6 | {8,6}
  7 | {9,7}
  8 | {8}
  9 | {9}
(10 rows)

--Testcase 292:
explain (verbose, costs off)
select (v->>'c2')::int as c2, array_agg((v->>'c2')::int) over (partition by (v->>'c2')::int%2 order by (v->>'c2')::int range between current row and unbounded following) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (((v ->> 'c2'::text))::integer), (array_agg((((v ->> 'c2'::text))::integer)) OVER (?)), (((((v ->> 'c2'::text))::integer) % 2))
   Sort Key: (((ft1.v ->> 'c2'::text))::integer)
   ->  WindowAgg
         Output: (((v ->> 'c2'::text))::integer), array_agg((((v ->> 'c2'::text))::integer)) OVER (?), (((((v ->> 'c2'::text))::integer) % 2))
         ->  Sort
               Output: (((v ->> 'c2'::text))::integer), (((((v ->> 'c2'::text))::integer) % 2)), v
               Sort Key: (((((ft1.v ->> 'c2'::text))::integer) % 2)), (((ft1.v ->> 'c2'::text))::integer)
               ->  HashAggregate
                     Output: (((v ->> 'c2'::text))::integer), ((((v ->> 'c2'::text))::integer) % 2), v
                     Group Key: ((ft1.v ->> 'c2'::text))::integer
                     ->  Foreign Scan on public.ft1
                           Output: ((v ->> 'c2'::text))::integer, v
                           Filter: (((ft1.v ->> 'c2'::text))::integer < 10)
                           Reader: Single File
                           Row groups: 1
(16 rows)

--Testcase 293:
select (v->>'c2')::int as c2, array_agg((v->>'c2')::int) over (partition by (v->>'c2')::int%2 order by (v->>'c2')::int range between current row and unbounded following) from ft1 where (v->>'c2')::int < 10 group by (v->>'c2')::int order by 1;
 c2 |  array_agg  
----+-------------
  0 | {0,2,4,6,8}
  1 | {1,3,5,7,9}
  2 | {2,4,6,8}
  3 | {3,5,7,9}
  4 | {4,6,8}
  5 | {5,7,9}
  6 | {6,8}
  7 | {7,9}
  8 | {8}
  9 | {9}
(10 rows)

-- ===================================================================
-- parameterized queries
-- ===================================================================
-- simple join
--Testcase 294:
PREPARE st1(int, int) AS SELECT (t1.v->>'c3') as c3, (t2.v->>'c3') as c3 FROM ft1 t1, ft2 t2 WHERE (t1.v->>'c1')::int8 = $1 AND (t2.v->>'c1')::int8 = $2;
--Testcase 295:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st1(1, 2);
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop
   Output: (t1.v ->> 'c3'::text), (t2.v ->> 'c3'::text)
   ->  Foreign Scan on public.ft1 t1
         Output: t1.v
         Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
         Reader: Single File
         Row groups: 1
   ->  Materialize
         Output: t2.v
         ->  Foreign Scan on public.ft2 t2
               Output: t2.v
               Filter: (((t2.v ->> 'c1'::text))::bigint = 2)
               Reader: Single File
               Row groups: 1
(14 rows)

--Testcase 296:
EXECUTE st1(1, 1);
  c3   |  c3   
-------+-------
 00001 | 00001
(1 row)

--Testcase 297:
EXECUTE st1(101, 101);
  c3   |  c3   
-------+-------
 00101 | 00101
(1 row)

-- subquery using stable function (can't be sent to remote)
--Testcase 298:
PREPARE st2(int) AS SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 < $2 AND (t1.v->>'c3')::int IN (SELECT (v->>'c3')::int as c3 FROM ft2 t2 WHERE (v->>'c1')::int8 > $1 AND date((v->>'c5')::timestamp) = '1970-01-17'::date) ORDER BY (v->>'c1')::int8;
--Testcase 299:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st2(10, 20);
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.v, (((t1.v ->> 'c1'::text))::bigint)
   Sort Key: (((t1.v ->> 'c1'::text))::bigint)
   ->  Hash Semi Join
         Output: t1.v, ((t1.v ->> 'c1'::text))::bigint
         Hash Cond: (((t1.v ->> 'c3'::text))::integer = ((t2.v ->> 'c3'::text))::integer)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Filter: (((t1.v ->> 'c1'::text))::bigint < '20'::bigint)
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Filter: ((((t2.v ->> 'c1'::text))::bigint > 10) AND (date(((t2.v ->> 'c5'::text))::timestamp without time zone) = '01-17-1970'::date))
                     Reader: Single File
                     Row groups: 1
(18 rows)

--Testcase 300:
EXECUTE st2(10, 20);
                                                    v                                                    
---------------------------------------------------------------------------------------------------------
 {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
(1 row)

--Testcase 301:
EXECUTE st2(101, 121);
                                                    v                                                     
----------------------------------------------------------------------------------------------------------
 {"c1": 116, "c2": 6, "c3": "00116", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
(1 row)

-- subquery using immutable function (can be sent to remote)
--Testcase 302:
PREPARE st3(int) AS SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 < $2 AND (t1.v->>'c3')::int IN (SELECT (v->>'c3')::int as c3 FROM ft2 t2 WHERE (v->>'c1')::int8 > $1 AND date((v->>'c5')::timestamp) = '1970-01-17'::date) ORDER BY (v->>'c1')::int8;
--Testcase 303:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st3(10, 20);
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.v, (((t1.v ->> 'c1'::text))::bigint)
   Sort Key: (((t1.v ->> 'c1'::text))::bigint)
   ->  Hash Semi Join
         Output: t1.v, ((t1.v ->> 'c1'::text))::bigint
         Hash Cond: (((t1.v ->> 'c3'::text))::integer = ((t2.v ->> 'c3'::text))::integer)
         ->  Foreign Scan on public.ft1 t1
               Output: t1.v
               Filter: (((t1.v ->> 'c1'::text))::bigint < '20'::bigint)
               Reader: Single File
               Row groups: 1
         ->  Hash
               Output: t2.v
               ->  Foreign Scan on public.ft2 t2
                     Output: t2.v
                     Filter: ((((t2.v ->> 'c1'::text))::bigint > 10) AND (date(((t2.v ->> 'c5'::text))::timestamp without time zone) = '01-17-1970'::date))
                     Reader: Single File
                     Row groups: 1
(18 rows)

--Testcase 304:
EXECUTE st3(10, 20);
                                                    v                                                    
---------------------------------------------------------------------------------------------------------
 {"c1": 16, "c2": 6, "c3": "00016", "c5": "Sat Jan 17 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
(1 row)

--Testcase 305:
EXECUTE st3(20, 30);
 v 
---
(0 rows)

-- custom plan should be chosen initially
--Testcase 306:
PREPARE st4(int) AS SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = $1;
--Testcase 307:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 308:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 309:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 310:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 311:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                   QUERY PLAN                    
-------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = 1)
   Reader: Single File
   Row groups: 1
(5 rows)

-- once we try it enough times, should switch to generic plan
--Testcase 312:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st4(1);
                    QUERY PLAN                    
--------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = $1)
   Reader: Single File
   Row groups: 1
(5 rows)

-- value of $1 should not be sent to remote
--Testcase 313:
PREPARE st5(user_enum,int) AS SELECT * FROM ft1 t1 WHERE v->>'c8' = $1::text and (v->>'c1')::int8 = $2;
--Testcase 314:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 315:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 316:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 317:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 318:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ('foo'::user_enum)::text) AND (((t1.v ->> 'c1'::text))::bigint = 1))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 319:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st5('foo', 1);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c8'::text) = ($1)::text) AND (((t1.v ->> 'c1'::text))::bigint = $2))
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 320:
EXECUTE st5('foo', 1);
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- altering FDW options requires replanning
--Testcase 321:
PREPARE st6 AS SELECT * FROM ft1 t1 WHERE (t1.v->>'c1')::int8 = (t1.v->>'c2')::int;
--Testcase 322:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st6;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c2'::text))::integer)
   Reader: Single File
   Row groups: 1
(5 rows)

-- parquet_s3_does not support INSERT
-- PREPARE st7 AS INSERT INTO ft1 (c1,c2,c3) VALUES (1001,101,'foo');
-- EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st7;
-- ALTER TABLE "S 1"."T1" RENAME TO "T0";
\set var :PATH_FILENAME'/ported_postgres/T0.parquet'
ALTER FOREIGN TABLE ft1 OPTIONS (SET filename :'var');
--Testcase 323:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st6;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (((t1.v ->> 'c1'::text))::bigint = ((t1.v ->> 'c2'::text))::integer)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 324:
EXECUTE st6;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
 {"c1": 2, "c2": 2, "c3": "00002", "c5": "Sat Jan 03 00:00:00 1970", "c6": "2", "c7": "2", "c8": "foo"}
 {"c1": 3, "c2": 3, "c3": "00003", "c5": "Sun Jan 04 00:00:00 1970", "c6": "3", "c7": "3", "c8": "foo"}
 {"c1": 4, "c2": 4, "c3": "00004", "c5": "Mon Jan 05 00:00:00 1970", "c6": "4", "c7": "4", "c8": "foo"}
 {"c1": 5, "c2": 5, "c3": "00005", "c5": "Tue Jan 06 00:00:00 1970", "c6": "5", "c7": "5", "c8": "foo"}
 {"c1": 6, "c2": 6, "c3": "00006", "c5": "Wed Jan 07 00:00:00 1970", "c6": "6", "c7": "6", "c8": "foo"}
 {"c1": 7, "c2": 7, "c3": "00007", "c5": "Thu Jan 08 00:00:00 1970", "c6": "7", "c7": "7", "c8": "foo"}
 {"c1": 8, "c2": 8, "c3": "00008", "c5": "Fri Jan 09 00:00:00 1970", "c6": "8", "c7": "8", "c8": "foo"}
 {"c1": 9, "c2": 9, "c3": "00009", "c5": "Sat Jan 10 00:00:00 1970", "c6": "9", "c7": "9", "c8": "foo"}
(9 rows)

-- EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st7;
-- ALTER TABLE "S 1"."T0" RENAME TO "T1";
\set var :PATH_FILENAME'/ported_postgres/T1.parquet'
ALTER FOREIGN TABLE ft1 OPTIONS (SET filename :'var');
--Testcase 325:
PREPARE st8 AS SELECT count(v->>'c3') FROM ft1 t1 WHERE (t1.v->>'c1')::int === (t1.v->>'c2')::int;
--Testcase 326:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st8;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

ALTER SERVER parquet_s3_srv OPTIONS (DROP extensions);
--Testcase 327:
EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st8;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Aggregate
   Output: count((v ->> 'c3'::text))
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (((t1.v ->> 'c1'::text))::integer === ((t1.v ->> 'c2'::text))::integer)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 328:
EXECUTE st8;
 count 
-------
     9
(1 row)

ALTER SERVER parquet_s3_srv OPTIONS (ADD extensions 'parquet_s3_fdw');
-- cleanup
DEALLOCATE st1;
DEALLOCATE st2;
DEALLOCATE st3;
DEALLOCATE st4;
DEALLOCATE st5;
DEALLOCATE st6;
-- DEALLOCATE st7;
DEALLOCATE st8;
-- System columns, except ctid and oid, should not be sent to remote
--Testcase 329:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM ft1 t1 WHERE t1.tableoid = 'pg_class'::regclass LIMIT 1;
                 QUERY PLAN                  
---------------------------------------------
 Limit
   Output: v
   ->  Foreign Scan on public.ft1 t1
         Output: v
         Filter: (t1.tableoid = '1259'::oid)
         Reader: Single File
         Row groups: 1
(7 rows)

--Testcase 330:
SELECT * FROM ft1 t1 WHERE t1.tableoid = 'ft1'::regclass LIMIT 1;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

--Testcase 331:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT tableoid::regclass, * FROM ft1 t1 LIMIT 1;
               QUERY PLAN                
-----------------------------------------
 Limit
   Output: ((tableoid)::regclass), v
   ->  Foreign Scan on public.ft1 t1
         Output: (tableoid)::regclass, v
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 332:
SELECT tableoid::regclass, * FROM ft1 t1 LIMIT 1;
 tableoid |                                                   v                                                    
----------+--------------------------------------------------------------------------------------------------------
 ft1      | {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

--Testcase 333:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM ft1 t1 WHERE t1.ctid = '(0,2)';
             QUERY PLAN             
------------------------------------
 Foreign Scan on public.ft1 t1
   Output: v
   Filter: (t1.ctid = '(0,2)'::tid)
   Reader: Single File
   Row groups: 1
(5 rows)

--Testcase 334:
SELECT * FROM ft1 t1 WHERE t1.ctid = '(0,2)';
 v 
---
(0 rows)

--Testcase 335:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT ctid, * FROM ft1 t1 LIMIT 1;
             QUERY PLAN              
-------------------------------------
 Limit
   Output: ctid, v
   ->  Foreign Scan on public.ft1 t1
         Output: ctid, v
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 336:
SELECT ctid, * FROM ft1 t1 LIMIT 1;
      ctid      |                                                   v                                                    
----------------+--------------------------------------------------------------------------------------------------------
 (4294967295,0) | {"c1": 1, "c2": 1, "c3": "00001", "c5": "Fri Jan 02 00:00:00 1970", "c6": "1", "c7": "1", "c8": "foo"}
(1 row)

-- ===================================================================
-- used in PL/pgSQL function
-- ===================================================================
--Testcase 337:
CREATE OR REPLACE FUNCTION f_test(p_c1 int) RETURNS int AS $$
DECLARE
	v_c1 int;
BEGIN
--Testcase 338:
    SELECT (v->>'c1')::int8 INTO v_c1 FROM ft1 WHERE (v->>'c1')::int8 = p_c1 LIMIT 1;
    PERFORM (v->>'c1')::int8 FROM ft1 WHERE (v->>'c1')::int8 = p_c1 AND p_c1 = v_c1 LIMIT 1;
    RETURN v_c1;
END;
$$ LANGUAGE plpgsql;
--Testcase 339:
SELECT f_test(100);
 f_test 
--------
    100
(1 row)

--Testcase 340:
DROP FUNCTION f_test(int);
-- ===================================================================
-- REINDEX
-- ===================================================================
-- remote table is not created here
-- raise error when creating foreign table with local file
-- do not raise error with minio/s3 servers but raise error when selecting table
\set var :PATH_FILENAME'/ported_postgres/reindex_local.parquet'
--Testcase 341:
CREATE FOREIGN TABLE reindex_foreign (v jsonb)
  SERVER parquet_s3_srv_2 OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:1384: ERROR:  parquet_s3_fdw: No such file or directory ('/tmp/data_local/ported_postgres/reindex_local.parquet')
REINDEX TABLE reindex_foreign; -- error
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:1385: ERROR:  relation "reindex_foreign" does not exist
REINDEX TABLE CONCURRENTLY reindex_foreign; -- error
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:1386: ERROR:  relation "reindex_foreign" does not exist
--Testcase 342:
DROP FOREIGN TABLE reindex_foreign;
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:1388: ERROR:  foreign table "reindex_foreign" does not exist
-- partitions and foreign tables
-- CREATE TABLE reind_fdw_parent (c1 int) PARTITION BY RANGE ((v->>'c1')::int8);
-- CREATE TABLE reind_fdw_0_10 PARTITION OF reind_fdw_parent
--   FOR VALUES FROM (0) TO (10);
-- CREATE FOREIGN TABLE reind_fdw_10_20 PARTITION OF reind_fdw_parent
--   FOR VALUES FROM (10) TO (20)
--   SERVER loopback OPTIONS (table_name 'reind_local_10_20');
-- REINDEX TABLE reind_fdw_parent; -- ok
-- REINDEX TABLE CONCURRENTLY reind_fdw_parent; -- ok
-- DROP TABLE reind_fdw_parent;
-- ===================================================================
-- conversion error
-- ===================================================================
-- ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE int;
-- SELECT * FROM ft1 ftx(x1,x2,x3,x4,x5,x6,x7,x8) WHERE x1 = 1;  -- ERROR
-- SELECT ftx.x1, ft2.v->>'c2', ftx.x8 FROM ft1 ftx(x1,x2,x3,x4,x5,x6,x7,x8), ft2
--   WHERE ftx.x1 = ft2.v->>'c1' AND ftx.x1 = 1; -- ERROR
-- SELECT ftx.x1, ft2.v->>'c2', ftx FROM ft1 ftx(x1,x2,x3,x4,x5,x6,x7,x8), ft2
--   WHERE ftx.x1 = ft2.v->>'c1' AND ftx.x1 = 1; -- ERROR
-- SELECT sum((v->>'c2')::int), array_agg(c8) FROM ft1 GROUP BY c8; -- ERROR
-- ALTER FOREIGN TABLE ft1 ALTER COLUMN c8 TYPE text;
-- ===================================================================
-- subtransaction
--  + local/remote error doesn't break cursor
-- ===================================================================
-- BEGIN;
-- DECLARE c CURSOR FOR SELECT * FROM ft1 ORDER BY v->>'c1';
-- FETCH c;
-- SAVEPOINT s;
-- ERROR OUT;          -- ERROR
-- ROLLBACK TO s;
-- FETCH c;
-- SAVEPOINT s;
-- SELECT * FROM ft1 WHERE 1 / (c1 - 1) > 0;  -- ERROR
-- ROLLBACK TO s;
-- FETCH c;
-- SELECT * FROM ft1 ORDER BY v->>'c1' LIMIT 1;
-- COMMIT;
-- ===================================================================
-- test handling of collations
-- schemaless foreign table does not have text column, this test is skipped
-- ===================================================================
-- \set var :PATH_FILENAME'/ported_postgres/loct3.parquet'
-- --Testcase 343:
-- create foreign table loct3 (f1 text collate "C", f2 text, f3 varchar(10))
--   server parquet_s3_srv options (filename :'var');
-- --Testcase 344:
-- create foreign table ft3 (f1 text collate "C", f2 text, f3 varchar(10))
--   server parquet_s3_srv options (filename :'var');
-- -- can be sent to remote
-- --Testcase 345:
-- explain (verbose, costs off) select * from ft3 where f1 = 'foo';
-- --Testcase 346:
-- explain (verbose, costs off) select * from ft3 where f1 COLLATE "C" = 'foo';
-- --Testcase 347:
-- explain (verbose, costs off) select * from ft3 where f2 = 'foo';
-- --Testcase 348:
-- explain (verbose, costs off) select * from ft3 where f3 = 'foo';
-- --Testcase 349:
-- explain (verbose, costs off) select * from ft3 f, loct3 l
--   where f.f3 = l.f3 and l.f1 = 'foo';
-- -- can't be sent to remote
-- --Testcase 350:
-- explain (verbose, costs off) select * from ft3 where f1 COLLATE "POSIX" = 'foo';
-- --Testcase 351:
-- explain (verbose, costs off) select * from ft3 where f1 = 'foo' COLLATE "C";
-- --Testcase 352:
-- explain (verbose, costs off) select * from ft3 where f2 COLLATE "C" = 'foo';
-- --Testcase 353:
-- explain (verbose, costs off) select * from ft3 where f2 = 'foo' COLLATE "C";
-- --Testcase 354:
-- explain (verbose, costs off) select * from ft3 f, loct3 l
--   where f.f3 = l.f3 COLLATE "POSIX" and l.f1 = 'foo';
-- ===================================================================
-- test writable foreign table stuff
-- parquet_s3_fdw does not support INSERT DELETE UPDATE
-- ===================================================================
-- EXPLAIN (verbose, costs off)
-- INSERT INTO ft2 (c1,c2,c3) SELECT v->>'c1'+1000,c2+100, c3 || c3 FROM ft2 LIMIT 20;
-- INSERT INTO ft2 (c1,c2,c3) SELECT v->>'c1'+1000,c2+100, c3 || c3 FROM ft2 LIMIT 20;
-- INSERT INTO ft2 (c1,c2,c3)
--   VALUES (1101,201,'aaa'), (1102,202,'bbb'), (1103,203,'ccc') RETURNING *;
-- INSERT INTO ft2 (c1,c2,c3) VALUES (1104,204,'ddd'), (1105,205,'eee');
-- EXPLAIN (verbose, costs off)
-- UPDATE ft2 SET c2 = c2 + 300, c3 = c3 || '_update3' WHERE v->>'c1' % 10 = 3;              -- can be pushed down
-- UPDATE ft2 SET c2 = c2 + 300, c3 = c3 || '_update3' WHERE v->>'c1' % 10 = 3;
-- EXPLAIN (verbose, costs off)
-- UPDATE ft2 SET c2 = c2 + 400, c3 = c3 || '_update7' WHERE v->>'c1' % 10 = 7 RETURNING *;  -- can be pushed down
-- UPDATE ft2 SET c2 = c2 + 400, c3 = c3 || '_update7' WHERE v->>'c1' % 10 = 7 RETURNING *;
-- EXPLAIN (verbose, costs off)
-- UPDATE ft2 SET c2 = ft2.v->>'c2' + 500, c3 = ft2.v->>'c3' || '_update9', c7 = DEFAULT
--   FROM ft1 WHERE (ft1.v->>'c1')::int8 = ft2.v->>'c2' AND (ft1.v->>'c1')::int8 % 10 = 9;                               -- can be pushed down
-- UPDATE ft2 SET c2 = ft2.v->>'c2' + 500, c3 = ft2.v->>'c3' || '_update9', c7 = DEFAULT
--   FROM ft1 WHERE (ft1.v->>'c1')::int8 = ft2.v->>'c2' AND (ft1.v->>'c1')::int8 % 10 = 9;
-- EXPLAIN (verbose, costs off)
--   DELETE FROM ft2 WHERE v->>'c1' % 10 = 5 RETURNING v->>'c1', c4;                               -- can be pushed down
-- DELETE FROM ft2 WHERE v->>'c1' % 10 = 5 RETURNING v->>'c1', c4;
-- EXPLAIN (verbose, costs off)
-- DELETE FROM ft2 USING ft1 WHERE (ft1.v->>'c1')::int8 = ft2.v->>'c2' AND (ft1.v->>'c1')::int8 % 10 = 2;                -- can be pushed down
-- DELETE FROM ft2 USING ft1 WHERE (ft1.v->>'c1')::int8 = ft2.v->>'c2' AND (ft1.v->>'c1')::int8 % 10 = 2;
-- SELECT v->>'c1',c2,c3,c4 FROM ft2 ORDER BY v->>'c1';
-- EXPLAIN (verbose, costs off)
-- INSERT INTO ft2 (c1,c2,c3) VALUES (1200,999,'foo') RETURNING tableoid::regclass;
-- INSERT INTO ft2 (c1,c2,c3) VALUES (1200,999,'foo') RETURNING tableoid::regclass;
-- EXPLAIN (verbose, costs off)
-- UPDATE ft2 SET c3 = 'bar' WHERE v->>'c1' = 1200 RETURNING tableoid::regclass;             -- can be pushed down
-- UPDATE ft2 SET c3 = 'bar' WHERE v->>'c1' = 1200 RETURNING tableoid::regclass;
-- EXPLAIN (verbose, costs off)
-- DELETE FROM ft2 WHERE v->>'c1' = 1200 RETURNING tableoid::regclass;                       -- can be pushed down
-- DELETE FROM ft2 WHERE v->>'c1' = 1200 RETURNING tableoid::regclass;
-- -- Test UPDATE/DELETE with RETURNING on a three-table join
-- INSERT INTO ft2 (c1,c2,c3)
--   SELECT id, id - 1200, to_char(id, 'FM00000') FROM generate_series(1201, 1300) id;
-- EXPLAIN (verbose, costs off)
-- UPDATE ft2 SET c3 = 'foo'
--   FROM ft4 INNER JOIN ft5 ON (ft4.c1 = ft5.c1)
--   WHERE ft2.v->>'c1' > 1200 AND ft2.v->>'c2' = ft4.c1
--   RETURNING ft2, ft2.*, ft4, ft4.*;       -- can be pushed down
-- UPDATE ft2 SET c3 = 'foo'
--   FROM ft4 INNER JOIN ft5 ON (ft4.c1 = ft5.c1)
--   WHERE ft2.v->>'c1' > 1200 AND ft2.v->>'c2' = ft4.c1
--   RETURNING ft2, ft2.*, ft4, ft4.*;
-- EXPLAIN (verbose, costs off)
-- DELETE FROM ft2
--   USING ft4 LEFT JOIN ft5 ON (ft4.c1 = ft5.c1)
--   WHERE ft2.v->>'c1' > 1200 AND ft2.v->>'c1' % 10 = 0 AND ft2.v->>'c2' = ft4.c1
--   RETURNING 100;                          -- can be pushed down
-- DELETE FROM ft2
--   USING ft4 LEFT JOIN ft5 ON (ft4.c1 = ft5.c1)
--   WHERE ft2.v->>'c1' > 1200 AND ft2.v->>'c1' % 10 = 0 AND ft2.v->>'c2' = ft4.c1
--   RETURNING 100;
-- DELETE FROM ft2 WHERE ft2.v->>'c1' > 1200;
-- Test UPDATE with a MULTIEXPR sub-select
-- (maybe someday this'll be remotely executable, but not today)
-- EXPLAIN (verbose, costs off)
-- UPDATE ft2 AS target SET (c2, c7) = (
--     SELECT c2 * 10, c7
--         FROM ft2 AS src
--         WHERE target.c1 = src.c1
-- ) WHERE v->>'c1' > 1100;
-- UPDATE ft2 AS target SET (c2, c7) = (
--     SELECT c2 * 10, c7
--         FROM ft2 AS src
--         WHERE target.c1 = src.c1
-- ) WHERE v->>'c1' > 1100;
-- UPDATE ft2 AS target SET ((v->>'c2')::int) = (
--     SELECT c2 / 10
--         FROM ft2 AS src
--         WHERE target.c1 = src.c1
-- ) WHERE v->>'c1' > 1100;
-- Test UPDATE involving a join that can be pushed down,
-- but a SET clause that can't be
-- EXPLAIN (VERBOSE, COSTS OFF)
-- UPDATE ft2 d SET c2 = CASE WHEN random() >= 0 THEN d.c2 ELSE 0 END
--   FROM ft2 AS t WHERE d.c1 = t.c1 AND d.c1 > 1000;
-- UPDATE ft2 d SET c2 = CASE WHEN random() >= 0 THEN d.c2 ELSE 0 END
--   FROM ft2 AS t WHERE d.c1 = t.c1 AND d.c1 > 1000;
-- Test UPDATE/DELETE with WHERE or JOIN/ON conditions containing
-- user-defined operators/functions
-- ALTER SERVER loopback OPTIONS (DROP extensions);
-- INSERT INTO ft2 (c1,c2,c3)
--   SELECT id, id % 10, to_char(id, 'FM00000') FROM generate_series(2001, 2010) id;
-- EXPLAIN (verbose, costs off)
-- UPDATE ft2 SET c3 = 'bar' WHERE postgres_fdw_abs((v->>'c1')::int8) > 2000 RETURNING *;            -- can't be pushed down
-- UPDATE ft2 SET c3 = 'bar' WHERE postgres_fdw_abs((v->>'c1')::int8) > 2000 RETURNING *;
-- EXPLAIN (verbose, costs off)
-- UPDATE ft2 SET c3 = 'baz'
--   FROM ft4 INNER JOIN ft5 ON (ft4.c1 = ft5.c1)
--   WHERE ft2.v->>'c1' > 2000 AND ft2.v->>'c2' === ft4.c1
--   RETURNING ft2.*, ft4.*, ft5.*;                                                    -- can't be pushed down
-- UPDATE ft2 SET c3 = 'baz'
--   FROM ft4 INNER JOIN ft5 ON (ft4.c1 = ft5.c1)
--   WHERE ft2.v->>'c1' > 2000 AND ft2.v->>'c2' === ft4.c1
--   RETURNING ft2.*, ft4.*, ft5.*;
-- EXPLAIN (verbose, costs off)
-- DELETE FROM ft2
--   USING ft4 INNER JOIN ft5 ON (ft4.c1 === ft5.c1)
--   WHERE ft2.v->>'c1' > 2000 AND ft2.v->>'c2' = ft4.c1
--   RETURNING ft2.v->>'c1', ft2.v->>'c2', ft2.v->>'c3';       -- can't be pushed down
-- DELETE FROM ft2
--   USING ft4 INNER JOIN ft5 ON (ft4.c1 === ft5.c1)
--   WHERE ft2.v->>'c1' > 2000 AND ft2.v->>'c2' = ft4.c1
--   RETURNING ft2.v->>'c1', ft2.v->>'c2', ft2.v->>'c3';
-- DELETE FROM ft2 WHERE ft2.v->>'c1' > 2000;
-- ALTER SERVER loopback OPTIONS (ADD extensions 'postgres_fdw');
-- -- Test that trigger on remote table works as expected
-- CREATE OR REPLACE FUNCTION "S 1".F_BRTRIG() RETURNS trigger AS $$
-- BEGIN
--     NEW.c3 = NEW.c3 || '_trig_update';
--     RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql;
-- CREATE TRIGGER t1_br_insert BEFORE INSERT OR UPDATE
--     ON "S 1"."T 1" FOR EACH ROW EXECUTE PROCEDURE "S 1".F_BRTRIG();
-- INSERT INTO ft2 (c1,c2,c3) VALUES (1208, 818, 'fff') RETURNING *;
-- INSERT INTO ft2 (c1,c2,c3,c6) VALUES (1218, 818, 'ggg', '(--;') RETURNING *;
-- UPDATE ft2 SET c2 = c2 + 600 WHERE v->>'c1' % 10 = 8 AND (v->>'c1')::int8 < 1200 RETURNING *;
-- -- Test errors thrown on remote side during update
-- ALTER TABLE "S 1"."T 1" ADD CONSTRAINT c2positive CHECK (c2 >= 0);
-- INSERT INTO ft1(c1, c2) VALUES(11, 12);  -- duplicate key
-- INSERT INTO ft1(c1, c2) VALUES(11, 12) ON CONFLICT DO NOTHING; -- works
-- INSERT INTO ft1(c1, c2) VALUES(11, 12) ON CONFLICT (c1, c2) DO NOTHING; -- unsupported
-- INSERT INTO ft1(c1, c2) VALUES(11, 12) ON CONFLICT (c1, c2) DO UPDATE SET c3 = 'ffg'; -- unsupported
-- INSERT INTO ft1(c1, c2) VALUES(1111, -2);  -- c2positive
-- UPDATE ft1 SET c2 = -c2 WHERE v->>'c1' = 1;  -- c2positive
-- Test savepoint/rollback behavior
--Testcase 355:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

--Testcase 356:
select (v->>'c2')::int as c2, count(*) from "S 1"."T1" where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

begin;
-- update ft2 set c2 = 42 where c2 = 0;
--Testcase 357:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

savepoint s1;
-- update ft2 set c2 = 44 where c2 = 4;
--Testcase 358:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

release savepoint s1;
--Testcase 359:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

savepoint s2;
-- update ft2 set c2 = 46 where c2 = 6;
--Testcase 360:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

rollback to savepoint s2;
--Testcase 361:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

release savepoint s2;
--Testcase 362:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

savepoint s3;
-- update ft2 set c2 = -2 where c2 = 42 and v->>'c1' = 10; -- fail on remote side
rollback to savepoint s3;
--Testcase 363:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

release savepoint s3;
--Testcase 364:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

-- none of the above is committed yet remotely
--Testcase 365:
select (v->>'c2')::int as c2, count(*) from "S 1"."T1" where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

commit;
--Testcase 366:
select (v->>'c2')::int as c2, count(*) from ft2 where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

--Testcase 367:
select (v->>'c2')::int as c2, count(*) from "S 1"."T1" where (v->>'c2')::int < 500 group by 1 order by 1;
 c2 | count 
----+-------
  0 |   100
  1 |   100
  2 |   100
  3 |   100
  4 |   100
  5 |   100
  6 |   100
  7 |   100
  8 |   100
  9 |   100
(10 rows)

-- VACUUM ANALYZE "S 1"."T1";
-- Above DMLs add data with v->>'c6' as NULL in ft1, so test ORDER BY NULLS LAST and NULLs
-- FIRST behavior here.
-- ORDER BY DESC NULLS LAST options
\set var :PATH_FILENAME'/ported_postgres/ft1_null.parquet'
--Testcase 368:
CREATE FOREIGN TABLE ft1_null (
	v jsonb
) SERVER parquet_s3_srv
OPTIONS (filename :'var', sorted 'c1', schemaless 'true');
--Testcase 369:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1_null ORDER BY v->>'c6' DESC NULLS LAST, (v->>'c1')::int8 OFFSET 795 LIMIT 10;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Limit
   Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
         Sort Key: ((ft1_null.v ->> 'c6'::text)) DESC NULLS LAST, (((ft1_null.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1_null
               Output: v, (v ->> 'c6'::text), ((v ->> 'c1'::text))::bigint
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 370:
SELECT * FROM ft1_null ORDER BY v->>'c6' DESC NULLS LAST, (v->>'c1')::int8 OFFSET 795  LIMIT 10;
                                                    v                                                    
---------------------------------------------------------------------------------------------------------
 {"c1": 591, "c2": 1, "c3": "00591", "c5": "Thu Apr 02 00:00:00 1970", "c6": "", "c7": "1", "c8": "foo"}
 {"c1": 593, "c2": 3, "c3": "00593", "c5": "Sat Apr 04 00:00:00 1970", "c6": "", "c7": "3", "c8": "foo"}
 {"c1": 595, "c2": 5, "c3": "00595", "c5": "Mon Apr 06 00:00:00 1970", "c6": "", "c7": "5", "c8": "foo"}
 {"c1": 597, "c2": 7, "c3": "00597", "c5": "Wed Apr 08 00:00:00 1970", "c6": "", "c7": "7", "c8": "foo"}
 {"c1": 599, "c2": 9, "c3": "00599", "c5": "Fri Apr 10 00:00:00 1970", "c6": "", "c7": "9", "c8": "foo"}
 {"c1": 601, "c2": 1, "c3": "00601", "c5": "Fri Jan 02 00:00:00 1970", "c6": "", "c7": "1", "c8": "foo"}
 {"c1": 603, "c2": 3, "c3": "00603", "c5": "Sun Jan 04 00:00:00 1970", "c6": "", "c7": "3", "c8": "foo"}
 {"c1": 605, "c2": 5, "c3": "00605", "c5": "Tue Jan 06 00:00:00 1970", "c6": "", "c7": "5", "c8": "foo"}
 {"c1": 607, "c2": 7, "c3": "00607", "c5": "Thu Jan 08 00:00:00 1970", "c6": "", "c7": "7", "c8": "foo"}
 {"c1": 609, "c2": 9, "c3": "00609", "c5": "Sat Jan 10 00:00:00 1970", "c6": "", "c7": "9", "c8": "foo"}
(10 rows)

-- ORDER BY DESC NULLS FIRST options
--Testcase 371:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1_null ORDER BY v->>'c6' DESC NULLS FIRST, (v->>'c1')::int8 OFFSET 15 LIMIT 10;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Limit
   Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
         Sort Key: ((ft1_null.v ->> 'c6'::text)) DESC, (((ft1_null.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1_null
               Output: v, (v ->> 'c6'::text), ((v ->> 'c1'::text))::bigint
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 372:
SELECT * FROM ft1_null ORDER BY v->>'c6' DESC NULLS FIRST, (v->>'c1')::int8 OFFSET 15 LIMIT 10;
                                                     v                                                      
------------------------------------------------------------------------------------------------------------
 {"c1": 32, "c2": 2, "c3": "00032", "c5": "Mon Feb 02 00:00:00 1970", "c6": "(--;", "c7": "2", "c8": "foo"}
 {"c1": 34, "c2": 4, "c3": "00034", "c5": "Wed Feb 04 00:00:00 1970", "c6": "(--;", "c7": "4", "c8": "foo"}
 {"c1": 36, "c2": 6, "c3": "00036", "c5": "Fri Feb 06 00:00:00 1970", "c6": "(--;", "c7": "6", "c8": "foo"}
 {"c1": 38, "c2": 8, "c3": "00038", "c5": "Sun Feb 08 00:00:00 1970", "c6": "(--;", "c7": "8", "c8": "foo"}
 {"c1": 40, "c2": 0, "c3": "00040", "c5": "Tue Feb 10 00:00:00 1970", "c6": "(--;", "c7": "0", "c8": "foo"}
 {"c1": 42, "c2": 2, "c3": "00042", "c5": "Thu Feb 12 00:00:00 1970", "c6": "(--;", "c7": "2", "c8": "foo"}
 {"c1": 44, "c2": 4, "c3": "00044", "c5": "Sat Feb 14 00:00:00 1970", "c6": "(--;", "c7": "4", "c8": "foo"}
 {"c1": 46, "c2": 6, "c3": "00046", "c5": "Mon Feb 16 00:00:00 1970", "c6": "(--;", "c7": "6", "c8": "foo"}
 {"c1": 48, "c2": 8, "c3": "00048", "c5": "Wed Feb 18 00:00:00 1970", "c6": "(--;", "c7": "8", "c8": "foo"}
 {"c1": 50, "c2": 0, "c3": "00050", "c5": "Fri Feb 20 00:00:00 1970", "c6": "(--;", "c7": "0", "c8": "foo"}
(10 rows)

-- ORDER BY ASC NULLS FIRST options
--Testcase 373:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1_null ORDER BY v->>'c6' ASC NULLS FIRST, (v->>'c1')::int8 OFFSET 15 LIMIT 10;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
   ->  Sort
         Output: v, ((v ->> 'c6'::text)), (((v ->> 'c1'::text))::bigint)
         Sort Key: ((ft1_null.v ->> 'c6'::text)) NULLS FIRST, (((ft1_null.v ->> 'c1'::text))::bigint)
         ->  Foreign Scan on public.ft1_null
               Output: v, (v ->> 'c6'::text), ((v ->> 'c1'::text))::bigint
               Reader: Single File
               Row groups: 1
(9 rows)

--Testcase 374:
SELECT * FROM ft1_null ORDER BY v->>'c6' ASC NULLS FIRST, (v->>'c1')::int8 OFFSET 15 LIMIT 10;
                                                   v                                                    
--------------------------------------------------------------------------------------------------------
 {"c1": 31, "c2": 1, "c3": "00031", "c5": "Sun Feb 01 00:00:00 1970", "c6": "", "c7": "1", "c8": "foo"}
 {"c1": 33, "c2": 3, "c3": "00033", "c5": "Tue Feb 03 00:00:00 1970", "c6": "", "c7": "3", "c8": "foo"}
 {"c1": 35, "c2": 5, "c3": "00035", "c5": "Thu Feb 05 00:00:00 1970", "c6": "", "c7": "5", "c8": "foo"}
 {"c1": 37, "c2": 7, "c3": "00037", "c5": "Sat Feb 07 00:00:00 1970", "c6": "", "c7": "7", "c8": "foo"}
 {"c1": 39, "c2": 9, "c3": "00039", "c5": "Mon Feb 09 00:00:00 1970", "c6": "", "c7": "9", "c8": "foo"}
 {"c1": 41, "c2": 1, "c3": "00041", "c5": "Wed Feb 11 00:00:00 1970", "c6": "", "c7": "1", "c8": "foo"}
 {"c1": 43, "c2": 3, "c3": "00043", "c5": "Fri Feb 13 00:00:00 1970", "c6": "", "c7": "3", "c8": "foo"}
 {"c1": 45, "c2": 5, "c3": "00045", "c5": "Sun Feb 15 00:00:00 1970", "c6": "", "c7": "5", "c8": "foo"}
 {"c1": 47, "c2": 7, "c3": "00047", "c5": "Tue Feb 17 00:00:00 1970", "c6": "", "c7": "7", "c8": "foo"}
 {"c1": 49, "c2": 9, "c3": "00049", "c5": "Thu Feb 19 00:00:00 1970", "c6": "", "c7": "9", "c8": "foo"}
(10 rows)

-- ===================================================================
-- test check constraints
-- ===================================================================
-- Consistent check constraints provide consistent results
ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c2positive CHECK ((v->>'c2')::int >= 0);
--Testcase 375:
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM ft1 WHERE (v->>'c2')::int < 0;
                       QUERY PLAN                        
---------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  Foreign Scan on public.ft1
         Filter: (((ft1.v ->> 'c2'::text))::integer < 0)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 376:
SELECT count(*) FROM ft1 WHERE (v->>'c2')::int < 0;
 count 
-------
     0
(1 row)

SET constraint_exclusion = 'on';
--Testcase 377:
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM ft1 WHERE (v->>'c2')::int < 0;
           QUERY PLAN           
--------------------------------
 Aggregate
   Output: count(*)
   ->  Result
         One-Time Filter: false
(4 rows)

--Testcase 378:
SELECT count(*) FROM ft1 WHERE (v->>'c2')::int < 0;
 count 
-------
     0
(1 row)

RESET constraint_exclusion;
-- check constraint is enforced on the remote side, not locally
-- INSERT INTO ft1(c1, c2) VALUES(1111, -2);  -- c2positive
-- UPDATE ft1 SET c2 = -c2 WHERE v->>'c1' = 1;  -- c2positive
ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c2positive;
-- But inconsistent check constraints provide inconsistent results
ALTER FOREIGN TABLE ft1 ADD CONSTRAINT ft1_c2negative CHECK ((v->>'c2')::int < 0);
--Testcase 379:
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM ft1 WHERE (v->>'c2')::int >= 0;
                        QUERY PLAN                        
----------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  Foreign Scan on public.ft1
         Filter: (((ft1.v ->> 'c2'::text))::integer >= 0)
         Reader: Single File
         Row groups: 1
(6 rows)

--Testcase 380:
SELECT count(*) FROM ft1 WHERE (v->>'c2')::int >= 0;
 count 
-------
  1000
(1 row)

SET constraint_exclusion = 'on';
--Testcase 381:
EXPLAIN (VERBOSE, COSTS OFF) SELECT count(*) FROM ft1 WHERE (v->>'c2')::int >= 0;
           QUERY PLAN           
--------------------------------
 Aggregate
   Output: count(*)
   ->  Result
         One-Time Filter: false
(4 rows)

--Testcase 382:
SELECT count(*) FROM ft1 WHERE (v->>'c2')::int >= 0;
 count 
-------
     0
(1 row)

RESET constraint_exclusion;
-- local check constraint is not actually enforced
-- INSERT INTO ft1(c1, c2) VALUES(1111, 2);
-- UPDATE ft1 SET c2 = c2 + 1 WHERE v->>'c1' = 1;
ALTER FOREIGN TABLE ft1 DROP CONSTRAINT ft1_c2negative;
-- ===================================================================
-- test WITH CHECK OPTION constraints
-- ===================================================================
--Testcase 383:
CREATE FUNCTION row_before_insupd_trigfunc() RETURNS trigger AS $$BEGIN NEW.a := NEW.a + 10; RETURN NEW; END$$ LANGUAGE plpgsql;
\set var :PATH_FILENAME'/ported_postgres/base_tbl.parquet'
--Testcase 384:
CREATE FOREIGN TABLE base_tbl (v jsonb)
  SERVER parquet_s3_srv OPTIONS (filename :'var', schemaless 'true');
--Testcase 385:
CREATE TRIGGER row_before_insupd_trigger BEFORE INSERT OR UPDATE ON base_tbl FOR EACH ROW EXECUTE PROCEDURE row_before_insupd_trigfunc();
--Testcase 386:
CREATE FOREIGN TABLE foreign_tbl (v jsonb)
  SERVER parquet_s3_srv OPTIONS (filename :'var', schemaless 'true');
--Testcase 387:
CREATE VIEW rw_view AS SELECT * FROM foreign_tbl
  WHERE (v->>'a')::int < (v->>'b')::int WITH CHECK OPTION;
--Testcase 388:
\d+ rw_view
                          View "public.rw_view"
 Column | Type  | Collation | Nullable | Default | Storage  | Description 
--------+-------+-----------+----------+---------+----------+-------------
 v      | jsonb |           |          |         | extended | 
View definition:
 SELECT foreign_tbl.v
   FROM foreign_tbl
  WHERE ((foreign_tbl.v ->> 'a'::text)::integer) < ((foreign_tbl.v ->> 'b'::text)::integer);
Options: check_option=cascaded

-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO rw_view VALUES (0, 5);
-- INSERT INTO rw_view VALUES (0, 5); -- should fail
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO rw_view VALUES (0, 15);
-- INSERT INTO rw_view VALUES (0, 15); -- ok
-- SELECT * FROM foreign_tbl;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- UPDATE rw_view SET b = b + 5;
-- UPDATE rw_view SET b = b + 5; -- should fail
-- EXPLAIN (VERBOSE, COSTS OFF)
-- UPDATE rw_view SET b = b + 15;
-- UPDATE rw_view SET b = b + 15; -- ok
-- SELECT * FROM foreign_tbl;
--Testcase 389:
DROP FOREIGN TABLE foreign_tbl CASCADE;
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:1756: NOTICE:  drop cascades to view rw_view
--Testcase 390:
DROP TRIGGER row_before_insupd_trigger ON base_tbl;
--Testcase 391:
DROP FOREIGN TABLE base_tbl;
-- test WCO for partitions
-- Postgres does not support create partition by range of jsonb elemnent value.
-- The test below is skipped.
-- \set var :PATH_FILENAME'/ported_postgres/child_tbl.parquet'
-- --Testcase 392:
-- CREATE FOREIGN TABLE child_tbl (v jsonb)
--   SERVER parquet_s3_srv OPTIONS (filename :'var', schemaless 'true');
-- --Testcase 393:
-- CREATE TRIGGER row_before_insupd_trigger BEFORE INSERT OR UPDATE ON child_tbl FOR EACH ROW EXECUTE PROCEDURE row_before_insupd_trigfunc();
-- --Testcase 394:
-- CREATE FOREIGN TABLE foreign_tbl (v jsonb)
--   SERVER parquet_s3_srv OPTIONS (filename :'var', schemaless 'true');
-- --Testcase 395:
-- CREATE TABLE parent_tbl (v jsonb) PARTITION BY RANGE((v->>'a')::int);
-- ALTER TABLE parent_tbl ATTACH PARTITION foreign_tbl FOR VALUES FROM (0) TO (100);
-- --Testcase 396:
-- CREATE VIEW rw_view AS SELECT * FROM parent_tbl
--   WHERE (v->>'a')::int < (v->>'b')::int WITH CHECK OPTION;
-- --Testcase 397:
-- \d+ rw_view
-- -- EXPLAIN (VERBOSE, COSTS OFF)
-- -- INSERT INTO rw_view VALUES (0, 5);
-- -- INSERT INTO rw_view VALUES (0, 5); -- should fail
-- -- EXPLAIN (VERBOSE, COSTS OFF)
-- -- INSERT INTO rw_view VALUES (0, 15);
-- -- INSERT INTO rw_view VALUES (0, 15); -- ok
-- -- SELECT * FROM foreign_tbl;
-- -- EXPLAIN (VERBOSE, COSTS OFF)
-- -- UPDATE rw_view SET b = b + 5;
-- -- UPDATE rw_view SET b = b + 5; -- should fail
-- -- EXPLAIN (VERBOSE, COSTS OFF)
-- -- UPDATE rw_view SET b = b + 15;
-- -- UPDATE rw_view SET b = b + 15; -- ok
-- -- SELECT * FROM foreign_tbl;
-- --Testcase 398:
-- DROP FOREIGN TABLE foreign_tbl CASCADE;
-- --Testcase 399:
-- DROP TRIGGER row_before_insupd_trigger ON child_tbl;
-- --Testcase 400:
-- DROP TABLE parent_tbl CASCADE;
-- --Testcase 401:
-- DROP FUNCTION row_before_insupd_trigfunc;
-- ===================================================================
-- test serial columns (ie, sequence-based defaults)
-- ===================================================================
-- create foreign table rem1 (f1 serial, f2 text)
--   server parquet_s3_srv options(filename 's3://ported_postgres/loc1.parquet');
-- select pg_catalog.setval('rem1_f1_seq', 10, false);
-- select * from rem1;
-- ===================================================================
-- test generated columns
-- ===================================================================
-- create table gloc1 (
--   a int,
--   b int generated always as (a * 2) stored);
-- alter table gloc1 set (autovacuum_enabled = 'false');
-- create foreign table grem1 (
--   a int,
--   b int generated always as (a * 2) stored)
--   server loopback options(table_name 'gloc1');
-- explain (verbose, costs off)
-- insert into grem1 (a) values (1), (2);
-- insert into grem1 (a) values (1), (2);
-- explain (verbose, costs off)
-- update grem1 set a = 22 where a = 2;
-- update grem1 set a = 22 where a = 2;
-- select * from gloc1;
-- select * from grem1;
-- delete from grem1;
-- -- test copy from
-- copy grem1 from stdin;
-- 1
-- 2
-- \.
-- select * from gloc1;
-- select * from grem1;
-- delete from grem1;
-- -- test batch insert
-- alter server loopback options (add batch_size '10');
-- explain (verbose, costs off)
-- insert into grem1 (a) values (1), (2);
-- insert into grem1 (a) values (1), (2);
-- select * from gloc1;
-- select * from grem1;
-- delete from grem1;
-- alter server loopback options (drop batch_size);
-- ===================================================================
-- test local triggers
-- ===================================================================
-- Trigger functions "borrowed" from triggers regress test.
-- CREATE FUNCTION trigger_func() RETURNS trigger LANGUAGE plpgsql AS $$
-- BEGIN
-- 	RAISE NOTICE 'trigger_func(%) called: action = %, when = %, level = %',
-- 		TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
-- 	RETURN NULL;
-- END;$$;
-- CREATE TRIGGER trig_stmt_before BEFORE DELETE OR INSERT OR UPDATE ON rem1
-- 	FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func();
-- CREATE TRIGGER trig_stmt_after AFTER DELETE OR INSERT OR UPDATE ON rem1
-- 	FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func();
-- CREATE OR REPLACE FUNCTION trigger_data()  RETURNS trigger
-- LANGUAGE plpgsql AS $$
-- declare
-- 	oldnew text[];
-- 	relid text;
--     argstr text;
-- begin
-- 	relid := TG_relid::regclass;
-- 	argstr := '';
-- 	for i in 0 .. TG_nargs - 1 loop
-- 		if i > 0 then
-- 			argstr := argstr || ', ';
-- 		end if;
-- 		argstr := argstr || TG_argv[i];
-- 	end loop;
--     RAISE NOTICE '%(%) % % % ON %',
-- 		tg_name, argstr, TG_when, TG_level, TG_OP, relid;
--     oldnew := '{}'::text[];
-- 	if TG_OP != 'INSERT' then
-- 		oldnew := array_append(oldnew, format('OLD: %s', OLD));
-- 	end if;
-- 	if TG_OP != 'DELETE' then
-- 		oldnew := array_append(oldnew, format('NEW: %s', NEW));
-- 	end if;
--     RAISE NOTICE '%', array_to_string(oldnew, ',');
-- 	if TG_OP = 'DELETE' then
-- 		return OLD;
-- 	else
-- 		return NEW;
-- 	end if;
-- end;
-- $$;
-- -- Test basic functionality
-- CREATE TRIGGER trig_row_before
-- BEFORE INSERT OR UPDATE OR DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- CREATE TRIGGER trig_row_after
-- AFTER INSERT OR UPDATE OR DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- delete from rem1;
-- insert into rem1 values(1,'insert');
-- update rem1 set f2  = 'update' where f1 = 1;
-- update rem1 set f2 = f2 || f2;
-- -- cleanup
-- DROP TRIGGER trig_row_before ON rem1;
-- DROP TRIGGER trig_row_after ON rem1;
-- DROP TRIGGER trig_stmt_before ON rem1;
-- DROP TRIGGER trig_stmt_after ON rem1;
-- DELETE from rem1;
-- Test multiple AFTER ROW triggers on a foreign table
-- CREATE TRIGGER trig_row_after1
-- AFTER INSERT OR UPDATE OR DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- CREATE TRIGGER trig_row_after2
-- AFTER INSERT OR UPDATE OR DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- insert into rem1 values(1,'insert');
-- update rem1 set f2  = 'update' where f1 = 1;
-- update rem1 set f2 = f2 || f2;
-- delete from rem1;
-- -- cleanup
-- DROP TRIGGER trig_row_after1 ON rem1;
-- DROP TRIGGER trig_row_after2 ON rem1;
-- -- Test WHEN conditions
-- CREATE TRIGGER trig_row_before_insupd
-- BEFORE INSERT OR UPDATE ON rem1
-- FOR EACH ROW
-- WHEN (NEW.f2 like '%update%')
-- EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- CREATE TRIGGER trig_row_after_insupd
-- AFTER INSERT OR UPDATE ON rem1
-- FOR EACH ROW
-- WHEN (NEW.f2 like '%update%')
-- EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- -- Insert or update not matching: nothing happens
-- INSERT INTO rem1 values(1, 'insert');
-- UPDATE rem1 set f2 = 'test';
-- -- Insert or update matching: triggers are fired
-- INSERT INTO rem1 values(2, 'update');
-- UPDATE rem1 set f2 = 'update update' where f1 = '2';
-- CREATE TRIGGER trig_row_before_delete
-- BEFORE DELETE ON rem1
-- FOR EACH ROW
-- WHEN (OLD.f2 like '%update%')
-- EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- CREATE TRIGGER trig_row_after_delete
-- AFTER DELETE ON rem1
-- FOR EACH ROW
-- WHEN (OLD.f2 like '%update%')
-- EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- -- Trigger is fired for f1=2, not for f1=1
-- DELETE FROM rem1;
-- -- cleanup
-- DROP TRIGGER trig_row_before_insupd ON rem1;
-- DROP TRIGGER trig_row_after_insupd ON rem1;
-- DROP TRIGGER trig_row_before_delete ON rem1;
-- DROP TRIGGER trig_row_after_delete ON rem1;
-- -- Test various RETURN statements in BEFORE triggers.
-- CREATE FUNCTION trig_row_before_insupdate() RETURNS TRIGGER AS $$
--   BEGIN
--     NEW.f2 := NEW.f2 || ' triggered !';
--     RETURN NEW;
--   END
-- $$ language plpgsql;
-- CREATE TRIGGER trig_row_before_insupd
-- BEFORE INSERT OR UPDATE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trig_row_before_insupdate();
-- -- The new values should have 'triggered' appended
-- INSERT INTO rem1 values(1, 'insert');
-- SELECT * from loc1;
-- INSERT INTO rem1 values(2, 'insert') RETURNING f2;
-- SELECT * from loc1;
-- UPDATE rem1 set f2 = '';
-- SELECT * from loc1;
-- UPDATE rem1 set f2 = 'skidoo' RETURNING f2;
-- SELECT * from loc1;
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f1 = 10;          -- all columns should be transmitted
-- UPDATE rem1 set f1 = 10;
-- SELECT * from loc1;
-- DELETE FROM rem1;
-- -- Add a second trigger, to check that the changes are propagated correctly
-- -- from trigger to trigger
-- CREATE TRIGGER trig_row_before_insupd2
-- BEFORE INSERT OR UPDATE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trig_row_before_insupdate();
-- INSERT INTO rem1 values(1, 'insert');
-- SELECT * from loc1;
-- INSERT INTO rem1 values(2, 'insert') RETURNING f2;
-- SELECT * from loc1;
-- UPDATE rem1 set f2 = '';
-- SELECT * from loc1;
-- UPDATE rem1 set f2 = 'skidoo' RETURNING f2;
-- SELECT * from loc1;
-- DROP TRIGGER trig_row_before_insupd ON rem1;
-- DROP TRIGGER trig_row_before_insupd2 ON rem1;
-- DELETE from rem1;
-- INSERT INTO rem1 VALUES (1, 'test');
-- -- Test with a trigger returning NULL
-- CREATE FUNCTION trig_null() RETURNS TRIGGER AS $$
--   BEGIN
--     RETURN NULL;
--   END
-- $$ language plpgsql;
-- CREATE TRIGGER trig_null
-- BEFORE INSERT OR UPDATE OR DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trig_null();
-- -- Nothing should have changed.
-- INSERT INTO rem1 VALUES (2, 'test2');
-- SELECT * from loc1;
-- UPDATE rem1 SET f2 = 'test2';
-- SELECT * from loc1;
-- DELETE from rem1;
-- SELECT * from loc1;
-- DROP TRIGGER trig_null ON rem1;
-- DELETE from rem1;
-- -- Test a combination of local and remote triggers
-- CREATE TRIGGER trig_row_before
-- BEFORE INSERT OR UPDATE OR DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- CREATE TRIGGER trig_row_after
-- AFTER INSERT OR UPDATE OR DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- CREATE TRIGGER trig_local_before BEFORE INSERT OR UPDATE ON loc1
-- FOR EACH ROW EXECUTE PROCEDURE trig_row_before_insupdate();
-- INSERT INTO rem1(f2) VALUES ('test');
-- UPDATE rem1 SET f2 = 'testo';
-- -- Test returning a system attribute
-- INSERT INTO rem1(f2) VALUES ('test') RETURNING ctid;
-- -- cleanup
-- DROP TRIGGER trig_row_before ON rem1;
-- DROP TRIGGER trig_row_after ON rem1;
-- DROP TRIGGER trig_local_before ON loc1;
-- -- Test direct foreign table modification functionality
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1 WHERE false;     -- currently can't be pushed down
-- -- Test with statement-level triggers
-- CREATE TRIGGER trig_stmt_before
-- 	BEFORE DELETE OR INSERT OR UPDATE ON rem1
-- 	FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func();
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f2 = '';          -- can be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can be pushed down
-- DROP TRIGGER trig_stmt_before ON rem1;
-- CREATE TRIGGER trig_stmt_after
-- 	AFTER DELETE OR INSERT OR UPDATE ON rem1
-- 	FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func();
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f2 = '';          -- can be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can be pushed down
-- DROP TRIGGER trig_stmt_after ON rem1;
-- -- Test with row-level ON INSERT triggers
-- CREATE TRIGGER trig_row_before_insert
-- BEFORE INSERT ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f2 = '';          -- can be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can be pushed down
-- DROP TRIGGER trig_row_before_insert ON rem1;
-- CREATE TRIGGER trig_row_after_insert
-- AFTER INSERT ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f2 = '';          -- can be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can be pushed down
-- DROP TRIGGER trig_row_after_insert ON rem1;
-- -- Test with row-level ON UPDATE triggers
-- CREATE TRIGGER trig_row_before_update
-- BEFORE UPDATE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f2 = '';          -- can't be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can be pushed down
-- DROP TRIGGER trig_row_before_update ON rem1;
-- CREATE TRIGGER trig_row_after_update
-- AFTER UPDATE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f2 = '';          -- can't be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can be pushed down
-- DROP TRIGGER trig_row_after_update ON rem1;
-- -- Test with row-level ON DELETE triggers
-- CREATE TRIGGER trig_row_before_delete
-- BEFORE DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f2 = '';          -- can be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can't be pushed down
-- DROP TRIGGER trig_row_before_delete ON rem1;
-- CREATE TRIGGER trig_row_after_delete
-- AFTER DELETE ON rem1
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- EXPLAIN (verbose, costs off)
-- UPDATE rem1 set f2 = '';          -- can be pushed down
-- EXPLAIN (verbose, costs off)
-- DELETE FROM rem1;                 -- can't be pushed down
-- DROP TRIGGER trig_row_after_delete ON rem1;
-- ===================================================================
-- test inheritance features
-- ===================================================================
-- CREATE TABLE a (aa TEXT);
-- CREATE TABLE loct (aa TEXT, bb TEXT);
-- ALTER TABLE a SET (autovacuum_enabled = 'false');
-- ALTER TABLE loct SET (autovacuum_enabled = 'false');
-- CREATE FOREIGN TABLE b (bb TEXT) INHERITS (a)
--   SERVER loopback OPTIONS (table_name 'loct');
-- INSERT INTO a(aa) VALUES('aaa');
-- INSERT INTO a(aa) VALUES('aaaa');
-- INSERT INTO a(aa) VALUES('aaaaa');
-- INSERT INTO b(aa) VALUES('bbb');
-- INSERT INTO b(aa) VALUES('bbbb');
-- INSERT INTO b(aa) VALUES('bbbbb');
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- UPDATE a SET aa = 'zzzzzz' WHERE aa LIKE 'aaaa%';
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- UPDATE b SET aa = 'new';
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- UPDATE a SET aa = 'newtoo';
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- DELETE FROM a;
-- SELECT tableoid::regclass, * FROM a;
-- SELECT tableoid::regclass, * FROM b;
-- SELECT tableoid::regclass, * FROM ONLY a;
-- DROP TABLE a CASCADE;
-- DROP TABLE loct;
-- Check SELECT FOR UPDATE/SHARE with an inherited source table
-- create table loct1 (f1 int, f2 int, f3 int);
-- create table loct2 (f1 int, f2 int, f3 int);
-- alter table loct1 set (autovacuum_enabled = 'false');
-- alter table loct2 set (autovacuum_enabled = 'false');
-- create table foo (f1 int, f2 int);
-- create foreign table foo2 (f3 int) inherits (foo)
--   server loopback options (table_name 'loct1');
-- create table bar (f1 int, f2 int);
-- create foreign table bar2 (f3 int) inherits (bar)
--   server loopback options (table_name 'loct2');
-- alter table foo set (autovacuum_enabled = 'false');
-- alter table bar set (autovacuum_enabled = 'false');
-- insert into foo values(1,1);
-- insert into foo values(3,3);
-- insert into foo2 values(2,2,2);
-- insert into foo2 values(4,4,4);
-- insert into bar values(1,11);
-- insert into bar values(2,22);
-- insert into bar values(6,66);
-- insert into bar2 values(3,33,33);
-- insert into bar2 values(4,44,44);
-- insert into bar2 values(7,77,77);
-- explain (verbose, costs off)
-- select * from bar where f1 in (select f1 from foo) for update;
-- select * from bar where f1 in (select f1 from foo) for update;
-- explain (verbose, costs off)
-- select * from bar where f1 in (select f1 from foo) for share;
-- select * from bar where f1 in (select f1 from foo) for share;
-- -- Now check SELECT FOR UPDATE/SHARE with an inherited source table,
-- -- where the parent is itself a foreign table
-- create table loct4 (f1 int, f2 int, f3 int);
-- create foreign table foo2child (f3 int) inherits (foo2)
--   server loopback options (table_name 'loct4');
-- explain (verbose, costs off)
-- select * from bar where f1 in (select f1 from foo2) for share;
-- select * from bar where f1 in (select f1 from foo2) for share;
-- drop foreign table foo2child;
-- -- And with a local child relation of the foreign table parent
-- create table foo2child (f3 int) inherits (foo2);
-- explain (verbose, costs off)
-- select * from bar where f1 in (select f1 from foo2) for share;
-- select * from bar where f1 in (select f1 from foo2) for share;
-- drop table foo2child;
-- -- Check UPDATE with inherited target and an inherited source table
-- explain (verbose, costs off)
-- update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
-- update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
-- select tableoid::regclass, * from bar order by 1,2;
-- -- Check UPDATE with inherited target and an appendrel subquery
-- explain (verbose, costs off)
-- update bar set f2 = f2 + 100
-- from
--   ( select f1 from foo union all select f1+3 from foo ) ss
-- where bar.f1 = ss.f1;
-- update bar set f2 = f2 + 100
-- from
--   ( select f1 from foo union all select f1+3 from foo ) ss
-- where bar.f1 = ss.f1;
-- select tableoid::regclass, * from bar order by 1,2;
-- Test forcing the remote server to produce sorted data for a merge join,
-- but the foreign table is an inheritance child.
-- truncate table loct1;
-- truncate table only foo;
-- \set num_rows_foo 2000
-- insert into loct1 select generate_series(0, :num_rows_foo, 2), generate_series(0, :num_rows_foo, 2), generate_series(0, :num_rows_foo, 2);
-- insert into foo select generate_series(1, :num_rows_foo, 2), generate_series(1, :num_rows_foo, 2);
-- SET enable_hashjoin to false;
-- SET enable_nestloop to false;
-- alter foreign table foo2 options (use_remote_estimate 'true');
-- create index i_loct1_f1 on loct1(f1);
-- create index i_foo_f1 on foo(f1);
-- analyze foo;
-- analyze loct1;
-- inner join; expressions in the clauses appear in the equivalence class list
-- explain (verbose, costs off)
-- 	select foo.f1, loct1.f1 from foo join loct1 on (foo.f1 = loct1.f1) order by foo.f2 offset 10 limit 10;
-- select foo.f1, loct1.f1 from foo join loct1 on (foo.f1 = loct1.f1) order by foo.f2 offset 10 limit 10;
-- outer join; expressions in the clauses do not appear in equivalence class
-- list but no output change as compared to the previous query
-- explain (verbose, costs off)
-- 	select foo.f1, loct1.f1 from foo left join loct1 on (foo.f1 = loct1.f1) order by foo.f2 offset 10 limit 10;
-- select foo.f1, loct1.f1 from foo left join loct1 on (foo.f1 = loct1.f1) order by foo.f2 offset 10 limit 10;
-- RESET enable_hashjoin;
-- RESET enable_nestloop;
-- Test that WHERE CURRENT OF is not supported
-- begin;
-- declare c cursor for select * from bar where f1 = 7;
-- fetch from c;
-- update bar set f2 = null where current of c;
-- rollback;
-- explain (verbose, costs off)
-- delete from foo where f1 < 5 returning *;
-- delete from foo where f1 < 5 returning *;
-- explain (verbose, costs off)
-- update bar set f2 = f2 + 100 returning *;
-- update bar set f2 = f2 + 100 returning *;
-- Test that UPDATE/DELETE with inherited target works with row-level triggers
-- CREATE TRIGGER trig_row_before
-- BEFORE UPDATE OR DELETE ON bar2
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- CREATE TRIGGER trig_row_after
-- AFTER UPDATE OR DELETE ON bar2
-- FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
-- explain (verbose, costs off)
-- update bar set f2 = f2 + 100;
-- update bar set f2 = f2 + 100;
-- explain (verbose, costs off)
-- delete from bar where f2 < 400;
-- delete from bar where f2 < 400;
-- cleanup
-- drop table foo cascade;
-- drop table bar cascade;
-- drop table loct1;
-- drop table loct2;
-- Test pushing down UPDATE/DELETE joins to the remote server
-- create table parent (a int, b text);
-- create table loct1 (a int, b text);
-- create table loct2 (a int, b text);
-- create foreign table remt1 (a int, b text)
--   server loopback options (table_name 'loct1');
-- create foreign table remt2 (a int, b text)
--   server loopback options (table_name 'loct2');
-- alter foreign table remt1 inherit parent;
-- insert into remt1 values (1, 'foo');
-- insert into remt1 values (2, 'bar');
-- insert into remt2 values (1, 'foo');
-- insert into remt2 values (2, 'bar');
-- analyze remt1;
-- analyze remt2;
-- explain (verbose, costs off)
-- update parent set b = parent.b || remt2.b from remt2 where parent.a = remt2.a returning *;
-- update parent set b = parent.b || remt2.b from remt2 where parent.a = remt2.a returning *;
-- explain (verbose, costs off)
-- delete from parent using remt2 where parent.a = remt2.a returning parent;
-- delete from parent using remt2 where parent.a = remt2.a returning parent;
-- cleanup
-- drop foreign table remt1;
-- drop foreign table remt2;
-- drop table loct1;
-- drop table loct2;
-- drop table parent;
-- ===================================================================
-- test tuple routing for foreign-table partitions
-- ===================================================================
-- Test insert tuple routing
-- create table itrtest (a int, b text) partition by list (a);
-- create table loct1 (a int check (a in (1)), b text);
-- create foreign table remp1 (a int check (a in (1)), b text) server loopback options (table_name 'loct1');
-- create table loct2 (a int check (a in (2)), b text);
-- create foreign table remp2 (b text, a int check (a in (2))) server loopback options (table_name 'loct2');
-- alter table itrtest attach partition remp1 for values in (1);
-- alter table itrtest attach partition remp2 for values in (2);
-- insert into itrtest values (1, 'foo');
-- insert into itrtest values (1, 'bar') returning *;
-- insert into itrtest values (2, 'baz');
-- insert into itrtest values (2, 'qux') returning *;
-- insert into itrtest values (1, 'test1'), (2, 'test2') returning *;
-- select tableoid::regclass, * FROM itrtest;
-- select tableoid::regclass, * FROM remp1;
-- select tableoid::regclass, * FROM remp2;
-- delete from itrtest;
-- create unique index loct1_idx on loct1 (a);
-- DO NOTHING without an inference specification is supported
-- insert into itrtest values (1, 'foo') on conflict do nothing returning *;
-- insert into itrtest values (1, 'foo') on conflict do nothing returning *;
-- But other cases are not supported
-- insert into itrtest values (1, 'bar') on conflict (a) do nothing;
-- insert into itrtest values (1, 'bar') on conflict (a) do update set b = excluded.b;
-- select tableoid::regclass, * FROM itrtest;
-- delete from itrtest;
-- drop index loct1_idx;
-- Test that remote triggers work with insert tuple routing
-- create function br_insert_trigfunc() returns trigger as $$
-- begin
-- 	new.b := new.b || ' triggered !';
-- 	return new;
-- end
-- $$ language plpgsql;
-- create trigger loct1_br_insert_trigger before insert on loct1
-- 	for each row execute procedure br_insert_trigfunc();
-- create trigger loct2_br_insert_trigger before insert on loct2
-- 	for each row execute procedure br_insert_trigfunc();
-- The new values are concatenated with ' triggered !'
-- insert into itrtest values (1, 'foo') returning *;
-- insert into itrtest values (2, 'qux') returning *;
-- insert into itrtest values (1, 'test1'), (2, 'test2') returning *;
-- with result as (insert into itrtest values (1, 'test1'), (2, 'test2') returning *) select * from result;
-- drop trigger loct1_br_insert_trigger on loct1;
-- drop trigger loct2_br_insert_trigger on loct2;
-- drop table itrtest;
-- drop table loct1;
-- drop table loct2;
-- Test update tuple routing
-- create table utrtest (a int, b text) partition by list (a);
-- create table loct (a int check (a in (1)), b text);
-- create foreign table remp (a int check (a in (1)), b text) server loopback options (table_name 'loct');
-- create table locp (a int check (a in (2)), b text);
-- alter table utrtest attach partition remp for values in (1);
-- alter table utrtest attach partition locp for values in (2);
-- insert into utrtest values (1, 'foo');
-- insert into utrtest values (2, 'qux');
-- select tableoid::regclass, * FROM utrtest;
-- select tableoid::regclass, * FROM remp;
-- select tableoid::regclass, * FROM locp;
-- It's not allowed to move a row from a partition that is foreign to another
-- update utrtest set a = 2 where b = 'foo' returning *;
-- But the reverse is allowed
-- update utrtest set a = 1 where b = 'qux' returning *;
-- select tableoid::regclass, * FROM utrtest;
-- select tableoid::regclass, * FROM remp;
-- select tableoid::regclass, * FROM locp;
-- The executor should not let unexercised FDWs shut down
-- update utrtest set a = 1 where b = 'foo';
-- Test that remote triggers work with update tuple routing
-- create trigger loct_br_insert_trigger before insert on loct
-- 	for each row execute procedure br_insert_trigfunc();
-- delete from utrtest;
-- insert into utrtest values (2, 'qux');
-- Check case where the foreign partition is a subplan target rel
-- explain (verbose, costs off)
-- update utrtest set a = 1 where a = 1 or a = 2 returning *;
-- The new values are concatenated with ' triggered !'
-- update utrtest set a = 1 where a = 1 or a = 2 returning *;
-- delete from utrtest;
-- insert into utrtest values (2, 'qux');
-- Check case where the foreign partition isn't a subplan target rel
-- explain (verbose, costs off)
-- update utrtest set a = 1 where a = 2 returning *;
-- The new values are concatenated with ' triggered !'
-- update utrtest set a = 1 where a = 2 returning *;
-- drop trigger loct_br_insert_trigger on loct;
-- We can move rows to a foreign partition that has been updated already,
-- but can't move rows to a foreign partition that hasn't been updated yet
-- delete from utrtest;
-- insert into utrtest values (1, 'foo');
-- insert into utrtest values (2, 'qux');
-- Test the former case:
-- with a direct modification plan
-- explain (verbose, costs off)
-- update utrtest set a = 1 returning *;
-- update utrtest set a = 1 returning *;
-- delete from utrtest;
-- insert into utrtest values (1, 'foo');
-- insert into utrtest values (2, 'qux');
-- with a non-direct modification plan
-- explain (verbose, costs off)
-- update utrtest set a = 1 from (values (1), (2)) s(x) where a = s.x returning *;
-- update utrtest set a = 1 from (values (1), (2)) s(x) where a = s.x returning *;
-- Change the definition of utrtest so that the foreign partition get updated
-- after the local partition
-- delete from utrtest;
-- alter table utrtest detach partition remp;
-- drop foreign table remp;
-- alter table loct drop constraint loct_a_check;
-- alter table loct add check (a in (3));
-- create foreign table remp (a int check (a in (3)), b text) server loopback options (table_name 'loct');
-- alter table utrtest attach partition remp for values in (3);
-- insert into utrtest values (2, 'qux');
-- insert into utrtest values (3, 'xyzzy');
-- Test the latter case:
-- with a direct modification plan
-- explain (verbose, costs off)
-- update utrtest set a = 3 returning *;
-- update utrtest set a = 3 returning *; -- ERROR
-- with a non-direct modification plan
-- explain (verbose, costs off)
-- update utrtest set a = 3 from (values (2), (3)) s(x) where a = s.x returning *;
-- update utrtest set a = 3 from (values (2), (3)) s(x) where a = s.x returning *; -- ERROR
-- drop table utrtest;
-- drop table loct;
-- Test copy tuple routing
-- create table ctrtest (a int, b text) partition by list (a);
-- create table loct1 (a int check (a in (1)), b text);
-- create foreign table remp1 (a int check (a in (1)), b text) server loopback options (table_name 'loct1');
-- create table loct2 (a int check (a in (2)), b text);
-- create foreign table remp2 (b text, a int check (a in (2))) server loopback options (table_name 'loct2');
-- alter table ctrtest attach partition remp1 for values in (1);
-- alter table ctrtest attach partition remp2 for values in (2);
-- copy ctrtest from stdin;
-- 1	foo
-- 2	qux
-- \.
-- select tableoid::regclass, * FROM ctrtest;
-- select tableoid::regclass, * FROM remp1;
-- select tableoid::regclass, * FROM remp2;
-- Copying into foreign partitions directly should work as well
-- copy remp1 from stdin;
-- 1	bar
-- \.
-- select tableoid::regclass, * FROM remp1;
-- drop table ctrtest;
-- drop table loct1;
-- drop table loct2;
-- ===================================================================
-- test COPY FROM
-- ===================================================================
-- create table loc2 (f1 int, f2 text);
-- alter table loc2 set (autovacuum_enabled = 'false');
-- create foreign table rem2 (f1 int, f2 text) server loopback options(table_name 'loc2');
-- Test basic functionality
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- delete from rem2;
-- Test check constraints
-- alter table loc2 add constraint loc2_f1positive check (f1 >= 0);
-- alter foreign table rem2 add constraint rem2_f1positive check (f1 >= 0);
-- check constraint is enforced on the remote side, not locally
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- copy rem2 from stdin; -- ERROR
-- -1	xyzzy
-- \.
-- select * from rem2;
-- alter foreign table rem2 drop constraint rem2_f1positive;
-- alter table loc2 drop constraint loc2_f1positive;
-- delete from rem2;
-- Test local triggers
-- create trigger trig_stmt_before before insert on rem2
-- 	for each statement execute procedure trigger_func();
-- create trigger trig_stmt_after after insert on rem2
-- 	for each statement execute procedure trigger_func();
-- create trigger trig_row_before before insert on rem2
-- 	for each row execute procedure trigger_data(23,'skidoo');
-- create trigger trig_row_after after insert on rem2
-- 	for each row execute procedure trigger_data(23,'skidoo');
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_row_before on rem2;
-- drop trigger trig_row_after on rem2;
-- drop trigger trig_stmt_before on rem2;
-- drop trigger trig_stmt_after on rem2;
-- delete from rem2;
-- create trigger trig_row_before_insert before insert on rem2
-- 	for each row execute procedure trig_row_before_insupdate();
-- The new values are concatenated with ' triggered !'
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_row_before_insert on rem2;
-- delete from rem2;
-- create trigger trig_null before insert on rem2
-- 	for each row execute procedure trig_null();
-- Nothing happens
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_null on rem2;
-- delete from rem2;
-- Test remote triggers
-- create trigger trig_row_before_insert before insert on loc2
-- 	for each row execute procedure trig_row_before_insupdate();
-- The new values are concatenated with ' triggered !'
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_row_before_insert on loc2;
-- delete from rem2;
-- create trigger trig_null before insert on loc2
-- 	for each row execute procedure trig_null();
-- Nothing happens
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger trig_null on loc2;
-- delete from rem2;
-- Test a combination of local and remote triggers
-- create trigger rem2_trig_row_before before insert on rem2
-- 	for each row execute procedure trigger_data(23,'skidoo');
-- create trigger rem2_trig_row_after after insert on rem2
-- 	for each row execute procedure trigger_data(23,'skidoo');
-- create trigger loc2_trig_row_before_insert before insert on loc2
-- 	for each row execute procedure trig_row_before_insupdate();
-- copy rem2 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- select * from rem2;
-- drop trigger rem2_trig_row_before on rem2;
-- drop trigger rem2_trig_row_after on rem2;
-- drop trigger loc2_trig_row_before_insert on loc2;
-- delete from rem2;
-- test COPY FROM with foreign table created in the same transaction
-- create table loc3 (f1 int, f2 text);
-- begin;
-- create foreign table rem3 (f1 int, f2 text)
-- 	server loopback options(table_name 'loc3');
-- copy rem3 from stdin;
-- 1	foo
-- 2	bar
-- \.
-- commit;
-- select * from rem3;
-- drop foreign table rem3;
-- drop table loc3;
-- ===================================================================
-- test for TRUNCATE
-- ===================================================================
-- CREATE TABLE tru_rtable0 (id int primary key);
-- CREATE FOREIGN TABLE tru_ftable (id int)
--        SERVER loopback OPTIONS (table_name 'tru_rtable0');
-- INSERT INTO tru_rtable0 (SELECT x FROM generate_series(1,10) x);
-- CREATE TABLE tru_ptable (id int) PARTITION BY HASH(id);
-- CREATE TABLE tru_ptable__p0 PARTITION OF tru_ptable
--                             FOR VALUES WITH (MODULUS 2, REMAINDER 0);
-- CREATE TABLE tru_rtable1 (id int primary key);
-- CREATE FOREIGN TABLE tru_ftable__p1 PARTITION OF tru_ptable
--                                     FOR VALUES WITH (MODULUS 2, REMAINDER 1)
--        SERVER loopback OPTIONS (table_name 'tru_rtable1');
-- INSERT INTO tru_ptable (SELECT x FROM generate_series(11,20) x);
-- CREATE TABLE tru_pk_table(id int primary key);
-- CREATE TABLE tru_fk_table(fkey int references tru_pk_table(id));
-- INSERT INTO tru_pk_table (SELECT x FROM generate_series(1,10) x);
-- INSERT INTO tru_fk_table (SELECT x % 10 + 1 FROM generate_series(5,25) x);
-- CREATE FOREIGN TABLE tru_pk_ftable (id int)
--        SERVER loopback OPTIONS (table_name 'tru_pk_table');
-- CREATE TABLE tru_rtable_parent (id int);
-- CREATE TABLE tru_rtable_child (id int);
-- CREATE FOREIGN TABLE tru_ftable_parent (id int)
--        SERVER loopback OPTIONS (table_name 'tru_rtable_parent');
-- CREATE FOREIGN TABLE tru_ftable_child () INHERITS (tru_ftable_parent)
--        SERVER loopback OPTIONS (table_name 'tru_rtable_child');
-- INSERT INTO tru_rtable_parent (SELECT x FROM generate_series(1,8) x);
-- INSERT INTO tru_rtable_child  (SELECT x FROM generate_series(10, 18) x);
-- normal truncate
-- SELECT sum(id) FROM tru_ftable;        -- 55
-- TRUNCATE tru_ftable;
-- SELECT count(*) FROM tru_rtable0;		-- 0
-- SELECT count(*) FROM tru_ftable;		-- 0
-- 'truncatable' option
-- ALTER SERVER loopback OPTIONS (ADD truncatable 'false');
-- TRUNCATE tru_ftable;			-- error
-- ALTER FOREIGN TABLE tru_ftable OPTIONS (ADD truncatable 'true');
-- TRUNCATE tru_ftable;			-- accepted
-- ALTER FOREIGN TABLE tru_ftable OPTIONS (SET truncatable 'false');
-- TRUNCATE tru_ftable;			-- error
-- ALTER SERVER loopback OPTIONS (DROP truncatable);
-- ALTER FOREIGN TABLE tru_ftable OPTIONS (SET truncatable 'false');
-- TRUNCATE tru_ftable;			-- error
-- ALTER FOREIGN TABLE tru_ftable OPTIONS (SET truncatable 'true');
-- TRUNCATE tru_ftable;			-- accepted
-- partitioned table with both local and foreign tables as partitions
-- SELECT sum(id) FROM tru_ptable;        -- 155
-- TRUNCATE tru_ptable;
-- SELECT count(*) FROM tru_ptable;		-- 0
-- SELECT count(*) FROM tru_ptable__p0;	-- 0
-- SELECT count(*) FROM tru_ftable__p1;	-- 0
-- SELECT count(*) FROM tru_rtable1;		-- 0
-- 'CASCADE' option
-- SELECT sum(id) FROM tru_pk_ftable;      -- 55
-- TRUNCATE tru_pk_ftable;	-- failed by FK reference
-- TRUNCATE tru_pk_ftable CASCADE;
-- SELECT count(*) FROM tru_pk_ftable;    -- 0
-- SELECT count(*) FROM tru_fk_table;		-- also truncated,0
-- truncate two tables at a command
-- INSERT INTO tru_ftable (SELECT x FROM generate_series(1,8) x);
-- INSERT INTO tru_pk_ftable (SELECT x FROM generate_series(3,10) x);
-- SELECT count(*) from tru_ftable; -- 8
-- SELECT count(*) from tru_pk_ftable; -- 8
-- TRUNCATE tru_ftable, tru_pk_ftable CASCADE;
-- SELECT count(*) from tru_ftable; -- 0
-- SELECT count(*) from tru_pk_ftable; -- 0
-- truncate with ONLY clause
-- Since ONLY is specified, the table tru_ftable_child that inherits
-- tru_ftable_parent locally is not truncated.
-- TRUNCATE ONLY tru_ftable_parent;
-- SELECT sum(id) FROM tru_ftable_parent;  -- 126
-- TRUNCATE tru_ftable_parent;
-- SELECT count(*) FROM tru_ftable_parent; -- 0
-- in case when remote table has inherited children
-- CREATE TABLE tru_rtable0_child () INHERITS (tru_rtable0);
-- INSERT INTO tru_rtable0 (SELECT x FROM generate_series(5,9) x);
-- INSERT INTO tru_rtable0_child (SELECT x FROM generate_series(10,14) x);
-- SELECT sum(id) FROM tru_ftable;   -- 95
-- Both parent and child tables in the foreign server are truncated
-- even though ONLY is specified because ONLY has no effect
-- when truncating a foreign table.
-- TRUNCATE ONLY tru_ftable;
-- SELECT count(*) FROM tru_ftable;   -- 0
-- INSERT INTO tru_rtable0 (SELECT x FROM generate_series(21,25) x);
-- INSERT INTO tru_rtable0_child (SELECT x FROM generate_series(26,30) x);
-- SELECT sum(id) FROM tru_ftable;		-- 255
-- TRUNCATE tru_ftable;			-- truncate both of parent and child
-- SELECT count(*) FROM tru_ftable;    -- 0
-- cleanup
-- DROP FOREIGN TABLE tru_ftable_parent, tru_ftable_child, tru_pk_ftable,tru_ftable__p1,tru_ftable;
-- DROP TABLE tru_rtable0, tru_rtable1, tru_ptable, tru_ptable__p0, tru_pk_table, tru_fk_table,
-- tru_rtable_parent,tru_rtable_child, tru_rtable0_child;
-- ===================================================================
-- test IMPORT FOREIGN SCHEMA
-- ===================================================================
\set var '\"':PATH_FILENAME'\/ported_postgres\"'
--Testcase 402:
CREATE SCHEMA import_dest1;
IMPORT FOREIGN SCHEMA :var FROM SERVER parquet_s3_srv INTO import_dest1 OPTIONS (sorted 'c1', schemaless 'true');
--Testcase 403:
\det+ import_dest1.*
                                                                   List of foreign tables
    Schema    |   Table    |     Server     |                                           FDW options                                           | Description 
--------------+------------+----------------+-------------------------------------------------------------------------------------------------+-------------
 import_dest1 | T0         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T0.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | T1         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T1.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | T2         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T2.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | T3         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T3.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | T4         | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/T4.parquet', sorted 'c1', schemaless 'true')         | 
 import_dest1 | base_tbl   | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/base_tbl.parquet', sorted 'c1', schemaless 'true')   | 
 import_dest1 | child_tbl  | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/child_tbl.parquet', sorted 'c1', schemaless 'true')  | 
 import_dest1 | ft1        | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/ft1.parquet', sorted 'c1', schemaless 'true')        | 
 import_dest1 | ft1_null   | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/ft1_null.parquet', sorted 'c1', schemaless 'true')   | 
 import_dest1 | loc1       | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loc1.parquet', sorted 'c1', schemaless 'true')       | 
 import_dest1 | local_tbl  | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/local_tbl.parquet', sorted 'c1', schemaless 'true')  | 
 import_dest1 | loct3      | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct3.parquet', sorted 'c1', schemaless 'true')      | 
 import_dest1 | loct_empty | parquet_s3_srv | (filename '/tmp/data_local/ported_postgres/loct_empty.parquet', sorted 'c1', schemaless 'true') | 
(13 rows)

--Testcase 404:
\d import_dest1.*
                Foreign table "import_dest1.T0"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T0.parquet', sorted 'c1', schemaless 'true')

                Foreign table "import_dest1.T1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T1.parquet', sorted 'c1', schemaless 'true')

                Foreign table "import_dest1.T2"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T2.parquet', sorted 'c1', schemaless 'true')

                Foreign table "import_dest1.T3"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T3.parquet', sorted 'c1', schemaless 'true')

                Foreign table "import_dest1.T4"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/T4.parquet', sorted 'c1', schemaless 'true')

             Foreign table "import_dest1.base_tbl"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/base_tbl.parquet', sorted 'c1', schemaless 'true')

            Foreign table "import_dest1.child_tbl"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/child_tbl.parquet', sorted 'c1', schemaless 'true')

               Foreign table "import_dest1.ft1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/ft1.parquet', sorted 'c1', schemaless 'true')

             Foreign table "import_dest1.ft1_null"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/ft1_null.parquet', sorted 'c1', schemaless 'true')

               Foreign table "import_dest1.loc1"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loc1.parquet', sorted 'c1', schemaless 'true')

            Foreign table "import_dest1.local_tbl"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/local_tbl.parquet', sorted 'c1', schemaless 'true')

              Foreign table "import_dest1.loct3"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct3.parquet', sorted 'c1', schemaless 'true')

            Foreign table "import_dest1.loct_empty"
 Column | Type  | Collation | Nullable | Default | FDW options 
--------+-------+-----------+----------+---------+-------------
 v      | jsonb |           |          |         | 
Server: parquet_s3_srv
FDW options: (filename '/tmp/data_local/ported_postgres/loct_empty.parquet', sorted 'c1', schemaless 'true')

-- Options
-- CREATE SCHEMA import_dest2;
-- IMPORT FOREIGN SCHEMA import_source FROM SERVER loopback INTO import_dest2
--   OPTIONS (import_default 'true');
-- \det+ import_dest2.*
-- \d import_dest2.*
-- CREATE SCHEMA import_dest3;
-- IMPORT FOREIGN SCHEMA import_source FROM SERVER loopback INTO import_dest3
--   OPTIONS (import_collate 'false', import_generated 'false', import_not_null 'false');
-- \det+ import_dest3.*
-- \d import_dest3.*
-- Check LIMIT TO and EXCEPT
-- CREATE SCHEMA import_dest4;
-- IMPORT FOREIGN SCHEMA import_source LIMIT TO (t1, nonesuch, t4_part)
--   FROM SERVER loopback INTO import_dest4;
-- \det+ import_dest4.*
-- IMPORT FOREIGN SCHEMA import_source EXCEPT (t1, "x 4", nonesuch, t4_part)
--   FROM SERVER loopback INTO import_dest4;
-- \det+ import_dest4.*
-- Assorted error cases
-- IMPORT FOREIGN SCHEMA import_source FROM SERVER loopback INTO import_dest4;
-- IMPORT FOREIGN SCHEMA nonesuch FROM SERVER loopback INTO import_dest4;
-- IMPORT FOREIGN SCHEMA nonesuch FROM SERVER loopback INTO notthere;
-- IMPORT FOREIGN SCHEMA nonesuch FROM SERVER nowhere INTO notthere;
-- Check case of a type present only on the remote server.
-- We can fake this by dropping the type locally in our transaction.
-- CREATE TYPE "Colors" AS ENUM ('red', 'green', 'blue');
-- CREATE TABLE import_source.t5 (c1 int, c2 text collate "C", "Col" "Colors");
-- CREATE SCHEMA import_dest5;
-- BEGIN;
-- DROP TYPE "Colors" CASCADE;
-- IMPORT FOREIGN SCHEMA import_source LIMIT TO (t5)
--   FROM SERVER loopback INTO import_dest5;  -- ERROR
-- ROLLBACK;
-- BEGIN;
-- CREATE SERVER fetch101 FOREIGN DATA WRAPPER postgres_fdw OPTIONS( fetch_size '101' );
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'fetch101'
-- AND srvoptions @> array['fetch_size=101'];
-- ALTER SERVER fetch101 OPTIONS( SET fetch_size '202' );
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'fetch101'
-- AND srvoptions @> array['fetch_size=101'];
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'fetch101'
-- AND srvoptions @> array['fetch_size=202'];
-- CREATE FOREIGN TABLE table30000 ( x int ) SERVER fetch101 OPTIONS ( fetch_size '30000' );
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30000'::regclass
-- AND ftoptions @> array['fetch_size=30000'];
-- ALTER FOREIGN TABLE table30000 OPTIONS ( SET fetch_size '60000');
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30000'::regclass
-- AND ftoptions @> array['fetch_size=30000'];
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30000'::regclass
-- AND ftoptions @> array['fetch_size=60000'];
-- ROLLBACK;
-- ===================================================================
-- test partitionwise joins
-- ===================================================================
-- SET enable_partitionwise_join=on;
-- CREATE TABLE fprt1 (a int, b int, c varchar) PARTITION BY RANGE(a);
-- CREATE TABLE fprt1_p1 (LIKE fprt1);
-- CREATE TABLE fprt1_p2 (LIKE fprt1);
-- ALTER TABLE fprt1_p1 SET (autovacuum_enabled = 'false');
-- ALTER TABLE fprt1_p2 SET (autovacuum_enabled = 'false');
-- INSERT INTO fprt1_p1 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 249, 2) i;
-- INSERT INTO fprt1_p2 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(250, 499, 2) i;
-- CREATE FOREIGN TABLE ftprt1_p1 PARTITION OF fprt1 FOR VALUES FROM (0) TO (250)
-- 	SERVER loopback OPTIONS (table_name 'fprt1_p1', use_remote_estimate 'true');
-- CREATE FOREIGN TABLE ftprt1_p2 PARTITION OF fprt1 FOR VALUES FROM (250) TO (500)
-- 	SERVER loopback OPTIONS (TABLE_NAME 'fprt1_p2');
-- ANALYZE fprt1;
-- ANALYZE fprt1_p1;
-- ANALYZE fprt1_p2;
-- CREATE TABLE fprt2 (a int, b int, c varchar) PARTITION BY RANGE(b);
-- CREATE TABLE fprt2_p1 (LIKE fprt2);
-- CREATE TABLE fprt2_p2 (LIKE fprt2);
-- ALTER TABLE fprt2_p1 SET (autovacuum_enabled = 'false');
-- ALTER TABLE fprt2_p2 SET (autovacuum_enabled = 'false');
-- INSERT INTO fprt2_p1 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(0, 249, 3) i;
-- INSERT INTO fprt2_p2 SELECT i, i, to_char(i/50, 'FM0000') FROM generate_series(250, 499, 3) i;
-- CREATE FOREIGN TABLE ftprt2_p1 (b int, c varchar, a int)
-- 	SERVER loopback OPTIONS (table_name 'fprt2_p1', use_remote_estimate 'true');
-- ALTER TABLE fprt2 ATTACH PARTITION ftprt2_p1 FOR VALUES FROM (0) TO (250);
-- CREATE FOREIGN TABLE ftprt2_p2 PARTITION OF fprt2 FOR VALUES FROM (250) TO (500)
-- 	SERVER loopback OPTIONS (table_name 'fprt2_p2', use_remote_estimate 'true');
-- ANALYZE fprt2;
-- ANALYZE fprt2_p1;
-- ANALYZE fprt2_p2;
-- inner join three tables
-- EXPLAIN (COSTS OFF)
-- SELECT t1.a,t2.b,t3.c FROM fprt1 t1 INNER JOIN fprt2 t2 ON (t1.a = t2.b) INNER JOIN fprt1 t3 ON (t2.b = t3.a) WHERE t1.a % 25 =0 ORDER BY 1,2,3;
-- SELECT t1.a,t2.b,t3.c FROM fprt1 t1 INNER JOIN fprt2 t2 ON (t1.a = t2.b) INNER JOIN fprt1 t3 ON (t2.b = t3.a) WHERE t1.a % 25 =0 ORDER BY 1,2,3;
-- left outer join + nullable clause
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT t1.a,t2.b,t2.c FROM fprt1 t1 LEFT JOIN (SELECT * FROM fprt2 WHERE a < 10) t2 ON (t1.a = t2.b and t1.b = t2.a) WHERE t1.a < 10 ORDER BY 1,2,3;
-- SELECT t1.a,t2.b,t2.c FROM fprt1 t1 LEFT JOIN (SELECT * FROM fprt2 WHERE a < 10) t2 ON (t1.a = t2.b and t1.b = t2.a) WHERE t1.a < 10 ORDER BY 1,2,3;
-- with whole-row reference; partitionwise join does not apply
-- EXPLAIN (COSTS OFF)
-- SELECT t1.wr, t2.wr FROM (SELECT t1 wr, a FROM fprt1 t1 WHERE t1.a % 25 = 0) t1 FULL JOIN (SELECT t2 wr, b FROM fprt2 t2 WHERE t2.b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY 1,2;
-- SELECT t1.wr, t2.wr FROM (SELECT t1 wr, a FROM fprt1 t1 WHERE t1.a % 25 = 0) t1 FULL JOIN (SELECT t2 wr, b FROM fprt2 t2 WHERE t2.b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY 1,2;
-- join with lateral reference
-- EXPLAIN (COSTS OFF)
-- SELECT t1.a,t1.b FROM fprt1 t1, LATERAL (SELECT t2.a, t2.b FROM fprt2 t2 WHERE t1.a = t2.b AND t1.b = t2.a) q WHERE t1.a%25 = 0 ORDER BY 1,2;
-- SELECT t1.a,t1.b FROM fprt1 t1, LATERAL (SELECT t2.a, t2.b FROM fprt2 t2 WHERE t1.a = t2.b AND t1.b = t2.a) q WHERE t1.a%25 = 0 ORDER BY 1,2;
-- with PHVs, partitionwise join selected but no join pushdown
-- EXPLAIN (COSTS OFF)
-- SELECT t1.a, t1.phv, t2.b, t2.phv FROM (SELECT 't1_phv' phv, * FROM fprt1 WHERE a % 25 = 0) t1 FULL JOIN (SELECT 't2_phv' phv, * FROM fprt2 WHERE b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY t1.a, t2.b;
-- SELECT t1.a, t1.phv, t2.b, t2.phv FROM (SELECT 't1_phv' phv, * FROM fprt1 WHERE a % 25 = 0) t1 FULL JOIN (SELECT 't2_phv' phv, * FROM fprt2 WHERE b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY t1.a, t2.b;
-- test FOR UPDATE; partitionwise join does not apply
-- EXPLAIN (COSTS OFF)
-- SELECT t1.a, t2.b FROM fprt1 t1 INNER JOIN fprt2 t2 ON (t1.a = t2.b) WHERE t1.a % 25 = 0 ORDER BY 1,2 FOR UPDATE OF t1;
-- SELECT t1.a, t2.b FROM fprt1 t1 INNER JOIN fprt2 t2 ON (t1.a = t2.b) WHERE t1.a % 25 = 0 ORDER BY 1,2 FOR UPDATE OF t1;
-- RESET enable_partitionwise_join;
-- ===================================================================
-- test partitionwise aggregates
-- ===================================================================
-- CREATE TABLE pagg_tab (a int, b int, c text) PARTITION BY RANGE(a);
-- CREATE TABLE pagg_tab_p1 (LIKE pagg_tab);
-- CREATE TABLE pagg_tab_p2 (LIKE pagg_tab);
-- CREATE TABLE pagg_tab_p3 (LIKE pagg_tab);
-- INSERT INTO pagg_tab_p1 SELECT i % 30, i % 50, to_char(i/30, 'FM0000') FROM generate_series(1, 3000) i WHERE (i % 30) < 10;
-- INSERT INTO pagg_tab_p2 SELECT i % 30, i % 50, to_char(i/30, 'FM0000') FROM generate_series(1, 3000) i WHERE (i % 30) < 20 and (i % 30) >= 10;
-- INSERT INTO pagg_tab_p3 SELECT i % 30, i % 50, to_char(i/30, 'FM0000') FROM generate_series(1, 3000) i WHERE (i % 30) < 30 and (i % 30) >= 20;
-- Create foreign partitions
-- CREATE FOREIGN TABLE fpagg_tab_p1 PARTITION OF pagg_tab FOR VALUES FROM (0) TO (10) SERVER loopback OPTIONS (table_name 'pagg_tab_p1');
-- CREATE FOREIGN TABLE fpagg_tab_p2 PARTITION OF pagg_tab FOR VALUES FROM (10) TO (20) SERVER loopback OPTIONS (table_name 'pagg_tab_p2');
-- CREATE FOREIGN TABLE fpagg_tab_p3 PARTITION OF pagg_tab FOR VALUES FROM (20) TO (30) SERVER loopback OPTIONS (table_name 'pagg_tab_p3');
-- ANALYZE pagg_tab;
-- ANALYZE fpagg_tab_p1;
-- ANALYZE fpagg_tab_p2;
-- ANALYZE fpagg_tab_p3;
-- When GROUP BY clause matches with PARTITION KEY.
-- Plan with partitionwise aggregates is disabled
-- SET enable_partitionwise_aggregate TO false;
-- EXPLAIN (COSTS OFF)
-- SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- Plan with partitionwise aggregates is enabled
-- SET enable_partitionwise_aggregate TO true;
-- EXPLAIN (COSTS OFF)
-- SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- Check with whole-row reference
-- Should have all the columns in the target list for the given relation
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT a, count(t1) FROM pagg_tab t1 GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- SELECT a, count(t1) FROM pagg_tab t1 GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-- When GROUP BY clause does not match with PARTITION KEY.
-- EXPLAIN (COSTS OFF)
-- SELECT b, avg(a), max(a), count(*) FROM pagg_tab GROUP BY b HAVING sum(a) < 700 ORDER BY 1;
-- ===================================================================
-- access rights and superuser
-- ===================================================================
-- Non-superuser cannot create a FDW without a password in the connstr
-- CREATE ROLE regress_nosuper NOSUPERUSER;
-- GRANT USAGE ON FOREIGN DATA WRAPPER postgres_fdw TO regress_nosuper;
-- SET ROLE regress_nosuper;
-- SHOW is_superuser;
-- This will be OK, we can create the FDW
-- DO $d$
--     BEGIN
--         EXECUTE $$CREATE SERVER loopback_nopw FOREIGN DATA WRAPPER postgres_fdw
--             OPTIONS (dbname '$$||current_database()||$$',
--                      port '$$||current_setting('port')||$$'
--             )$$;
--     END;
-- $d$;
-- But creation of user mappings for non-superusers should fail
-- CREATE USER MAPPING FOR public SERVER loopback_nopw;
-- CREATE USER MAPPING FOR CURRENT_USER SERVER loopback_nopw;
-- CREATE FOREIGN TABLE ft1_nopw (
-- 	c1 int NOT NULL,
-- 	c2 int NOT NULL,
-- 	c3 text,
-- 	c4 timestamptz,
-- 	c5 timestamp,
-- 	c6 varchar(10),
-- 	c7 char(10) default 'ft1',
-- 	c8 user_enum
-- ) SERVER loopback_nopw OPTIONS (schema_name 'public', table_name 'ft1');
-- SELECT 1 FROM ft1_nopw LIMIT 1;
-- If we add a password to the connstr it'll fail, because we don't allow passwords
-- in connstrs only in user mappings.
-- DO $d$
--     BEGIN
--         EXECUTE $$ALTER SERVER loopback_nopw OPTIONS (ADD password 'dummypw')$$;
--     END;
-- $d$;
-- If we add a password for our user mapping instead, we should get a different
-- error because the password wasn't actually *used* when we run with trust auth.
--
-- This won't work with installcheck, but neither will most of the FDW checks.
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (ADD password 'dummypw');
-- SELECT 1 FROM ft1_nopw LIMIT 1;
-- Unpriv user cannot make the mapping passwordless
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (ADD password_required 'false');
-- SELECT 1 FROM ft1_nopw LIMIT 1;
-- RESET ROLE;
-- But the superuser can
-- ALTER USER MAPPING FOR regress_nosuper SERVER loopback_nopw OPTIONS (ADD password_required 'false');
-- SET ROLE regress_nosuper;
-- Should finally work now
-- SELECT 1 FROM ft1_nopw LIMIT 1;
-- unpriv user also cannot set sslcert / sslkey on the user mapping
-- first set password_required so we see the right error messages
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (SET password_required 'true');
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (ADD sslcert 'foo.crt');
-- ALTER USER MAPPING FOR CURRENT_USER SERVER loopback_nopw OPTIONS (ADD sslkey 'foo.key');
-- We're done with the role named after a specific user and need to check the
-- changes to the public mapping.
-- DROP USER MAPPING FOR CURRENT_USER SERVER loopback_nopw;
-- This will fail again as it'll resolve the user mapping for public, which
-- lacks password_required=false
-- SELECT * FROM ft1_nopw LIMIT 1;
-- RESET ROLE;
-- The user mapping for public is passwordless and lacks the password_required=false
-- mapping option, but will work because the current user is a superuser.
-- SELECT * FROM ft1_nopw LIMIT 1;
-- cleanup
-- DROP USER MAPPING FOR public SERVER loopback_nopw;
-- DROP OWNED BY regress_nosuper;
-- DROP ROLE regress_nosuper;
-- Clean-up
-- RESET enable_partitionwise_aggregate;
-- Two-phase transactions are not supported.
-- BEGIN;
-- SELECT count(*) FROM ft1;
-- error here
-- PREPARE TRANSACTION 'fdw_tpc';
-- ROLLBACK;
-- ===================================================================
-- reestablish new connection
-- ===================================================================
-- Change application_name of remote connection to special one
-- so that we can easily terminate the connection later.
-- ALTER SERVER parquet_s3_srv OPTIONS (application_name 'fdw_retry_check');
-- If debug_discard_caches is active, it results in
-- dropping remote connections after every transaction, making it
-- impossible to test termination meaningfully.  So turn that off
-- for this test.
-- SET debug_discard_caches = 0;
-- Make sure we have a remote connection.
-- SELECT 1 FROM ft1 LIMIT 1;
-- Terminate the remote connection and wait for the termination to complete.
-- SELECT pg_terminate_backend(pid, 180000) FROM pg_stat_activity
-- 	WHERE application_name = 'fdw_retry_check';
-- This query should detect the broken connection when starting new remote
-- transaction, reestablish new connection, and then succeed.
-- BEGIN;
-- SELECT 1 FROM ft1 LIMIT 1;
-- If we detect the broken connection when starting a new remote
-- subtransaction, we should fail instead of establishing a new connection.
-- Terminate the remote connection and wait for the termination to complete.
-- SELECT pg_terminate_backend(pid, 180000) FROM pg_stat_activity
-- 	WHERE application_name = 'fdw_retry_check';
-- SAVEPOINT s;
-- The text of the error might vary across platforms, so only show SQLSTATE.
-- \set VERBOSITY sqlstate
-- SELECT 1 FROM ft1 LIMIT 1;    -- should fail
-- \set VERBOSITY default
-- COMMIT;
-- RESET debug_discard_caches;
-- =============================================================================
-- test connection invalidation cases and parquet_s3_fdw_get_connections function
-- with local parquet file (not on minio/s3 servers). It haven't server and connection.
-- =============================================================================
-- Let's ensure to close all the existing cached connections.
--Testcase 405:
SELECT 1 FROM parquet_s3_fdw_disconnect_all();
 ?column? 
----------
        1
(1 row)

-- No cached connections, so no records should be output.
--Testcase 406:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;
 server_name 
-------------
(0 rows)

-- This test case is for closing the connection in pgfdw_xact_callback
-- BEGIN;
-- Connection xact depth becomes 1 i.e. the connection is in midst of the xact.
--Testcase 407:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

--Testcase 408:
SELECT 1 FROM ft7 LIMIT 1;
 ?column? 
----------
        1
(1 row)

-- List all the existing cached connections. parquet_s3_srv and parquet_s3_srv_3 should be
-- output.
--Testcase 409:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;  -- return 0 rows if not use minio/s3 servers.
 server_name 
-------------
(0 rows)

-- Connections are not closed at the end of the alter and drop statements.
-- That's because the connections are in midst of this xact,
-- they are just marked as invalid in pgfdw_inval_callback.
ALTER SERVER parquet_s3_srv OPTIONS (ADD use_remote_estimate 'off');
--Testcase 410:
DROP SERVER parquet_s3_srv_3 CASCADE;
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:3243: NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to user mapping for public on server parquet_s3_srv_3
drop cascades to foreign table ft7
-- List all the existing cached connections. parquet_s3_srv and parquet_s3_srv_3
-- should be output as invalid connections. Also the server name for
-- parquet_s3_srv_3 should be NULL because the server was dropped.
--Testcase 411:
SELECT * FROM parquet_s3_fdw_get_connections() ORDER BY 1;  -- return 0 rows if not use minio/s3 servers.
 server_name | valid 
-------------+-------
(0 rows)

-- The invalid connections get closed in pgfdw_xact_callback during commit.
-- COMMIT;
-- All cached connections were closed while committing above xact, so no
-- records should be output.
-- SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;
-- =======================================================================
-- test parquet_s3_fdw_disconnect and parquet_s3_fdw_disconnect_all functions
-- with local parquet file (not on minio/s3 servers). It haven't server and connection.
-- =======================================================================
-- BEGIN;
-- Let's ensure to close all the existing cached connections.
--Testcase 412:
SELECT 1 FROM parquet_s3_fdw_disconnect_all();
 ?column? 
----------
        1
(1 row)

-- Ensure to cache parquet_s3_srv connection.
--Testcase 413:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

-- Ensure to cache parquet_s3_srv_2 connection.
--Testcase 414:
SELECT 1 FROM ft6 LIMIT 1;
 ?column? 
----------
        1
(1 row)

-- List all the existing cached connections. parquet_s3_srv and parquet_s3_srv_2 should be
-- output.
--Testcase 415:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;  -- return 0 rows if not use minio/s3 servers.
 server_name 
-------------
(0 rows)

-- Issue a warning and return false as parquet_s3_srv connection is still in use and
-- can not be closed.
-- SELECT parquet_s3_fdw_disconnect('parquet_s3_srv');
-- List all the existing cached connections. parquet_s3_srv and parquet_s3_srv_2 should be
-- output.
--Testcase 416:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;  -- return 0 rows if not use minio/s3 servers.
 server_name 
-------------
(0 rows)

-- Return false as connections are still in use, warnings are issued.
-- But disable warnings temporarily because the order of them is not stable.
-- SET client_min_messages = 'ERROR';
-- SELECT parquet_s3_fdw_disconnect_all();
-- RESET client_min_messages;
-- COMMIT;
-- Ensure that parquet_s3_srv_2 connection is closed.
--Testcase 417:
SELECT 1 FROM parquet_s3_fdw_disconnect('parquet_s3_srv_2');
 ?column? 
----------
        1
(1 row)

--Testcase 418:
SELECT server_name FROM parquet_s3_fdw_get_connections() WHERE server_name = 'parquet_s3_srv_2';
 server_name 
-------------
(0 rows)

-- Return false as parquet_s3_srv_2 connection is closed already.
--Testcase 419:
SELECT parquet_s3_fdw_disconnect('parquet_s3_srv_2');
 parquet_s3_fdw_disconnect 
---------------------------
 f
(1 row)

-- Return an error as there is no foreign server with given name.
--Testcase 420:
SELECT parquet_s3_fdw_disconnect('unknownserver');
psql:sql/14.0/schemaless/parquet_s3_fdw_post.sql:3296: ERROR:  server "unknownserver" does not exist
-- Let's ensure to close all the existing cached connections.
--Testcase 421:
SELECT 1 FROM parquet_s3_fdw_disconnect_all();
 ?column? 
----------
        1
(1 row)

-- No cached connections, so no records should be output.
--Testcase 422:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;
 server_name 
-------------
(0 rows)

-- =============================================================================
-- test case for having multiple cached connections for a foreign server
-- with local parquet file (not on minio/s3 servers). It haven't server and connection.
-- =============================================================================
--Testcase 423:
CREATE ROLE regress_multi_conn_user1 SUPERUSER;
--Testcase 424:
CREATE ROLE regress_multi_conn_user2 SUPERUSER;
--Testcase 425:
CREATE USER MAPPING FOR regress_multi_conn_user1 SERVER parquet_s3_srv :USER_PASSWORD;
--Testcase 426:
CREATE USER MAPPING FOR regress_multi_conn_user2 SERVER parquet_s3_srv :USER_PASSWORD;
-- BEGIN;
-- Will cache parquet_s3_srv connection with user mapping for regress_multi_conn_user1
SET ROLE regress_multi_conn_user1;
--Testcase 427:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

RESET ROLE;
-- Will cache parquet_s3_srv connection with user mapping for regress_multi_conn_user2
SET ROLE regress_multi_conn_user2;
--Testcase 428:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

RESET ROLE;
-- Should output two connections for parquet_s3_srv server
--Testcase 429:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1; -- return 0 rows if not use minio/s3 servers.
 server_name 
-------------
(0 rows)

-- COMMIT;
-- Let's ensure to close all the existing cached connections.
--Testcase 430:
SELECT 1 FROM parquet_s3_fdw_disconnect_all();
 ?column? 
----------
        1
(1 row)

-- No cached connections, so no records should be output.
--Testcase 431:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1; 
 server_name 
-------------
(0 rows)

-- Clean up
--Testcase 432:
DROP USER MAPPING FOR regress_multi_conn_user1 SERVER parquet_s3_srv;
--Testcase 433:
DROP USER MAPPING FOR regress_multi_conn_user2 SERVER parquet_s3_srv;
--Testcase 434:
DROP ROLE regress_multi_conn_user1;
--Testcase 435:
DROP ROLE regress_multi_conn_user2;
-- ===================================================================
-- Test foreign server level option keep_connections
-- ===================================================================
-- By default, the connections associated with foreign server are cached i.e.
-- keep_connections option is on. Set it to off.
ALTER SERVER parquet_s3_srv OPTIONS (keep_connections 'off');
-- connection to parquet_s3_srv server is closed at the end of xact
-- as keep_connections was set to off.
--Testcase 436:
SELECT 1 FROM ft1 LIMIT 1;
 ?column? 
----------
        1
(1 row)

-- No cached connections, so no records should be output.
--Testcase 437:
SELECT server_name FROM parquet_s3_fdw_get_connections() ORDER BY 1;
 server_name 
-------------
(0 rows)

ALTER SERVER parquet_s3_srv OPTIONS (SET keep_connections 'on');
-- ===================================================================
-- batch insert
-- ===================================================================
-- BEGIN;
-- CREATE SERVER batch10 FOREIGN DATA WRAPPER postgres_fdw OPTIONS( batch_size '10' );
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'batch10'
-- AND srvoptions @> array['batch_size=10'];
-- ALTER SERVER batch10 OPTIONS( SET batch_size '20' );
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'batch10'
-- AND srvoptions @> array['batch_size=10'];
-- SELECT count(*)
-- FROM pg_foreign_server
-- WHERE srvname = 'batch10'
-- AND srvoptions @> array['batch_size=20'];
-- CREATE FOREIGN TABLE table30 ( x int ) SERVER batch10 OPTIONS ( batch_size '30' );
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30'::regclass
-- AND ftoptions @> array['batch_size=30'];
-- ALTER FOREIGN TABLE table30 OPTIONS ( SET batch_size '40');
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30'::regclass
-- AND ftoptions @> array['batch_size=30'];
-- SELECT COUNT(*)
-- FROM pg_foreign_table
-- WHERE ftrelid = 'table30'::regclass
-- AND ftoptions @> array['batch_size=40'];
-- ROLLBACK;
-- CREATE TABLE batch_table ( x int );
-- CREATE FOREIGN TABLE ftable ( x int ) SERVER loopback OPTIONS ( table_name 'batch_table', batch_size '10' );
-- EXPLAIN (VERBOSE, COSTS OFF) INSERT INTO ftable SELECT * FROM generate_series(1, 10) i;
-- INSERT INTO ftable SELECT * FROM generate_series(1, 10) i;
-- INSERT INTO ftable SELECT * FROM generate_series(11, 31) i;
-- INSERT INTO ftable VALUES (32);
-- INSERT INTO ftable VALUES (33), (34);
-- SELECT COUNT(*) FROM ftable;
-- TRUNCATE batch_table;
-- DROP FOREIGN TABLE ftable;
-- -- try if large batches exceed max number of bind parameters
-- CREATE FOREIGN TABLE ftable ( x int ) SERVER loopback OPTIONS ( table_name 'batch_table', batch_size '100000' );
-- INSERT INTO ftable SELECT * FROM generate_series(1, 70000) i;
-- SELECT COUNT(*) FROM ftable;
-- TRUNCATE batch_table;
-- DROP FOREIGN TABLE ftable;
-- Disable batch insert
-- CREATE FOREIGN TABLE ftable ( x int ) SERVER loopback OPTIONS ( table_name 'batch_table', batch_size '1' );
-- EXPLAIN (VERBOSE, COSTS OFF) INSERT INTO ftable VALUES (1), (2);
-- INSERT INTO ftable VALUES (1), (2);
-- SELECT COUNT(*) FROM ftable;
-- DROP FOREIGN TABLE ftable;
-- DROP TABLE batch_table;
-- Use partitioning
-- CREATE TABLE batch_table ( x int ) PARTITION BY HASH (x);
-- CREATE TABLE batch_table_p0 (LIKE batch_table);
-- CREATE FOREIGN TABLE batch_table_p0f
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 3, REMAINDER 0)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_table_p0', batch_size '10');
-- CREATE TABLE batch_table_p1 (LIKE batch_table);
-- CREATE FOREIGN TABLE batch_table_p1f
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 3, REMAINDER 1)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_table_p1', batch_size '1');
-- CREATE TABLE batch_table_p2
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 3, REMAINDER 2);
-- INSERT INTO batch_table SELECT * FROM generate_series(1, 66) i;
-- SELECT COUNT(*) FROM batch_table;
-- Check that enabling batched inserts doesn't interfere with cross-partition
-- updates
-- CREATE TABLE batch_cp_upd_test (a int) PARTITION BY LIST (a);
-- CREATE TABLE batch_cp_upd_test1 (LIKE batch_cp_upd_test);
-- CREATE FOREIGN TABLE batch_cp_upd_test1_f
-- 	PARTITION OF batch_cp_upd_test
-- 	FOR VALUES IN (1)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_cp_upd_test1', batch_size '10');
-- CREATE TABLE batch_cp_up_test1 PARTITION OF batch_cp_upd_test
-- 	FOR VALUES IN (2);
-- INSERT INTO batch_cp_upd_test VALUES (1), (2);
-- The following moves a row from the local partition to the foreign one
-- UPDATE batch_cp_upd_test t SET a = 1 FROM (VALUES (1), (2)) s(a) WHERE t.a = s.a;
-- SELECT tableoid::regclass, * FROM batch_cp_upd_test;
-- Clean up
-- DROP TABLE batch_table, batch_cp_upd_test, batch_table_p0, batch_table_p1 CASCADE;
-- -- Use partitioning
-- ALTER SERVER loopback OPTIONS (ADD batch_size '10');
-- CREATE TABLE batch_table ( x int, field1 text, field2 text) PARTITION BY HASH (x);
-- CREATE TABLE batch_table_p0 (LIKE batch_table);
-- ALTER TABLE batch_table_p0 ADD CONSTRAINT p0_pkey PRIMARY KEY (x);
-- CREATE FOREIGN TABLE batch_table_p0f
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 2, REMAINDER 0)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_table_p0');
-- CREATE TABLE batch_table_p1 (LIKE batch_table);
-- ALTER TABLE batch_table_p1 ADD CONSTRAINT p1_pkey PRIMARY KEY (x);
-- CREATE FOREIGN TABLE batch_table_p1f
-- 	PARTITION OF batch_table
-- 	FOR VALUES WITH (MODULUS 2, REMAINDER 1)
-- 	SERVER loopback
-- 	OPTIONS (table_name 'batch_table_p1');
-- INSERT INTO batch_table SELECT i, 'test'||i, 'test'|| i FROM generate_series(1, 50) i;
-- SELECT COUNT(*) FROM batch_table;
-- SELECT * FROM batch_table ORDER BY x;
-- ALTER SERVER loopback OPTIONS (DROP batch_size);
-- ===================================================================
-- test asynchronous execution
-- ===================================================================
-- ALTER SERVER loopback OPTIONS (DROP extensions);
-- ALTER SERVER loopback OPTIONS (ADD async_capable 'true');
-- ALTER SERVER loopback2 OPTIONS (ADD async_capable 'true');
-- CREATE TABLE async_pt (a int, b int, c text) PARTITION BY RANGE (a);
-- CREATE TABLE base_tbl1 (a int, b int, c text);
-- CREATE TABLE base_tbl2 (a int, b int, c text);
-- CREATE FOREIGN TABLE async_p1 PARTITION OF async_pt FOR VALUES FROM (1000) TO (2000)
--   SERVER loopback OPTIONS (table_name 'base_tbl1');
-- CREATE FOREIGN TABLE async_p2 PARTITION OF async_pt FOR VALUES FROM (2000) TO (3000)
--   SERVER loopback2 OPTIONS (table_name 'base_tbl2');
-- INSERT INTO async_p1 SELECT 1000 + i, i, to_char(i, 'FM0000') FROM generate_series(0, 999, 5) i;
-- INSERT INTO async_p2 SELECT 2000 + i, i, to_char(i, 'FM0000') FROM generate_series(0, 999, 5) i;
-- ANALYZE async_pt;
-- simple queries
-- CREATE TABLE result_tbl (a int, b int, c text);
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b % 100 = 0;
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b % 100 = 0;
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- Check case where multiple partitions use the same connection
-- CREATE TABLE base_tbl3 (a int, b int, c text);
-- CREATE FOREIGN TABLE async_p3 PARTITION OF async_pt FOR VALUES FROM (3000) TO (4000)
--   SERVER loopback2 OPTIONS (table_name 'base_tbl3');
-- INSERT INTO async_p3 SELECT 3000 + i, i, to_char(i, 'FM0000') FROM generate_series(0, 999, 5) i;
-- ANALYZE async_pt;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- DROP FOREIGN TABLE async_p3;
-- DROP TABLE base_tbl3;
-- Check case where the partitioned table has local/remote partitions
-- CREATE TABLE async_p3 PARTITION OF async_pt FOR VALUES FROM (3000) TO (4000);
-- INSERT INTO async_p3 SELECT 3000 + i, i, to_char(i, 'FM0000') FROM generate_series(0, 999, 5) i;
-- ANALYZE async_pt;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- INSERT INTO result_tbl SELECT * FROM async_pt WHERE b === 505;
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- partitionwise joins
-- SET enable_partitionwise_join TO true;
-- CREATE TABLE join_tbl (a1 int, b1 int, v->>'c1' text, a2 int, b2 int, c2 text);
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO join_tbl SELECT * FROM async_pt t1, async_pt t2 WHERE t1.a = t2.a AND t1.b = t2.b AND t1.b % 100 = 0;
-- INSERT INTO join_tbl SELECT * FROM async_pt t1, async_pt t2 WHERE t1.a = t2.a AND t1.b = t2.b AND t1.b % 100 = 0;
-- SELECT * FROM join_tbl ORDER BY a1;
-- DELETE FROM join_tbl;
-- RESET enable_partitionwise_join;
-- Test rescan of an async Append node with do_exec_prune=false
-- SET enable_hashjoin TO false;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO join_tbl SELECT * FROM async_p1 t1, async_pt t2 WHERE t1.a = t2.a AND t1.b = t2.b AND t1.b % 100 = 0;
-- INSERT INTO join_tbl SELECT * FROM async_p1 t1, async_pt t2 WHERE t1.a = t2.a AND t1.b = t2.b AND t1.b % 100 = 0;
-- SELECT * FROM join_tbl ORDER BY a1;
-- DELETE FROM join_tbl;
-- RESET enable_hashjoin;
-- Test interaction of async execution with plan-time partition pruning
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM async_pt WHERE a < 3000;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM async_pt WHERE a < 2000;
-- Test interaction of async execution with run-time partition pruning
-- SET plan_cache_mode TO force_generic_plan;
-- PREPARE async_pt_query (int, int) AS
--   INSERT INTO result_tbl SELECT * FROM async_pt WHERE a < $1 AND b === $2;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- EXECUTE async_pt_query (3000, 505);
-- EXECUTE async_pt_query (3000, 505);
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- EXECUTE async_pt_query (2000, 505);
-- EXECUTE async_pt_query (2000, 505);
-- SELECT * FROM result_tbl ORDER BY a;
-- DELETE FROM result_tbl;
-- RESET plan_cache_mode;
-- CREATE TABLE local_tbl(a int, b int, c text);
-- INSERT INTO local_tbl VALUES (1505, 505, 'foo'), (2505, 505, 'bar');
-- ANALYZE local_tbl;
-- CREATE INDEX base_tbl1_idx ON base_tbl1 (a);
-- CREATE INDEX base_tbl2_idx ON base_tbl2 (a);
-- CREATE INDEX async_p3_idx ON async_p3 (a);
-- ANALYZE base_tbl1;
-- ANALYZE base_tbl2;
-- ANALYZE async_p3;
-- ALTER FOREIGN TABLE async_p1 OPTIONS (use_remote_estimate 'true');
-- ALTER FOREIGN TABLE async_p2 OPTIONS (use_remote_estimate 'true');
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM local_tbl, async_pt WHERE local_tbl.a = async_pt.a AND local_tbl.c = 'bar';
-- EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-- SELECT * FROM local_tbl, async_pt WHERE local_tbl.a = async_pt.a AND local_tbl.c = 'bar';
-- SELECT * FROM local_tbl, async_pt WHERE local_tbl.a = async_pt.a AND local_tbl.c = 'bar';
-- ALTER FOREIGN TABLE async_p1 OPTIONS (DROP use_remote_estimate);
-- ALTER FOREIGN TABLE async_p2 OPTIONS (DROP use_remote_estimate);
-- DROP TABLE local_tbl;
-- DROP INDEX base_tbl1_idx;
-- DROP INDEX base_tbl2_idx;
-- DROP INDEX async_p3_idx;
-- Test that pending requests are processed properly
-- SET enable_mergejoin TO false;
-- SET enable_hashjoin TO false;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM async_pt t1, async_p2 t2 WHERE t1.a = t2.a AND t1.b === 505;
-- SELECT * FROM async_pt t1, async_p2 t2 WHERE t1.a = t2.a AND t1.b === 505;
-- CREATE TABLE local_tbl (a int, b int, c text);
-- INSERT INTO local_tbl VALUES (1505, 505, 'foo');
-- ANALYZE local_tbl;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM local_tbl t1 LEFT JOIN (SELECT *, (SELECT count(*) FROM async_pt WHERE a < 3000) FROM async_pt WHERE a < 3000) t2 ON t1.a = t2.a;
-- EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-- SELECT * FROM local_tbl t1 LEFT JOIN (SELECT *, (SELECT count(*) FROM async_pt WHERE a < 3000) FROM async_pt WHERE a < 3000) t2 ON t1.a = t2.a;
-- SELECT * FROM local_tbl t1 LEFT JOIN (SELECT *, (SELECT count(*) FROM async_pt WHERE a < 3000) FROM async_pt WHERE a < 3000) t2 ON t1.a = t2.a;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- SELECT * FROM async_pt t1 WHERE t1.b === 505 LIMIT 1;
-- EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-- SELECT * FROM async_pt t1 WHERE t1.b === 505 LIMIT 1;
-- SELECT * FROM async_pt t1 WHERE t1.b === 505 LIMIT 1;
-- Check with foreign modify
-- CREATE TABLE base_tbl3 (a int, b int, c text);
-- CREATE FOREIGN TABLE remote_tbl (a int, b int, c text)
--   SERVER loopback OPTIONS (table_name 'base_tbl3');
-- INSERT INTO remote_tbl VALUES (2505, 505, 'bar');
-- CREATE TABLE base_tbl4 (a int, b int, c text);
-- CREATE FOREIGN TABLE insert_tbl (a int, b int, c text)
--   SERVER loopback OPTIONS (table_name 'base_tbl4');
-- EXPLAIN (VERBOSE, COSTS OFF)
-- INSERT INTO insert_tbl (SELECT * FROM local_tbl UNION ALL SELECT * FROM remote_tbl);
-- INSERT INTO insert_tbl (SELECT * FROM local_tbl UNION ALL SELECT * FROM remote_tbl);
-- SELECT * FROM insert_tbl ORDER BY a;
-- Check with direct modify
-- EXPLAIN (VERBOSE, COSTS OFF)
-- WITH t AS (UPDATE remote_tbl SET c = c || c RETURNING *)
-- INSERT INTO join_tbl SELECT * FROM async_pt LEFT JOIN t ON (async_pt.a = t.a AND async_pt.b = t.b) WHERE async_pt.b === 505;
-- WITH t AS (UPDATE remote_tbl SET c = c || c RETURNING *)
-- INSERT INTO join_tbl SELECT * FROM async_pt LEFT JOIN t ON (async_pt.a = t.a AND async_pt.b = t.b) WHERE async_pt.b === 505;
-- SELECT * FROM join_tbl ORDER BY a1;
-- DELETE FROM join_tbl;
-- DROP TABLE local_tbl;
-- DROP FOREIGN TABLE remote_tbl;
-- DROP FOREIGN TABLE insert_tbl;
-- DROP TABLE base_tbl3;
-- DROP TABLE base_tbl4;
-- RESET enable_mergejoin;
-- RESET enable_hashjoin;
-- Test that UPDATE/DELETE with inherited target works with async_capable enabled
-- EXPLAIN (VERBOSE, COSTS OFF)
-- UPDATE async_pt SET c = c || c WHERE b = 0 RETURNING *;
-- UPDATE async_pt SET c = c || c WHERE b = 0 RETURNING *;
-- EXPLAIN (VERBOSE, COSTS OFF)
-- DELETE FROM async_pt WHERE b = 0 RETURNING *;
-- DELETE FROM async_pt WHERE b = 0 RETURNING *;
-- Check EXPLAIN ANALYZE for a query that scans empty partitions asynchronously
-- DELETE FROM async_p1;
-- DELETE FROM async_p2;
-- DELETE FROM async_p3;
-- EXPLAIN (ANALYZE, COSTS OFF, SUMMARY OFF, TIMING OFF)
-- SELECT * FROM async_pt;
-- Clean up
-- DROP TABLE async_pt;
-- DROP TABLE base_tbl1;
-- DROP TABLE base_tbl2;
-- DROP TABLE result_tbl;
-- DROP TABLE join_tbl;
-- ALTER SERVER loopback OPTIONS (DROP async_capable);
-- ALTER SERVER loopback2 OPTIONS (DROP async_capable);
-- ===================================================================
-- test invalid server and foreign table options
-- ===================================================================
-- Invalid fdw_startup_cost option
-- CREATE SERVER inv_scst FOREIGN DATA WRAPPER postgres_fdw
-- 	OPTIONS(fdw_startup_cost '100$%$#$#');
-- -- Invalid fdw_tuple_cost option
-- CREATE SERVER inv_scst FOREIGN DATA WRAPPER postgres_fdw
-- 	OPTIONS(fdw_tuple_cost '100$%$#$#');
-- -- Invalid fetch_size option
-- CREATE FOREIGN TABLE inv_fsz (c1 int )
-- 	SERVER loopback OPTIONS (fetch_size '100$%$#$#');
-- -- Invalid batch_size option
-- CREATE FOREIGN TABLE inv_bsz (c1 int )
-- 	SERVER loopback OPTIONS (batch_size '100$%$#$#');
-- Clean-up
SET client_min_messages TO WARNING;
--Testcase 438:
DROP TYPE user_enum;
--Testcase 439:
DROP SCHEMA "S 1" CASCADE;
--Testcase 440:
DROP SCHEMA import_dest1 CASCADE;
--Testcase 441:
DROP USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv;
--Testcase 442:
DROP USER MAPPING FOR CURRENT_USER SERVER parquet_s3_srv_2;
--Testcase 443:
DROP SERVER parquet_s3_srv CASCADE;
--Testcase 444:
DROP SERVER parquet_s3_srv_2 CASCADE;
--Testcase 445:
DROP EXTENSION parquet_s3_fdw CASCADE;
